/* Test: cc_block_any returns first successful task with correct result.
   NOTE: Due to async runtime limitations (cc_sleep_ms blocks the polling thread),
   timing-based "fastest wins" is not guaranteed. This test verifies correctness:
   - winner is valid (0, 1, or 2)
   - result matches the winner's return value */
#include <ccc/cc_runtime.cch>
#include <stdio.h>

@async int task_a(void) {
    cc_sleep_ms(10);
    return 10;
}

@async int task_b(void) {
    cc_sleep_ms(20);
    return 20;
}

@async int task_c(void) {
    cc_sleep_ms(30);
    return 30;
}

int main(void) {
    CCTaskIntptr tasks[] = {
        task_a(),  /* index 0, returns 10 */
        task_b(),  /* index 1, returns 20 */
        task_c()   /* index 2, returns 30 */
    };

    int winner = -1;
    intptr_t result = 0;
    int err = cc_block_any(3, tasks, &winner, &result);

    printf("err=%d, winner=%d, result=%d\n", err, winner, (int)result);

    if (err != 0) return 1;
    
    /* Verify winner is valid and result matches */
    if (winner == 0) {
        if (result != 10) return 2;
    } else if (winner == 1) {
        if (result != 20) return 3;
    } else if (winner == 2) {
        if (result != 30) return 4;
    } else {
        return 5;  /* invalid winner */
    }

    printf("Result: PASS (winner=%d)\n", winner);
    return 0;
}

// Test: Owned channel syntax T[~N owned { ... }]
#include <ccc/std/prelude.cch>
#include <assert.h>

static int g_create_count = 0;
static int g_destroy_count = 0;
static int g_reset_count = 0;

// Custom type for Test 3 - must be at file scope for closures
typedef struct {
    int id;
    char data[60];
} PoolItem;

static int g_next_id = 1;

int main(void) {
    printf("Test 1: Basic owned channel syntax\n");
    fflush(stdout);
    {
        // Declare owned channel with lifecycle closures - using typed parameters
        void*[~4 owned {
            .create = []() => {
                g_create_count++;
                void* p = malloc(64);
                printf("  create: p=%p\n", p);
                return p;
            },
            .destroy = [](void* p) => {
                g_destroy_count++;
                printf("  destroy: p=%p\n", p);
                free(p);
                return NULL;
            },
            .reset = [](void* p) => {
                g_reset_count++;
                printf("  reset: p=%p\n", p);
                return NULL;
            }
        }] pool;
        
        assert(pool != NULL);
        printf("  pool created: %p\n", (void*)pool);
        fflush(stdout);
        
        // Recv from empty pool - should create
        void* r1 = NULL;
        int rc = cc_chan_recv(pool, &r1, sizeof(r1));
        assert(rc == 0);
        assert(g_create_count == 1);
        assert(r1 != NULL);
        printf("  recv 1: item=%p, creates=%d\n", r1, g_create_count);
        fflush(stdout);
        
        // Return to pool
        rc = cc_chan_send(pool, &r1, sizeof(r1));
        assert(rc == 0);
        assert(g_reset_count == 1);
        printf("  send 1: returned, resets=%d\n", g_reset_count);
        fflush(stdout);
        
        // Recv again - should get from pool
        void* r2 = NULL;
        rc = cc_chan_recv(pool, &r2, sizeof(r2));
        assert(rc == 0);
        assert(g_create_count == 1);  // No new create
        printf("  recv 2: item=%p (from pool), creates=%d\n", r2, g_create_count);
        fflush(stdout);
        
        // Return it
        rc = cc_chan_send(pool, &r2, sizeof(r2));
        assert(rc == 0);
        printf("  send 2: returned\n");
        fflush(stdout);
        
        // Free pool
        printf("  freeing pool...\n");
        fflush(stdout);
        cc_chan_free(pool);
        printf("  freed, destroys=%d\n", g_destroy_count);
        fflush(stdout);
        
        printf("Test 1: PASSED\n");
    }
    
    printf("Test 2: Expression capacity with typed parameters\n");
    fflush(stdout);
    {
        int cap = 2;
        int extra = 2;
        
        // Test expression capacity like (cap + extra)
        void*[~(cap + extra) owned {
            .create = []() => {
                return malloc(64);
            },
            .destroy = [](void* p) => {
                free(p);
                return NULL;
            },
            .reset = [](void* p) => {
                memset(p, 0, 64);
                return NULL;
            }
        }] item_pool;
        
        // Get item from pool
        void* item = NULL;
        cc_chan_recv(item_pool, &item, sizeof(item));
        assert(item != NULL);
        printf("  got item: %p\n", item);
        
        // Return to pool
        cc_chan_send(item_pool, &item, sizeof(item));
        
        // Get again
        cc_chan_recv(item_pool, &item, sizeof(item));
        printf("  got item again: %p\n", item);
        
        cc_chan_send(item_pool, &item, sizeof(item));
        cc_chan_free(item_pool);
        
        printf("Test 2: PASSED\n");
    }
    
    printf("Test 3: Custom struct type with typed closures\n");
    fflush(stdout);
    {
        // Pool of PoolItem* with fully typed closures - no intptr_t casts needed!
        PoolItem*[~4 owned {
            .create = []() => {
                PoolItem* item = (PoolItem*)malloc(sizeof(PoolItem));
                item->id = g_next_id++;
                memset(item->data, 0, sizeof(item->data));
                printf("  create: item id=%d\n", item->id);
                return item;
            },
            .destroy = [](PoolItem* item) => {
                printf("  destroy: item id=%d\n", item->id);
                free(item);
                return NULL;
            },
            .reset = [](PoolItem* item) => {
                printf("  reset: item id=%d\n", item->id);
                memset(item->data, 0, sizeof(item->data));
                return NULL;
            }
        }] item_pool;
        
        // Get items
        PoolItem* a = NULL;
        PoolItem* b = NULL;
        cc_chan_recv(item_pool, &a, sizeof(a));
        cc_chan_recv(item_pool, &b, sizeof(b));
        assert(a->id == 1);
        assert(b->id == 2);
        printf("  got items: a.id=%d, b.id=%d\n", a->id, b->id);
        
        // Use them
        strcpy(a->data, "hello");
        strcpy(b->data, "world");
        
        // Return to pool
        cc_chan_send(item_pool, &a, sizeof(a));
        cc_chan_send(item_pool, &b, sizeof(b));
        
        // Get again - should be reset
        cc_chan_recv(item_pool, &a, sizeof(a));
        assert(a->data[0] == 0);  // Data was reset
        printf("  got item again: id=%d, data reset=%s\n", a->id, a->data[0] == 0 ? "yes" : "no");
        
        cc_chan_send(item_pool, &a, sizeof(a));
        cc_chan_free(item_pool);
        
        printf("Test 3: PASSED\n");
    }
    
    printf("\nowned_channel_syntax_smoke: ALL TESTS PASSED\n");
    return 0;
}

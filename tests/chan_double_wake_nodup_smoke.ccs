/*
 * Stress double-wake race: sender wake and close wake target same waiter.
 *
 * The recv operation must complete exactly once (data or closed), with no hang.
 */
#include <ccc/cc_runtime.cch>
#include <ccc/cc_channel.cch>
#include <ccc/cc_atomic.cch>

#include <errno.h>
#include <stdio.h>

#define REPEATS 40

cc_atomic_int g_errors = 0;
cc_atomic_int g_recv_data = 0;
cc_atomic_int g_recv_closed = 0;
cc_atomic_int g_recv_timeout = 0;

int main(void) {
    cc_sched_set_num_workers(2);

    for (int rep = 0; rep < REPEATS; rep++) {
        if ((rep % 1000) == 0) {
            fprintf(stderr, "iter %d/%d\n", rep, REPEATS);
        }

        int[~ >] tx;
        int[~ <] rx;
        CCChan* ch = channel_pair(&tx, &rx);

        @nursery {
            spawn(() => [rx] {
                int v = -1;
                CCDeadline d = cc_deadline_after_ms(40);
                int rc = cc_chan_deadline_recv(rx.raw, &v, sizeof(int), &d);
                if (rc == 0) {
                    cc_atomic_fetch_add(&g_recv_data, 1);
                } else if (rc == EPIPE) {
                    cc_atomic_fetch_add(&g_recv_closed, 1);
                } else if (rc == ETIMEDOUT) {
                    cc_atomic_fetch_add(&g_recv_timeout, 1);
                } else {
                    cc_atomic_fetch_add(&g_errors, 1);
                }
            });
            spawn(() => [tx] {
                cc_sleep_ms(1);
                int v = 23;
                CCDeadline d = cc_deadline_after_ms(40);
                int rc = cc_chan_deadline_send(tx.raw, &v, sizeof(int), &d);
                /* Sender may succeed or lose to close/deadline; disallow unrelated errors. */
                if (!(rc == 0 || rc == EPIPE || rc == ETIMEDOUT)) {
                    cc_atomic_fetch_add(&g_errors, 1);
                }
            });
            spawn(() => [tx] {
                cc_sleep_ms(1);
                tx.close();
            });
        }

        tx.close();
        cc_chan_free(ch);

        if (cc_atomic_load(&g_errors) != 0) break;
    }

    if (cc_atomic_load(&g_errors) == 0) {
        fprintf(stderr, "double_wake outcomes: data=%d closed=%d\n",
                cc_atomic_load(&g_recv_data),
                cc_atomic_load(&g_recv_closed));
        fprintf(stderr, "double_wake timeouts: %d\n",
                cc_atomic_load(&g_recv_timeout));
    }
    return cc_atomic_load(&g_errors) == 0 ? 0 : 1;
}

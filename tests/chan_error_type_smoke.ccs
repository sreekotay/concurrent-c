// Test: Error channels - Result types can be channel element types
#include <ccc/std/prelude.cch>
#include <assert.h>

typedef struct {
    int code;
    const char* msg;
} ParseError;

int !> (ParseError) ok_value(void) {
    return cc_ok(42);
}

int !> (ParseError) err_value(void) {
    ParseError err = {.code = 1, .msg = "parse failed"};
    return cc_err(err);
}

int main(void) {
    // Create a buffered channel that sends Result types
    CCResult_int_ParseError[~ 4 >] tx;  // Buffer 4 items
    CCResult_int_ParseError[~ 4 <] rx;
    CCChan* ch = channel_pair(&tx, &rx);
    
    // Create and send a success value
    int !> (ParseError) ok_val = ok_value();
    assert(cc_io_avail(chan_send(tx, ok_val)));  // should succeed

    // Create and send an error value
    int !> (ParseError) err_val = err_value();
    assert(cc_io_avail(chan_send(tx, err_val)));  // should succeed
    
    // Receive using the raw channel API
    int !> (ParseError) r1;
    int rr1 = cc_chan_recv(rx.raw, &r1, sizeof(r1));
    assert(rr1 == 0);  // 0 = success
    assert(r1.ok);  // Should be success result
    assert(r1.u.value == 42);
    
    int !> (ParseError) r2;
    int rr2 = cc_chan_recv(rx.raw, &r2, sizeof(r2));
    assert(rr2 == 0);  // 0 = success
    assert(!r2.ok);  // Should be error result
    // Note: r2.u.error.code == 1 in actual execution (custom error fields work at runtime)
    
    chan_close(tx);
    cc_chan_free(ch);
    
    printf("chan_error_type_smoke: OK\n");
    return 0;
}

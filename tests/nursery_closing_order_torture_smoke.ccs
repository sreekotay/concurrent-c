#include "cc_runtime.cch"
#include "cc_channel.cch"

#include <errno.h>
#include <unistd.h>

static volatile int g_err = 0;
static volatile int g_sum = 0;

void producer(CCChan* ch1, CCChan* ch2) {
    int e = 0;
    // Send a sequence across both channels. If closing happens before join, we'll hit EPIPE.
    for (int i = 1; i <= 20; i++) {
        int v1 = i;
        e = cc_chan_send(ch1, &v1, sizeof(v1));
        if (e != 0) { g_err = e; return; }

        // Keep the producer alive long enough that a buggy "close-first" will trip.
        usleep(2 * 1000);

        int v2 = i * 10;
        e = cc_chan_send(ch2, &v2, sizeof(v2));
        if (e != 0) { g_err = e; return; }
    }
}

void consumer(CCChan* ch1, CCChan* ch2) {
    int e = 0;
    for (int i = 1; i <= 20; i++) {
        int v = 0;
        e = cc_chan_recv(ch1, &v, sizeof(v));
        if (e != 0) { g_err = e; return; }
        g_sum += v;

        v = 0;
        e = cc_chan_recv(ch2, &v, sizeof(v));
        if (e != 0) { g_err = e; return; }
        g_sum += v;
    }
}

int main(void) {
    CCChanTx ch1_tx;
    CCChanTx ch2_tx;
    CCChanRx ch1_rx;
    CCChanRx ch2_rx;
    if (cc_chan_pair_create(1, CC_CHAN_MODE_BLOCK, false, sizeof(int), &ch1_tx, &ch1_rx) != 0) return 2;
    if (cc_chan_pair_create(1, CC_CHAN_MODE_BLOCK, false, sizeof(int), &ch2_tx, &ch2_rx) != 0) return 3;

    g_err = 0;
    g_sum = 0;

    @nursery closing(ch1_tx, ch2_tx) {
        spawn(() => { producer(ch1_tx.raw, ch2_tx.raw); });
        spawn(() => { consumer(ch1_rx.raw, ch2_rx.raw); });
    }

    if (g_err != 0) return 10;

    // Expected sum: (1..20) + (10..200 step 10) = 210 + 2100 = 2310
    if (g_sum != 2310) return 11;

    // After nursery exit, both channels should now be closed.
    int tmp = 0;
    if (cc_chan_try_recv(ch1_rx.raw, &tmp, sizeof(tmp)) != EPIPE) return 12;
    if (cc_chan_try_recv(ch2_rx.raw, &tmp, sizeof(tmp)) != EPIPE) return 13;

    int v = 1;
    if (cc_chan_send(ch1_tx.raw, &v, sizeof(v)) != EPIPE) return 14;
    if (cc_chan_send(ch2_tx.raw, &v, sizeof(v)) != EPIPE) return 15;

    cc_chan_free(ch1_tx.raw);
    cc_chan_free(ch2_tx.raw);
    return 0;
}


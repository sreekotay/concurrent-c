#include <ccc/cc_runtime.cch>
#include <ccc/cc_channel.cch>

#include <errno.h>
#include <unistd.h>

static volatile int g_err = 0;
static volatile int g_sum = 0;

void producer(CCChanTx ch1_tx, CCChanTx ch2_tx) {
    int e = 0;
    // Send a sequence across both channels. If closing happens before join, we'll hit EPIPE.
    for (int i = 1; i <= 20; i++) {
        int v1 = i;
        e = chan_send(ch1_tx, v1);
        if (e != 0) { g_err = e; return; }

        // Keep the producer alive long enough that a buggy "close-first" will trip.
        usleep(2 * 1000);

        int v2 = i * 10;
        e = chan_send(ch2_tx, v2);
        if (e != 0) { g_err = e; return; }
    }
}

void consumer(CCChanRx ch1_rx, CCChanRx ch2_rx) {
    int e = 0;
    for (int i = 1; i <= 20; i++) {
        int v = 0;
        e = chan_recv(ch1_rx, &v);
        if (e != 0) { g_err = e; return; }
        g_sum += v;

        v = 0;
        e = chan_recv(ch2_rx, &v);
        if (e != 0) { g_err = e; return; }
        g_sum += v;
    }
}

int main(void) {
    CCChanTx ch1_tx;
    CCChanTx ch2_tx;
    CCChanRx ch1_rx;
    CCChanRx ch2_rx;
    if (cc_chan_pair_create(1, CC_CHAN_MODE_BLOCK, false, sizeof(int), &ch1_tx, &ch1_rx) != 0) return 2;
    if (cc_chan_pair_create(1, CC_CHAN_MODE_BLOCK, false, sizeof(int), &ch2_tx, &ch2_rx) != 0) return 3;

    g_err = 0;
    g_sum = 0;

    @nursery closing(ch1_tx, ch2_tx) {
        spawn(() => { producer(ch1_tx, ch2_tx); });
        spawn(() => { consumer(ch1_rx, ch2_rx); });
    }

    if (g_err != 0) return 10;

    // Expected sum: (1..20) + (10..200 step 10) = 210 + 2100 = 2310
    if (g_sum != 2310) return 11;

    // After nursery exit, both channels should now be closed.
    int tmp = 0;
    if (chan_try_recv(ch1_rx, &tmp) != EPIPE) return 12;
    if (chan_try_recv(ch2_rx, &tmp) != EPIPE) return 13;

    int v = 1;
    if (chan_send(ch1_tx, v) != EPIPE) return 14;
    if (chan_send(ch2_tx, v) != EPIPE) return 15;

    chan_free(ch1_tx);
    chan_free(ch2_tx);
    return 0;
}


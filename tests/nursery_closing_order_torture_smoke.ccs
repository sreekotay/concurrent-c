#include <ccc/cc_runtime.cch>
#include <ccc/cc_channel.cch>

#include <errno.h>
#include <unistd.h>

static volatile int g_err = 0;
static volatile int g_sum = 0;

void producer(CCChanTx ch1_tx, CCChanTx ch2_tx) {
    // Send a sequence across both channels. If closing happens before join, we'll hit closed.
    for (int i = 1; i <= 20; i++) {
        int v1 = i;
        if (!cc_io_avail(chan_send(ch1_tx, v1))) { g_err = 1; return; }

        // Keep the producer alive long enough that a buggy "close-first" will trip.
        usleep(2 * 1000);

        int v2 = i * 10;
        if (!cc_io_avail(chan_send(ch2_tx, v2))) { g_err = 1; return; }
    }
}

void consumer(CCChanRx ch1_rx, CCChanRx ch2_rx) {
    for (int i = 1; i <= 20; i++) {
        int v = 0;
        if (!cc_io_avail(chan_recv(ch1_rx, &v))) { g_err = 1; return; }
        g_sum += v;

        v = 0;
        if (!cc_io_avail(chan_recv(ch2_rx, &v))) { g_err = 1; return; }
        g_sum += v;
    }
}

int main(void) {
    CCChanTx ch1_tx;
    CCChanTx ch2_tx;
    CCChanRx ch1_rx;
    CCChanRx ch2_rx;
    if (cc_chan_pair_create(1, CC_CHAN_MODE_BLOCK, false, sizeof(int), &ch1_tx, &ch1_rx) != 0) return 2;
    if (cc_chan_pair_create(1, CC_CHAN_MODE_BLOCK, false, sizeof(int), &ch2_tx, &ch2_rx) != 0) return 3;

    g_err = 0;
    g_sum = 0;

    @nursery closing(ch1_tx, ch2_tx) {
        spawn(() => { producer(ch1_tx, ch2_tx); });
        spawn(() => { consumer(ch1_rx, ch2_rx); });
    }

    if (g_err != 0) return 10;

    // Expected sum: (1..20) + (10..200 step 10) = 210 + 2100 = 2310
    if (g_sum != 2310) return 11;

    // After nursery exit, both channels should now be closed.
    int tmp = 0;
    CCResult_bool_CCIoError r1 = chan_try_recv(ch1_rx, &tmp);
    if (!(cc_is_ok(r1) && !cc_unwrap(r1))) return 12;
    CCResult_bool_CCIoError r2 = chan_try_recv(ch2_rx, &tmp);
    if (!(cc_is_ok(r2) && !cc_unwrap(r2))) return 13;

    int v = 1;
    CCResult_bool_CCIoError s1 = chan_send(ch1_tx, v);
    if (!(cc_is_ok(s1) && !cc_unwrap(s1))) return 14;
    CCResult_bool_CCIoError s2 = chan_send(ch2_tx, v);
    if (!(cc_is_ok(s2) && !cc_unwrap(s2))) return 15;

    chan_free(ch1_tx);
    chan_free(ch2_tx);
    return 0;
}


#include "cc_runtime.cch"
#include "cc_channel.cch"

#include <errno.h>
#include <unistd.h>

static volatile int g_err = 0;
static volatile int g_sum = 0;

void producer(CCChan* ch1, CCChan* ch2) {
    int e = 0;
    // Send a sequence across both channels. If closing happens before join, we'll hit EPIPE.
    for (int i = 1; i <= 20; i++) {
        int v1 = i;
        e = cc_chan_send(ch1, &v1, sizeof(v1));
        if (e != 0) { g_err = e; return; }

        // Keep the producer alive long enough that a buggy "close-first" will trip.
        usleep(2 * 1000);

        int v2 = i * 10;
        e = cc_chan_send(ch2, &v2, sizeof(v2));
        if (e != 0) { g_err = e; return; }
    }
}

void consumer(CCChan* ch1, CCChan* ch2) {
    int e = 0;
    for (int i = 1; i <= 20; i++) {
        int v = 0;
        e = cc_chan_recv(ch1, &v, sizeof(v));
        if (e != 0) { g_err = e; return; }
        g_sum += v;

        v = 0;
        e = cc_chan_recv(ch2, &v, sizeof(v));
        if (e != 0) { g_err = e; return; }
        g_sum += v;
    }
}

int main(void) {
    CCChan* ch1 = cc_chan_create(1);
    CCChan* ch2 = cc_chan_create(1);
    if (!ch1 || !ch2) return 2;
    (void)cc_chan_init_elem(ch1, sizeof(int));
    (void)cc_chan_init_elem(ch2, sizeof(int));

    g_err = 0;
    g_sum = 0;

    @nursery closing(ch1, ch2) {
        spawn(() => { producer(ch1, ch2); });
        spawn(() => { consumer(ch1, ch2); });
    }

    if (g_err != 0) return 10;

    // Expected sum: (1..20) + (10..200 step 10) = 210 + 2100 = 2310
    if (g_sum != 2310) return 11;

    // After nursery exit, both channels should now be closed.
    int tmp = 0;
    if (cc_chan_try_recv(ch1, &tmp, sizeof(tmp)) != EPIPE) return 12;
    if (cc_chan_try_recv(ch2, &tmp, sizeof(tmp)) != EPIPE) return 13;

    int v = 1;
    if (cc_chan_send(ch1, &v, sizeof(v)) != EPIPE) return 14;
    if (cc_chan_send(ch2, &v, sizeof(v)) != EPIPE) return 15;

    cc_chan_free(ch1);
    cc_chan_free(ch2);
    return 0;
}


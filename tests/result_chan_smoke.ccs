/*
 * Result channel smoke test: channels carrying T !> (E) types.
 */
#include <ccc/std/prelude.cch>
#include <stdio.h>
#include <assert.h>
#include <errno.h>

// Use built-in CCError for the error type
CCResult_int_CCError[~4 >] results_tx;
CCResult_int_CCError[~4 <] results_rx;
CCChan* g_ch;

int !> (CCError) make_ok_result(void) {
    return cc_ok(42);
}

int !> (CCError) make_err_result(void) {
    return cc_err(CC_ERR_PARSE, "bad input");
}

int main(void) {
    g_ch = channel_pair(&results_tx, &results_rx);
    
    // Send a success (use non-UFCS form due to parser limitation)
    CCResult_int_CCError ok_result = make_ok_result();
    (void)chan_send(results_tx, ok_result);
    
    // Send an error
    CCResult_int_CCError err_result = make_err_result();
    (void)chan_send(results_tx, err_result);
    
    chan_close(results_tx);
    
    // Receive (use non-UFCS form due to parser limitation)
    CCResult_int_CCError r1 = {0};
    CCResult_bool_CCIoError res1 = chan_recv(results_rx, &r1);
    assert(cc_io_avail(res1) && r1.ok && "first result should be ok");
    assert(r1.u.value == 42);
    
    CCResult_int_CCError r2 = {0};
    CCResult_bool_CCIoError res2 = chan_recv(results_rx, &r2);
    assert(cc_io_avail(res2) && !r2.ok && "second result should be error");
    assert(r2.u.error.kind == CC_ERR_PARSE);
    
    cc_chan_free(g_ch);
    
    printf("result channel smoke: PASS\n");
    return 0;
}

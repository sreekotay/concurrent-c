#include <ccc/cc_runtime.cch>
#include <ccc/cc_channel.cch>

#include <errno.h>

static volatile int g_err = 0;

void producer(CCChanTx tx) {
    for (int i = 1; i <= 3; i++) {
        if (!cc_io_avail(chan_send(tx, i))) { g_err = 1; return; }
    }
}

int main(void) {
    // Capacity must be large enough to buffer producer's sends since the consumer runs after the nursery exits.
    CCChanTx ch_tx;
    CCChanRx ch_rx;
    if (cc_chan_pair_create(3, CC_CHAN_MODE_BLOCK, false, sizeof(int), &ch_tx, &ch_rx) != 0) return 2;

    g_err = 0;

    // Spawn producer(s) inside nursery; channel is closed on nursery exit.
    @nursery closing(ch_tx) {
        spawn(() => { producer(ch_tx); });
    }

    if (g_err != 0) return 10;

    // Consumer OUTSIDE nursery: drains until channel closes.
    int sum = 0;
    for (;;) {
        int v = 0;
        CCResult_bool_CCIoError res = chan_recv(ch_rx, &v);
        if (cc_io_avail(res)) { sum += v; continue; }
        if (cc_is_ok(res) && !cc_unwrap(res)) break; // closed
        return 11;
    }

    if (sum != 6) return 12;

    chan_free(ch_tx);
    return 0;
}


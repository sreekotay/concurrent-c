#include "cc_runtime.cch"
#include "cc_channel.cch"

#include <errno.h>

static volatile int g_err = 0;

void producer(CCChan* ch) {
    for (int i = 1; i <= 3; i++) {
        int v = i;
        int e = cc_chan_send(ch, &v, sizeof(v));
        if (e != 0) { g_err = e; return; }
    }
}

int main(void) {
    // Capacity must be large enough to buffer producer's sends since the consumer runs after the nursery exits.
    CCChan* ch = cc_chan_create(3);
    if (!ch) return 2;
    (void)cc_chan_init_elem(ch, sizeof(int));

    g_err = 0;

    // Spawn producer(s) inside nursery; channel is closed on nursery exit.
    @nursery closing(ch) {
        spawn(() => { producer(ch); });
    }

    if (g_err != 0) return 10;

    // Consumer OUTSIDE nursery: drains until channel closes (EPIPE).
    int sum = 0;
    for (;;) {
        int v = 0;
        int e = cc_chan_recv(ch, &v, sizeof(v));
        if (e == 0) { sum += v; continue; }
        if (e == EPIPE) break;
        return 11;
    }

    if (sum != 6) return 12;

    cc_chan_free(ch);
    return 0;
}


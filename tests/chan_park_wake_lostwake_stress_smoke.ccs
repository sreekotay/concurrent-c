/*
 * Lost-wake stress across core ยง4 park/wake windows.
 *
 * Covers:
 *  - pre-park wake race
 *  - post-commit wake path
 *  - concurrent sender-vs-close wake race
 *
 * The test is intentionally blocking (no recv deadline) so lost-wake regressions
 * surface as hangs/timeouts in the harness.
 */
#include <ccc/cc_runtime.cch>
#include <ccc/cc_channel.cch>
#include <ccc/cc_atomic.cch>

#include <errno.h>
#include <stdio.h>

#define REPEATS 1200

cc_atomic_int g_errors = 0;
cc_atomic_int g_data = 0;
cc_atomic_int g_closed = 0;

int main(void) {
    cc_sched_set_num_workers(2);

    for (int rep = 0; rep < REPEATS; rep++) {
        if ((rep % 200) == 0) {
            fprintf(stderr, "iter %d/%d\n", rep, REPEATS);
        }

        /* Case A: pre-park wake race. */
        {
            int[~ >] tx;
            int[~ <] rx;
            CCChan* ch = channel_pair(&tx, &rx);
            @nursery {
                spawn(() => [rx] {
                    int v = -1;
                    int rc = cc_chan_recv(rx.raw, &v, sizeof(int));
                    if (rc == 0 && v == 7) cc_atomic_fetch_add(&g_data, 1);
                    else cc_atomic_fetch_add(&g_errors, 1);
                });
                spawn(() => [tx] {
                    int v = 7;
                    int rc = cc_chan_send(tx.raw, &v, sizeof(int));
                    if (rc != 0) cc_atomic_fetch_add(&g_errors, 1);
                });
            }
            tx.close();
            cc_chan_free(ch);
        }

        /* Case B: post-commit wake path. */
        {
            int[~ >] tx;
            int[~ <] rx;
            CCChan* ch = channel_pair(&tx, &rx);
            @nursery {
                spawn(() => [rx] {
                    int v = -1;
                    int rc = cc_chan_recv(rx.raw, &v, sizeof(int));
                    if (rc == 0 && v == 11) cc_atomic_fetch_add(&g_data, 1);
                    else cc_atomic_fetch_add(&g_errors, 1);
                });
                spawn(() => [tx] {
                    cc_sleep_ms(1);
                    int v = 11;
                    int rc = cc_chan_send(tx.raw, &v, sizeof(int));
                    if (rc != 0) cc_atomic_fetch_add(&g_errors, 1);
                });
            }
            tx.close();
            cc_chan_free(ch);
        }

        /* Case C: sender-vs-close race (single completion, no hang). */
        {
            int[~ >] tx;
            int[~ <] rx;
            CCChan* ch = channel_pair(&tx, &rx);
            @nursery {
                spawn(() => [rx] {
                    int v = -1;
                    int rc = cc_chan_recv(rx.raw, &v, sizeof(int));
                    if (rc == 0) cc_atomic_fetch_add(&g_data, 1);
                    else if (rc == EPIPE) cc_atomic_fetch_add(&g_closed, 1);
                    else cc_atomic_fetch_add(&g_errors, 1);
                });
                spawn(() => [tx] {
                    cc_sleep_ms(1);
                    int v = 23;
                    int rc = cc_chan_send(tx.raw, &v, sizeof(int));
                    if (!(rc == 0 || rc == EPIPE)) cc_atomic_fetch_add(&g_errors, 1);
                });
                spawn(() => [tx] {
                    cc_sleep_ms(1);
                    tx.close();
                });
            }
            tx.close();
            cc_chan_free(ch);
        }

        if (cc_atomic_load(&g_errors) != 0) break;
    }

    if (cc_atomic_load(&g_errors) == 0) {
        fprintf(stderr, "lostwake_stress outcomes: data=%d closed=%d\n",
                cc_atomic_load(&g_data), cc_atomic_load(&g_closed));
    }
    return cc_atomic_load(&g_errors) == 0 ? 0 : 1;
}

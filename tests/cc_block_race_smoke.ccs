/* Test: cc_block_race returns first task to complete with correct result.
   NOTE: Due to async runtime limitations (cc_sleep_ms blocks the polling thread),
   timing-based "fast wins" is not guaranteed. This test verifies correctness:
   - winner is valid (0 or 1)
   - result matches the winner's return value */
#include <ccc/cc_runtime.cch>
#include <stdio.h>

@async int task_a(void) {
    cc_sleep_ms(10);
    return 42;
}

@async int task_b(void) {
    cc_sleep_ms(50);
    return 99;
}

int main(void) {
    CCTaskIntptr tasks[] = {
        task_a(),  /* index 0, returns 42 */
        task_b()   /* index 1, returns 99 */
    };

    int winner = -1;
    intptr_t result = 0;
    int err = cc_block_race(2, tasks, &winner, &result);

    printf("err=%d, winner=%d, result=%d\n", err, winner, (int)result);

    if (err != 0) return 1;
    
    /* Verify winner is valid and result matches */
    if (winner == 0) {
        if (result != 42) return 2;  /* task_a should return 42 */
    } else if (winner == 1) {
        if (result != 99) return 3;  /* task_b should return 99 */
    } else {
        return 4;  /* invalid winner */
    }

    printf("Result: PASS (winner=%d)\n", winner);
    return 0;
}

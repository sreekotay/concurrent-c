/*
 * chan_timed_ping_pong.ccs â€” minimal lost-wakeup reproducer.
 *
 * 2 channels, capacity 1024, 4 fibers, timed send/recv, 2 workers.
 * Stripped-down version of channel_contention_workers_smoke.
 */

#include <ccc/cc_runtime.cch>
#include <ccc/cc_channel.cch>
#include <ccc/cc_atomic.cch>

#define N 5000

cc_atomic_int g_errors = 0;

static void sender(CCChanTx tx, int count) {
    for (int i = 0; i < count; i++) {
        CCDeadline d = cc_deadline_after_ms(2000);
        int rc = cc_chan_deadline_send(tx.raw, &i, sizeof(int), &d);
        if (rc != 0) {
            fprintf(stderr, "FAIL: send rc=%d at i=%d\n", rc, i);
            cc_atomic_fetch_add(&g_errors, 1);
            return;
        }
    }
}

static void receiver(CCChanRx rx, int count) {
    int v;
    for (int i = 0; i < count; i++) {
        CCDeadline d = cc_deadline_after_ms(2000);
        int rc = cc_chan_deadline_recv(rx.raw, &v, sizeof(int), &d);
        if (rc != 0) {
            fprintf(stderr, "FAIL: recv rc=%d at i=%d\n", rc, i);
            cc_atomic_fetch_add(&g_errors, 1);
            return;
        }
    }
}

int main(void) {
    cc_sched_set_num_workers(2);

    int[~1024 >] tx1_h; int[~1024 <] rx1_h; CCChan* ch1 = channel_pair(&tx1_h, &rx1_h);
    int[~1024 >] tx2_h; int[~1024 <] rx2_h; CCChan* ch2 = channel_pair(&tx2_h, &rx2_h);
    (void)ch1; (void)ch2;
    CCChanTx tx1 = tx1_h;
    CCChanRx rx1 = rx1_h;
    CCChanTx tx2 = tx2_h;
    CCChanRx rx2 = rx2_h;

    @nursery {
        spawn(() => [tx1] { sender(tx1, N); });
        spawn(() => [rx1] { receiver(rx1, N); });
        spawn(() => [tx2] { sender(tx2, N); });
        spawn(() => [rx2] { receiver(rx2, N); });
    }

    return cc_atomic_load(&g_errors) == 0 ? 0 : 1;
}

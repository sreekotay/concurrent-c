/*
 * GoBench GoReal: grpc#2391 (channel deadlock on GOAWAY + close).
 * Simplified port: close path fails to signal channel, leaving reader blocked.
 */
#include <ccc/cc_runtime.cch>
#include <pthread.h>
#include <stdio.h>
#include <errno.h>

typedef struct {
    CCChan* goaway_ch;
    CCChan* done_ch;
} ReaderArgs;

static void* reader_thread(void* arg) {
    ReaderArgs* a = (ReaderArgs*)arg;
    int v = 0;
    (void)cc_chan_recv(a->goaway_ch, &v, sizeof(v)); /* waits for GOAWAY */
    v = 1;
    cc_chan_send(a->done_ch, &v, sizeof(v));
    return NULL;
}

int main(void) {
    CCChan* goaway_ch = cc_chan_create(0);
    CCChan* done_ch = cc_chan_create(1);
    if (!goaway_ch || !done_ch) return 2;
    if (cc_chan_init_elem(goaway_ch, sizeof(int)) != 0) return 3;
    if (cc_chan_init_elem(done_ch, sizeof(int)) != 0) return 4;

    ReaderArgs args = { .goaway_ch = goaway_ch, .done_ch = done_ch };
    pthread_t tid;
    pthread_create(&tid, NULL, reader_thread, &args);

    /* Close path forgets to send GOAWAY. */
    int v = 0;
    int rc = 0;
    @with_deadline(millis(20)) {
        rc = cc_chan_recv(done_ch, &v, sizeof(v));
    }

    if (rc != ETIMEDOUT) return 10;

    /* Cleanup: send GOAWAY and join. */
    v = 9;
    cc_chan_send(goaway_ch, &v, sizeof(v));
    pthread_join(tid, NULL);

    cc_chan_free(goaway_ch);
    cc_chan_free(done_ch);
    printf("gobench goreal grpc2391: PASS\n");
    return 0;
}

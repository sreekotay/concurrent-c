/*
 * Sync channel smoke test: verify sync channels block OS thread.
 */
#include <ccc/std/prelude.cch>
#include <pthread.h>
#include <stdio.h>
#include <assert.h>
#include <errno.h>

// Sync channel pair - blocks OS thread, no await needed
int[~2 sync >] tx;
int[~2 sync <] rx;
CCChan* g_ch;

static void* sender_thread(void* arg) {
    (void)arg;
    // Send values (use non-UFCS form due to parser limitation)
    (void)chan_send(tx, 10);
    (void)chan_send(tx, 20);
    chan_close(tx);
    return NULL;
}

int main(void) {
    g_ch = channel_pair(&tx, &rx);
    
    pthread_t tid;
    pthread_create(&tid, NULL, sender_thread, NULL);
    
    // Receive values (blocks OS thread, no await)
    int v1 = 0, v2 = 0;
    CCResult_bool_CCIoError res1 = chan_recv(rx, &v1);
    CCResult_bool_CCIoError res2 = chan_recv(rx, &v2);
    
    pthread_join(tid, NULL);
    
    // Verify
    assert(cc_io_avail(res1) && "first recv should succeed");
    assert(cc_io_avail(res2) && "second recv should succeed");
    assert(v1 == 10 && "first value should be 10");
    assert(v2 == 20 && "second value should be 20");
    
    // Third recv should return Ok(false) - closed + drained
    int v3 = 0;
    CCResult_bool_CCIoError res3 = chan_recv(rx, &v3);
    assert(cc_is_ok(res3) && !cc_unwrap(res3) && "recv on closed+drained should return Ok(false)");
    
    // Free the channel exactly once (tx and rx share the same underlying channel)
    cc_chan_free(g_ch);
    
    printf("sync channel smoke: PASS\n");
    return 0;
}

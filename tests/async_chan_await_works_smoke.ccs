/* Test that channel ops with await in @async functions work correctly.
   Uses cc_chan_*_task() directly since chan_send/recv are macros that
   don't interact well with await in the current implementation. */
#include "cc_runtime.cch"
#include "std/task_intptr.cch"
#include <stdio.h>
#include <assert.h>

@async int sender(CCChanTx tx) {
    int val = 42;
    /* Use task-returning API directly */
    intptr_t rc = await cc_chan_send_task(tx.raw, &val, sizeof(val));
    printf("sender: sent %d, rc=%ld\n", val, (long)rc);
    return (int)rc;
}

@async int receiver(CCChanRx rx) {
    int val = 0;
    /* Use task-returning API directly */
    intptr_t rc = await cc_chan_recv_task(rx.raw, &val, sizeof(val));
    printf("receiver: received %d, rc=%ld\n", val, (long)rc);
    return val;
}

int main(void) {
    int[~4 >] tx;
    int[~4 <] rx;
    channel_pair(&tx, &rx);

    int send_rc = cc_block_on(int, sender(tx));
    printf("send_rc = %d\n", send_rc);
    assert(send_rc == 0);

    int recv_val = cc_block_on(int, receiver(rx));
    printf("recv_val = %d\n", recv_val);
    assert(recv_val == 42);

    chan_close(tx);
    chan_free(rx);

    printf("async_chan_await_works_smoke: PASS\n");
    return 0;
}

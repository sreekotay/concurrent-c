/*
 * Channel topology smoke test: verify topology is parsed and passed to runtime.
 */
#include <ccc/std/prelude.cch>
#include <pthread.h>
#include <stdio.h>
#include <assert.h>
#include <errno.h>

// Test various topology declarations
int[~4 N:1 >] many_to_one_tx;
int[~4 N:1 <] many_to_one_rx;

int[~4 1:1 >] one_to_one_tx;
int[~4 1:1 <] one_to_one_rx;

CCChan* g_n1_ch;
CCChan* g_11_ch;

int main(void) {
    // Create N:1 channel (many senders, one receiver)
    g_n1_ch = channel_pair(&many_to_one_tx, &many_to_one_rx);
    
    // Create 1:1 channel (single producer, single consumer)
    g_11_ch = channel_pair(&one_to_one_tx, &one_to_one_rx);
    
    // Basic send/recv test on N:1 (use non-UFCS due to parser limitation)
    (void)chan_send(many_to_one_tx, 42);
    int v1 = 0;
    CCResult_bool_CCIoError res1 = chan_recv(many_to_one_rx, &v1);
    assert(cc_io_avail(res1) && v1 == 42 && "N:1 channel should work");
    
    // Basic send/recv test on 1:1 (use non-UFCS due to parser limitation)
    (void)chan_send(one_to_one_tx, 99);
    int v2 = 0;
    CCResult_bool_CCIoError res2 = chan_recv(one_to_one_rx, &v2);
    assert(cc_io_avail(res2) && v2 == 99 && "1:1 channel should work");
    
    // Cleanup
    chan_close(many_to_one_tx);
    cc_chan_free(g_n1_ch);
    
    chan_close(one_to_one_tx);
    cc_chan_free(g_11_ch);
    
    printf("channel topology smoke: PASS\n");
    return 0;
}

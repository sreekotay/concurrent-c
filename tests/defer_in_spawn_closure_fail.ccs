/*
 * Test: @defer inside spawn closure - EXPECTED TO FAIL or behave incorrectly
 * 
 * This test demonstrates the current limitation where @defer doesn't work
 * properly inside spawn closures. The closure body is extracted by the
 * closure pass BEFORE the defer pass runs, so the defer is never processed.
 */

#define CC_ENABLE_SHORT_NAMES
#include <ccc/std/prelude.cch>
#include <stdio.h>
#include <stdlib.h>

cc_atomic_int g_cleanup_count = 0;

void cleanup_fn(void) {
    printf("cleanup_fn called\n");
    cc_atomic_fetch_add(&g_cleanup_count, 1);
}

int main(void) {
    printf("Testing @defer inside spawn closure\n");
    cc_atomic_store(&g_cleanup_count, 0);
    
    @nursery {
        spawn([]() => {
            printf("Worker starting\n");
            @defer cleanup_fn();  // <-- THIS IS THE PROBLEM
            printf("Worker doing work\n");
            // cleanup_fn should run here when closure exits
        });
    }
    
    printf("Nursery complete. Cleanup count: %d\n", cc_atomic_load(&g_cleanup_count));
    
    if (cc_atomic_load(&g_cleanup_count) == 0) {
        printf("ERROR: @defer inside spawn closure was NOT executed!\n");
        printf("This demonstrates the limitation.\n");
        return 1;
    } else {
        printf("SUCCESS: @defer worked inside spawn closure!\n");
        return 0;
    }
}

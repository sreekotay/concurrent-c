#include <ccc/cc_runtime.cch>
#include <ccc/cc_channel.cch>

#include <errno.h>
#include <stdio.h>
#include <unistd.h>

static volatile int g_err = 0;
static volatile int g_got = 0;

void producer(CCChanTx tx) {
    int v1 = 1;
    int v2 = 2;

    if (!cc_io_avail(chan_send(tx, v1))) { g_err = 1; return; }

    // Ensure nursery end is reached while producer is still running.
    usleep(50 * 1000);

    if (!cc_io_avail(chan_send(tx, v2))) { g_err = 1; return; }
}

void consumer(CCChanRx rx) {
    int v = 0;

    if (!cc_io_avail(chan_recv(rx, &v))) { g_err = 1; return; }
    g_got += v;

    if (!cc_io_avail(chan_recv(rx, &v))) { g_err = 1; return; }
    g_got += v;
}

int main(void) {
    CCChanTx ch_tx;
    CCChanRx ch_rx;
    if (cc_chan_pair_create(1, CC_CHAN_MODE_BLOCK, false, sizeof(int), &ch_tx, &ch_rx) != 0) return 2;

    g_err = 0;
    g_got = 0;

    // Spec: closing(ch) must close after all children exit (i.e., after joining).
    @nursery closing(ch_tx) {
        spawn(() => { producer(ch_tx); });
        spawn(() => { consumer(ch_rx); });
    }

    // If closing happened before join, producer/consumer likely saw EPIPE.
    if (g_err != 0) return 10;
    if (g_got != 3) return 11;

    // After nursery exit, channel should now be closed.
    int tmp = 0;
    CCResult_bool_CCIoError tr = chan_try_recv(ch_rx, &tmp);
    if (!(cc_is_ok(tr) && !cc_unwrap(tr))) {
        fprintf(stderr, "nursery_closing_order_smoke: expected channel closed after nursery\n");
        return 12;
    }
    int v3 = 3;
    CCResult_bool_CCIoError e = chan_send(ch_tx, v3);
    if (!(cc_is_ok(e) && !cc_unwrap(e))) {
        fprintf(stderr, "nursery_closing_order_smoke: expected send to return closed after nursery\n");
        return 13;
    }

    chan_free(ch_tx);
    return 0;
}


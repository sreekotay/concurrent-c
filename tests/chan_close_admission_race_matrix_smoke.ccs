/*
 * ยง5 close/admission race matrix smoke.
 *
 * Validates:
 * - post-close send admission fails (EPIPE)
 * - close + recv drains any admitted work and returns closed afterwards
 * across buffered and unbuffered channels.
 */
#include <ccc/cc_runtime.cch>
#include <ccc/cc_channel.cch>
#include <ccc/cc_atomic.cch>

#include <errno.h>
#include <stdio.h>

#define REPEATS 8

cc_atomic_int g_errors = 0;
cc_atomic_int g_post_close_fail = 0;
cc_atomic_int g_post_close_success = 0;
cc_atomic_int g_recv_closed = 0;
cc_atomic_int g_recv_data = 0;

static void run_case_buffered(void) {
    for (int rep = 0; rep < REPEATS; rep++) {
        if ((rep % 200) == 0) fprintf(stderr, "buffered iter %d/%d\n", rep, REPEATS);
        int[~1 >] tx;
        int[~1 <] rx;
        CCChan* ch = channel_pair(&tx, &rx);

        @nursery {
            spawn(() => [tx] {
                int v = 1;
                CCDeadline d = cc_deadline_after_ms(40);
                int rc = cc_chan_deadline_send(tx.raw, &v, sizeof(int), &d);
                if (!(rc == 0 || rc == EPIPE || rc == ETIMEDOUT)) cc_atomic_fetch_add(&g_errors, 1);
            });
            spawn(() => [tx] {
                cc_sleep_ms(1);
                tx.close();
            });
        }

        /* After close: drain-at-most-one admitted item, then closed/non-success. */
        {
            int out = 0;
            CCDeadline d1 = cc_deadline_after_ms(40);
            int rc1 = cc_chan_deadline_recv(rx.raw, &out, sizeof(int), &d1);
            if (rc1 == 0) cc_atomic_fetch_add(&g_recv_data, 1);
            else if (rc1 == EPIPE) cc_atomic_fetch_add(&g_recv_closed, 1);
            else if (rc1 == ETIMEDOUT) { /* allowed as non-success close-adjacent outcome */ }
            else cc_atomic_fetch_add(&g_errors, 1);

            CCDeadline d2 = cc_deadline_after_ms(40);
            int rc2 = cc_chan_deadline_recv(rx.raw, &out, sizeof(int), &d2);
            if (rc2 == 0) cc_atomic_fetch_add(&g_errors, 1); /* no second success allowed */
            else if (rc2 == EPIPE) cc_atomic_fetch_add(&g_recv_closed, 1);
            else if (rc2 == ETIMEDOUT) { /* allowed non-success */ }
            else cc_atomic_fetch_add(&g_errors, 1);
        }

        /* Deterministic post-close admission check. */
        {
            int v = 2;
            int rc = cc_chan_send(ch, &v, sizeof(int));
            if (rc != 0) cc_atomic_fetch_add(&g_post_close_fail, 1);
            else {
                cc_atomic_fetch_add(&g_post_close_success, 1);
                cc_atomic_fetch_add(&g_errors, 1);
            }
        }
        tx.close();
        cc_chan_free(ch);
        if (cc_atomic_load(&g_errors) != 0) break;
    }
}

static void run_case_unbuffered(void) {
    for (int rep = 0; rep < REPEATS; rep++) {
        if ((rep % 200) == 0) fprintf(stderr, "unbuffered iter %d/%d\n", rep, REPEATS);
        int[~ >] tx;
        int[~ <] rx;
        CCChan* ch = channel_pair(&tx, &rx);

        @nursery {
            spawn(() => [tx] {
                int v = 3;
                CCDeadline d = cc_deadline_after_ms(40);
                int rc = cc_chan_deadline_send(tx.raw, &v, sizeof(int), &d);
                if (!(rc == 0 || rc == EPIPE || rc == ETIMEDOUT)) cc_atomic_fetch_add(&g_errors, 1);
            });
            spawn(() => [tx] {
                cc_sleep_ms(1);
                tx.close();
            });
        }

        {
            int out = 0;
            CCDeadline d1 = cc_deadline_after_ms(40);
            int rc1 = cc_chan_deadline_recv(rx.raw, &out, sizeof(int), &d1);
            if (rc1 == 0) cc_atomic_fetch_add(&g_recv_data, 1);
            else if (rc1 == EPIPE) cc_atomic_fetch_add(&g_recv_closed, 1);
            else if (rc1 == ETIMEDOUT) { }
            else cc_atomic_fetch_add(&g_errors, 1);

            CCDeadline d2 = cc_deadline_after_ms(40);
            int rc2 = cc_chan_deadline_recv(rx.raw, &out, sizeof(int), &d2);
            if (rc2 == 0) cc_atomic_fetch_add(&g_errors, 1);
            else if (rc2 == EPIPE) cc_atomic_fetch_add(&g_recv_closed, 1);
            else if (rc2 == ETIMEDOUT) { }
            else cc_atomic_fetch_add(&g_errors, 1);
        }

        /* Deterministic post-close admission check. */
        {
            int v = 4;
            int rc = cc_chan_send(ch, &v, sizeof(int));
            if (rc != 0) cc_atomic_fetch_add(&g_post_close_fail, 1);
            else {
                cc_atomic_fetch_add(&g_post_close_success, 1);
                cc_atomic_fetch_add(&g_errors, 1);
            }
        }
        tx.close();
        cc_chan_free(ch);
        if (cc_atomic_load(&g_errors) != 0) break;
    }
}

int main(void) {
    cc_sched_set_num_workers(2);
    run_case_buffered();
    if (cc_atomic_load(&g_errors) == 0) run_case_unbuffered();

    int expected_post_close = REPEATS * 2;
    if (cc_atomic_load(&g_post_close_fail) != expected_post_close) {
        fprintf(stderr, "post-close fail mismatch got=%d expected=%d\n",
                cc_atomic_load(&g_post_close_fail), expected_post_close);
        cc_atomic_fetch_add(&g_errors, 1);
    }
    if (cc_atomic_load(&g_post_close_success) != 0) {
        fprintf(stderr, "post-close success count must be zero, got=%d\n",
                cc_atomic_load(&g_post_close_success));
        cc_atomic_fetch_add(&g_errors, 1);
    }

    if (cc_atomic_load(&g_errors) == 0) {
        fprintf(stderr, "close-admission outcomes: post_close_fail=%d recv_data=%d recv_closed=%d\n",
                cc_atomic_load(&g_post_close_fail),
                cc_atomic_load(&g_recv_data),
                cc_atomic_load(&g_recv_closed));
    }
    return cc_atomic_load(&g_errors) == 0 ? 0 : 1;
}

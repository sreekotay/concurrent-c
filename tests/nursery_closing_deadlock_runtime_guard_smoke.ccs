#include "cc_runtime.cch"
#include "cc_channel.cch"

#include <stdlib.h>

static volatile int g_err = 0;

int main(void) {
    // Enable runtime guard: instead of deadlocking, cc_chan_recv returns EDEADLK in the foot-gun case.
    setenv("CC_NURSERY_CLOSING_RUNTIME_GUARD", "1", 1);

    // Buffer producer's sends so the producer can finish even if the consumer stops early.
    CCChan* ch = cc_chan_create(3);
    if (!ch) return 2;
    (void)cc_chan_init_elem(ch, sizeof(int));

    @nursery closing(ch) {
        spawn(() => {
            for (int i = 1; i <= 3; i++) {
                int v = i;
                (void)cc_chan_send(ch, &v, sizeof(v));
            }
        });

        // This would deadlock without the runtime guard.
        spawn(() => {
            int v = 0;
            for (;;) {
                int rc = cc_chan_recv(ch, &v, sizeof(v));
                if (rc == 0) continue;
                g_err = rc; /* expect EDEADLK from the guard */
                break;
            }
        });
    }

    if (g_err != EDEADLK) return 10;
    cc_chan_free(ch);
    return 0;
}


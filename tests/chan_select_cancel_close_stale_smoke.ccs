/*
 * Smoke test for select-cancel/close waiter races.
 *
 * Goal (ยง8): repeatedly force one @match arm to win while the other arm is
 * cancelled/closed, exercising stale waiter-node paths without deadlock.
 */
#include <ccc/cc_runtime.cch>
#include <stdio.h>

#define REPEATS 1500

int main(void) {
    int wins_data = 0;
    int wins_close = 0;

    for (int rep = 0; rep < REPEATS; rep++) {
        if ((rep % 1000) == 0) {
            fprintf(stderr, "iter %d/%d\n", rep, REPEATS);
        }

        int[~1 >] tx_data;
        int[~1 <] rx_data;
        int[~1 >] tx_close;
        int[~1 <] rx_close;
        CCChan* ch_data = channel_pair(&tx_data, &rx_data);
        CCChan* ch_close = channel_pair(&tx_close, &rx_close);

        int selected = 0;
        int got = 0;
        @nursery {
            spawn(() => {
                int v = 1;
                CCDeadline d = cc_deadline_after_ms(10);
                (void)cc_chan_deadline_send(tx_data.raw, &v, sizeof(int), &d);
            });
            spawn(() => {
                tx_close.close();
            });

            @with_deadline(millis(30)) {
                @match {
                    case rx_data.recv(&got): {
                        selected = 1;
                    }
                    case rx_close.recv(&got): {
                        selected = 2;
                    }
                }
            }
        }

        if (selected == 1) {
            wins_data++;
        } else if (selected == 2) {
            wins_close++;
        } else {
            fprintf(stderr, "invalid select result rep=%d selected=%d\n", rep, selected);
            return 2;
        }

        tx_data.close();
        cc_chan_free(ch_data);
        cc_chan_free(ch_close);
    }

    printf("chan_select_cancel_close_stale_smoke: reps=%d data=%d close=%d\n",
           REPEATS, wins_data, wins_close);
    return 0;
}

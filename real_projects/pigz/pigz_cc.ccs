/*
 * pigz_cc.ccs -- Parallel gzip compression in idiomatic Concurrent-C
 *
 * Architecture:
 *   Reader -> [Block Channel] -> Workers (N) -> [Result Channel] -> Writer
 *
 * CC Patterns Used:
 *   - @nursery + spawn() for structured concurrency
 *   - Channels for block pipeline (no shared mutable state)
 *   - @arena blocks for scoped memory
 *   - @defer for cleanup
 *   - CC stdlib CCFile API
 */

#define CC_ENABLE_SHORT_NAMES
#include <ccc/std/prelude.cch>
#include <ccc/cc_atomic.cch>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sched.h>
#include <zlib.h>

/* ============================================================================
 * Configuration
 * ============================================================================ */

#define BLOCK_SIZE (128 * 1024)   /* 128KB input blocks */
#define DICT_SIZE  32768          /* 32KB sliding dictionary */
#define MAX_WORKERS 16

/* ============================================================================
 * Data Types
 * ============================================================================ */

/* Input block for compression */
typedef struct {
    long seq;                     /* Sequence number for ordering */
    CCSlice data;                 /* Input data slice (arena-backed) */
    CCSlice dict;                 /* Dictionary from previous block */
    int last;                     /* True if this is the last block */
    CCArena arena;                /* Arena owning the data and dict */
} Block;

/* Compressed result */
typedef struct {
    long seq;                     /* Sequence number for ordering */
    CCSlice data;                 /* Compressed data slice (arena-backed) */
    unsigned long crc;            /* CRC-32 of uncompressed data */
    size_t ulen;                  /* Uncompressed length (for trailer) */
    int last;                     /* True if this is the last block */
} Result;

/* Global statistics (atomic for thread safety) */
cc_atomic_i64 g_bytes_in = 0;
cc_atomic_i64 g_bytes_out = 0;
cc_atomic_int g_blocks_done = 0;

/* Writer output state (written only by writer task) */
unsigned long g_total_crc = 0;
size_t g_total_ulen = 0;

/* Output file handle (global for writer access) */
CCFile g_out_file;

/* ============================================================================
 * Compression Worker
 * ============================================================================ */

/*
 * Compress a single block using zlib deflate.
 * 
 * PROVENANCE NOTE: The output slice uses malloc() rather than arena because:
 * - Worker sends Result through channel, then processes next block
 * - Writer receives Result asynchronously, may not consume it immediately
 * - If we used arena + reset, Result.data would be a dangling pointer
 * 
 * The slice is marked as transferable (can cross channel) but NOT unique
 * (writer needs to explicitly free after use - not automatic).
 */
static cc_atomic_u64 g_heap_alloc_counter = 1;

Result* compress_block(Block* blk, int level) {
    
    /* Allocate Result on heap - will be freed by writer after consumption */
    Result* res = (Result*)malloc(sizeof(Result));
    if (!res) {
        fprintf(stderr, "pigz_cc: malloc failed for Result\n");
        exit(1);
    }
    memset(res, 0, sizeof(Result));
    res->seq = blk->seq;
    res->last = blk->last;
    res->ulen = blk->data.len;
    
    /* Calculate CRC of input using zlib directly */
    res->crc = crc32(0UL, (const Bytef*)blk->data.ptr, (uInt)blk->data.len);
    
    /* Allocate output buffer with malloc - must outlive until writer consumes */
    size_t max_out = blk->data.len + (blk->data.len >> 3) + 256;
    unsigned char* out_buf = (unsigned char*)malloc(max_out);
    if (!out_buf) {
        free(res);
        fprintf(stderr, "pigz_cc: malloc failed\n");
        exit(1);
    }
    
    /* Write gzip header (10 bytes) */
    unsigned char header[10] = {
        0x1f, 0x8b,  /* Magic */
        0x08,        /* Deflate method */
        0x00,        /* Flags (none) */
        0, 0, 0, 0,  /* Mtime (not set) */
        0x00,        /* Extra flags */
        0x03         /* OS = Unix */
    };
    memcpy(out_buf, header, 10);
    size_t pos = 10;

    /* Compress with zlib (raw deflate, -15 window bits) */
    z_stream strm;
    memset(&strm, 0, sizeof(strm));
    
    int ret = deflateInit2(&strm, level, Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY);
    if (ret != Z_OK) {
        free(out_buf);
        free(res);
        fprintf(stderr, "pigz_cc: deflateInit2 failed\n");
        exit(1);
    }
    
    strm.next_in = (Bytef*)blk->data.ptr;
    strm.avail_in = (uInt)blk->data.len;
    strm.next_out = out_buf + pos;
    strm.avail_out = (uInt)(max_out - pos - 8);  /* Reserve space for trailer */
    
    ret = deflate(&strm, Z_FINISH);
    size_t deflate_len = strm.total_out;
    deflateEnd(&strm);
    
    if (ret != Z_STREAM_END) {
        free(out_buf);
        free(res);
        fprintf(stderr, "pigz_cc: deflate failed\n");
        exit(1);
    }
    
    pos += deflate_len;
    
    /* Write gzip trailer: CRC32 (4 bytes) + original size mod 2^32 (4 bytes) */
    unsigned long crc_val = res->crc;
    size_t in_len = blk->data.len;
    out_buf[pos++] = crc_val & 0xff;
    out_buf[pos++] = (crc_val >> 8) & 0xff;
    out_buf[pos++] = (crc_val >> 16) & 0xff;
    out_buf[pos++] = (crc_val >> 24) & 0xff;
    out_buf[pos++] = in_len & 0xff;
    out_buf[pos++] = (in_len >> 8) & 0xff;
    out_buf[pos++] = (in_len >> 16) & 0xff;
    out_buf[pos++] = (in_len >> 24) & 0xff;
    
    size_t compressed_len = pos;
    
    /* Create heap-owned slice with proper provenance:
     * - alloc_id: unique counter (heap allocation tracking)
     * - unique: false (not move-only - we don't have RAII destructor)
     * - transferable: true (can send through channel)
     * - subslice: false (this is the full allocation)
     */
    uint64_t alloc_id = cc_atomic_fetch_add(&g_heap_alloc_counter, 1);
    uint64_t slice_id = cc_slice_make_id(alloc_id, false, true, false);
    res->data = cc_slice_from_parts(out_buf, compressed_len, slice_id, compressed_len);
    
    /* Update global statistics */
    cc_atomic_fetch_add(&g_bytes_in, blk->data.len);
    cc_atomic_fetch_add(&g_bytes_out, compressed_len);
    cc_atomic_fetch_add(&g_blocks_done, 1);
    
    return res;
}

/* ============================================================================
 * Gzip Header/Trailer
 * ============================================================================ */

void write_gzip_header(CCFile* out) {
    unsigned char header[10] = {
        0x1f, 0x8b,              /* Magic */
        0x08,                    /* Deflate */
        0x00,                    /* Flags */
        0, 0, 0, 0,              /* Mtime (0 = not set) */
        0x00,                    /* Extra flags */
        0x03                     /* OS = Unix */
    };
    CCSlice hdr = cc_slice_from_parts(header, 10, CC_SLICE_ID_UNTRACKED, 10);
    cc_file_write(out, hdr);
}

void write_gzip_trailer(CCFile* out, unsigned long crc, size_t ulen) {
    unsigned char trailer[8];
    trailer[0] = crc & 0xff;
    trailer[1] = (crc >> 8) & 0xff;
    trailer[2] = (crc >> 16) & 0xff;
    trailer[3] = (crc >> 24) & 0xff;
    trailer[4] = ulen & 0xff;
    trailer[5] = (ulen >> 8) & 0xff;
    trailer[6] = (ulen >> 16) & 0xff;
    trailer[7] = (ulen >> 24) & 0xff;
    CCSlice trl = cc_slice_from_parts(trailer, 8, CC_SLICE_ID_UNTRACKED, 8);
    cc_file_write(out, trl);
}

/* CRC-32 combination for parallel computation */
unsigned long crc32_combine_cc(unsigned long crc1, unsigned long crc2, size_t len2) {
    return crc32_combine(crc1, crc2, (z_off_t)len2);
}

/* ============================================================================
 * Main Compression Pipeline
 * ============================================================================ */

int compress_file(const char* in_path, const char* out_path, int num_workers, int level) {
    /* Create main arena for the compression operation */
    CCArena main_arena = cc_heap_arena(64 * 1024 * 1024);
    @defer cc_heap_arena_free(&main_arena);
    
    /* Open files using CC stdlib */
    CCFile in_file;
    if (cc_file_open(&in_file, in_path, "rb") != 0) {
        fprintf(stderr, "pigz_cc: cannot open input: %s\n", in_path);
        return 1;
    }
    @defer cc_file_close(&in_file);
    
    if (cc_file_open(&g_out_file, out_path, "wb") != 0) {
        fprintf(stderr, "pigz_cc: cannot open output: %s\n", out_path);
        return 1;
    }
    @defer cc_file_close(&g_out_file);
    
    /* Channel types for pipeline - use pointers for lock-free fast path (8 bytes) 
     * Larger buffers reduce contention with multiple workers */
    Block*[~64 >] blocks_tx;
    Block*[~64 <] blocks_rx;
    Result*[~64 >] results_tx;
    Result*[~64 <] results_rx;
    
    /* Create channels */
    CCChan* blocks_ch = channel_pair(&blocks_tx, &blocks_rx);
    CCChan* results_ch = channel_pair(&results_tx, &results_rx);
    @defer cc_chan_free(blocks_ch);
    @defer cc_chan_free(results_ch);
    
    /* Each compressed block now includes its own gzip header/trailer,
       so we don't write a global header. Multiple gzip members are
       concatenated and gunzip handles them correctly. */
    
    /* Reset global state (for statistics only now) */
    g_total_crc = 0;
    g_total_ulen = 0;
    
    /*
     * Pipeline using nested nurseries:
     *
     *   @nursery (outer) {
     *       spawn(writer);
     *       @nursery closing(results_tx) {
     *           spawn(workers...);
     *           @nursery closing(blocks_tx) {
     *               spawn(reader);
     *           }
     *       }
     *   }
     */
    
    @nursery {
        /* Writer: receives results and writes in sequence order */
        spawn(() => {
            Result **pending = NULL;
            int pending_count = 0;
            int pending_cap = 0;
            long next_seq = 0;
            
            Result* r;
            while (chan_recv(results_rx, &r) == 0) {
                /* Buffer out-of-order results */
                if (r->seq != next_seq) {
                    if (pending_count >= pending_cap) {
                        pending_cap = pending_cap ? pending_cap * 2 : 16;
                        pending = (Result**)realloc(pending, pending_cap * sizeof(Result*));
                    }
                    pending[pending_count++] = r;
                    continue;
                }
                
                /* Write this result and free the buffer + Result struct */
                cc_file_write(&g_out_file, r->data);
                free((void*)r->data.ptr);
                g_total_crc = crc32_combine_cc(g_total_crc, r->crc, r->ulen);
                g_total_ulen += r->ulen;
                free(r);
                next_seq++;
                
                /* Check pending for next in sequence */
                int found;
                do {
                    found = 0;
                    for (int i = 0; i < pending_count; i++) {
                        if (pending[i]->seq == next_seq) {
                            cc_file_write(&g_out_file, pending[i]->data);
                            free((void*)pending[i]->data.ptr);
                            g_total_crc = crc32_combine_cc(g_total_crc, pending[i]->crc, pending[i]->ulen);
                            g_total_ulen += pending[i]->ulen;
                            free(pending[i]);
                            next_seq++;
                            pending[i] = pending[--pending_count];
                            found = 1;
                            break;
                        }
                    }
                } while (found);
            }
            
            free(pending);
        });
        
        /* Workers + Reader in nested nurseries */
        @nursery closing(results_tx) {
            /* Spawn compression workers */
            for (int w = 0; w < num_workers; w++) {
                spawn([level]() => {
                    Block* blk;
                    while (chan_recv(blocks_rx, &blk) == 0) {
                        Result* res = compress_block(blk, level);
                        chan_send(results_tx, res);
                        cc_heap_arena_free(&blk->arena);
                        free(blk);
                    }
                });
            }
            
            /* Reader: produces blocks */
            @nursery closing(blocks_tx) {
                void* in_ptr = (void*)&in_file;
                spawn([in_ptr]() => {
                    CCFile* in_f = (CCFile*)in_ptr;
                    long seq = 0;
                    
                    while (1) {
                        /* Create a fresh arena for this block (idiomatic transfer) */
                        CCArena arena = cc_heap_arena(BLOCK_SIZE + 1024);
                        
                        /* Read into the fresh arena */
                        CCRes(CCSlice, CCIoError) read_result = cc_file_read(in_f, &arena, BLOCK_SIZE);
                        
                        /* Check for error */
                        if (!read_result.ok) {
                            cc_heap_arena_free(&arena);
                            break;
                        }
                        
                        /* Check for EOF (empty slice means EOF) */
                        CCSlice data = read_result.u.value;
                        if (data.len == 0) {
                            cc_heap_arena_free(&arena);
                            break;  /* EOF */
                        }
                        
                        /* Allocate Block on heap for lock-free channel send */
                        Block* blk = (Block*)malloc(sizeof(Block));
                        if (!blk) {
                            cc_heap_arena_free(&arena);
                            fprintf(stderr, "pigz_cc: malloc failed for Block\n");
                            break;
                        }
                        memset(blk, 0, sizeof(Block));
                        blk->seq = seq++;
                        blk->data = data;
                        blk->arena = arena;
                        
                        /* Check if this is the last block by peeking */
                        CCResult_CCSlice_CCIoError peek = cc_file_read(in_f, &arena, 1);
                        if (!peek.ok || peek.u.value.len == 0) {
                            blk->last = 1;
                        } else {
                            blk->last = 0;
                            fseek(in_f->handle, -1, SEEK_CUR);
                        }
                        
                        /* Send block pointer to workers - ownership transfers */
                        chan_send(blocks_tx, blk);
                        
                        if (blk->last) {
                            break;
                        }
                    }
                });
            }
            /* blocks_tx closed -> workers drain and exit */
        }
        /* results_tx closed -> writer drains and exits */
    }
    /* All tasks complete here */
    
    /* No global trailer needed - each block has its own gzip trailer */
    
    /* Sync to disk */
    cc_file_sync(&g_out_file);
    
    return 0;
}

/* ============================================================================
 * Command Line Interface
 * ============================================================================ */

void usage(const char *prog) {
    fprintf(stderr, "Usage: %s [options] [file]\n", prog);
    fprintf(stderr, "  -c          Write to stdout\n");
    fprintf(stderr, "  -k          Keep original file\n");
    fprintf(stderr, "  -p N        Use N compression threads (default: 4)\n");
    fprintf(stderr, "  -1..-9      Compression level (default: 6)\n");
    fprintf(stderr, "  -h          Show this help\n");
}

int main(int argc, char *argv[]) {
    int to_stdout = 0;
    int keep = 0;
    int num_workers = 4;
    int level = 6;
    const char *input_file = NULL;
    
    /* Parse arguments */
    for (int i = 1; i < argc; i++) {
        if (argv[i][0] == '-') {
            if (strcmp(argv[i], "-c") == 0) {
                to_stdout = 1;
            } else if (strcmp(argv[i], "-k") == 0) {
                keep = 1;
            } else if (strcmp(argv[i], "-h") == 0) {
                usage(argv[0]);
                return 0;
            } else if (strncmp(argv[i], "-p", 2) == 0) {
                if (argv[i][2]) {
                    num_workers = atoi(&argv[i][2]);
                } else if (i + 1 < argc) {
                    num_workers = atoi(argv[++i]);
                }
                if (num_workers < 1) num_workers = 1;
                if (num_workers > MAX_WORKERS) num_workers = MAX_WORKERS;
            } else if (argv[i][1] >= '1' && argv[i][1] <= '9') {
                level = argv[i][1] - '0';
            } else {
                fprintf(stderr, "Unknown option: %s\n", argv[i]);
                usage(argv[0]);
                return 1;
            }
        } else {
            input_file = argv[i];
        }
    }
    
    if (!input_file) {
        fprintf(stderr, "pigz_cc: no input file specified\n");
        usage(argv[0]);
        return 1;
    }
    
    /* Build output filename */
    char output_file[4096];
    if (to_stdout) {
        /* Use /dev/stdout for stdout mode */
        snprintf(output_file, sizeof(output_file), "/dev/stdout");
    } else {
        snprintf(output_file, sizeof(output_file), "%s.gz", input_file);
    }
    
    /* Compress */
    int ret = compress_file(input_file, output_file, num_workers, level);
    
    /* Delete original if requested */
    if (ret == 0 && !keep && !to_stdout) {
        unlink(input_file);
    }
    
    /* Print statistics */
    long bytes_in = cc_atomic_load(&g_bytes_in);
    long bytes_out = cc_atomic_load(&g_bytes_out);
    int blocks = cc_atomic_load(&g_blocks_done);
    fprintf(stderr, "%s: %ld -> %ld bytes (%.1f%%), %d blocks, %d workers\n",
            input_file,
            bytes_in, bytes_out,
            bytes_in > 0 ? 100.0 * (1.0 - (double)bytes_out / bytes_in) : 0.0,
            blocks, num_workers);
    
    return ret;
}

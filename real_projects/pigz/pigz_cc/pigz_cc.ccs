/*
 * pigz_cc.ccs -- Parallel gzip compression in Concurrent-C
 *
 * This version aims for feature parity with Mark Adler's original pigz,
 * while demonstrating idiomatic Concurrent-C patterns:
 * - Result types (T!>(E)) for error propagation
 * - CCFile with Result-based I/O (cc_file_read, cc_file_write)
 * - @nursery + spawn() for structured concurrency
 * - Arena-backed ownership transfer
 */

#include "pigz_cc.cch"

/* ============================================================================
 * Global State & Statistics
 * ============================================================================ */

/* Global statistics */
cc_atomic_i64 g_bytes_in = 0;
cc_atomic_i64 g_bytes_out = 0;
cc_atomic_int g_blocks_done = 0;

/* Global error flag - when set, all tasks should exit ASAP */
cc_atomic_int g_pipeline_error = 0;

/* Helper for repeated write-or-fail pattern */
static inline bool write_slice(CCFile* f, CCSlice data, const char* what) {
    if (cc_is_err(cc_file_write(f, data))) {
        fprintf(stderr, "Error: failed to write %s\n", what);
        cc_atomic_store(&g_pipeline_error, 1);
        return false;
    }
    return true;
}

/* ============================================================================
 * Compression Worker
 * ============================================================================ */

/*
 * Compress a single block using a provided z_stream.
 * Returns a CompressedResult*!>(CCIoError) to demonstrate idiomatic error propagation.
 * (matches pigz.c:2310-2350)
 * 
 * Uses @arena block with cc_arena_detach() for clean ownership transfer:
 * - On error: @arena cleanup frees the memory
 * - On success: arena_detach() transfers ownership, cleanup is no-op
 */
CompressedResultPtr !>(CCIoError) compress_block(z_stream* strm, Block* blk, CCSlice dict, int level, int strategy) {
    // Arena sizing: CompressedResult struct + deflate output
    // Deflate worst case is ~0.03% expansion + 11 bytes; we allow 12.5% + 8KB for safety
    size_t arena_size = blk->data.len + (blk->data.len >> 3) + 8192;
    
    @arena(res_arena, arena_size) {
        CompressedResult* res = arena_alloc1(CompressedResult, res_arena);
        if (!res) return cc_err(cc_io_error(CC_IO_OUT_OF_MEMORY));
        
        res->seq = blk->seq;
        res->is_last = blk->is_last;
        res->original_len = blk->data.len;

        // Stage 1: Setup & Checksum (matches pigz.c:2323-2324)
        // pigz uses Adler-32 only for zlib streams; gzip + zip use CRC-32.
        if (g.form == 1) {
            res->crc = adler32(1UL, (const Bytef*)blk->data.ptr, (uInt)blk->data.len);
        } else {
            res->crc = crc32(0UL, (const Bytef*)blk->data.ptr, (uInt)blk->data.len);
        }

        if (level <= 9) {
            (void)deflateReset(strm);
            (void)deflateParams(strm, level, strategy);

            // Stage 2: Output Buffer Allocation
            // Use deflateBound to ensure we have enough space for the compressed data
            // For rsyncable, we might have many sync markers which add overhead (~5 bytes each)
            size_t max_out = deflateBound(strm, (uLong)blk->data.len) + 128;
            if (blk->lens.len > 0) {
                max_out += (blk->lens.len / sizeof(size_t)) * 10; // Extra space for sync markers
            }
            unsigned char* out_buf = arena_alloc(unsigned char, res_arena, max_out);
            if (!out_buf) return cc_err(cc_io_error(CC_IO_OUT_OF_MEMORY));

            size_t pos = 0;

            // Stage 3: Dictionary Loading (matches pigz.c:2330-2335)
            if (dict.len > 0) {
                deflateSetDictionary(strm, (const Bytef*)dict.ptr, (uInt)dict.len);
            }
            
            strm->next_in = (Bytef*)blk->data.ptr;
            strm->avail_in = (uInt)blk->data.len;
            strm->next_out = out_buf + pos;
            strm->avail_out = (uInt)(max_out - pos);
            
            int ret;
            // Stage 4: Deflate Loop (matches pigz.c:2340-2350)
            if (blk->lens.len == 0) {
                // Standard single-segment block
                while (strm->avail_in > 0) {
                    ret = deflate(strm, Z_NO_FLUSH);
                    if (ret != Z_OK) break;
                    if (strm->avail_out == 0) { ret = Z_BUF_ERROR; break; }
                }
            } else {
                // Rsyncable multi-segment block (matches pigz.c:1787-1856)
                size_t* lens = (size_t*)blk->lens.ptr;
                size_t n_lens = blk->lens.len / sizeof(size_t);
                size_t total_in = 0;
                ret = Z_OK;
                
                for (size_t i = 0; i < n_lens; i++) {
                    size_t segment_len = lens[i];
                    if (segment_len == 0) segment_len = blk->data.len - total_in;
                    
                    strm->avail_in = (uInt)segment_len;
                    // next_in is already set correctly at the start or by previous deflate calls
                    total_in += segment_len;
                    
                    // Deflate segment
                    while (strm->avail_in > 0) {
                        ret = deflate(strm, Z_NO_FLUSH);
                        if (ret != Z_OK) break;
                        if (strm->avail_out == 0) { ret = Z_BUF_ERROR; break; }
                    }
                    if (ret != Z_OK) break;
                    
                    // Flush at rsync boundary (unless it's the very end of the last block)
                    if (total_in < blk->data.len || !blk->is_last) {
#if ZLIB_VERNUM >= 0x1260
                        int setdict = (g.setdict && (dict.len > 0 || i > 0));
                        ret = deflate(strm, Z_BLOCK);
                        if (ret == Z_OK) {
                            int bits = 0;
                            (void)deflatePending(strm, Z_NULL, &bits);
                            if ((bits & 1) || !setdict) {
                                ret = deflate(strm, Z_SYNC_FLUSH);
                            } else if (bits & 7) {
                                do {
                                    ret = deflatePrime(strm, 10, 2);
                                    if (ret != Z_OK) break;
                                    (void)deflatePending(strm, Z_NULL, &bits);
                                } while (bits & 7);
                                if (ret == Z_OK) ret = deflate(strm, Z_BLOCK);
                            }
                        }
#else
                        ret = deflate(strm, Z_SYNC_FLUSH);
#endif
                        if (ret != Z_OK) break;
                    }
                }
            }

            // Stage 5: Block Boundary Alignment (matches pigz.c:1990-2010)
            // (Only needed if not already handled by the rsyncable loop)
            if (ret == Z_OK && blk->lens.len == 0) {
                if (blk->is_last) {
                    // Finish the stream on the last block.
                    do {
                        ret = deflate(strm, Z_FINISH);
                        if (ret != Z_OK && ret != Z_STREAM_END) break;
                        if (strm->avail_out == 0) { ret = Z_BUF_ERROR; break; }
                    } while (ret != Z_STREAM_END);
                } else {
#if ZLIB_VERNUM >= 0x1260
                    int setdict = (g.setdict && dict.len > 0);
                    // Align to byte boundary without finishing the stream
                    ret = deflate(strm, Z_BLOCK);
                    if (ret == Z_OK) {
                        int bits = 0;
                        (void)deflatePending(strm, Z_NULL, &bits);
                        if ((bits & 1) || !setdict) {
                            ret = deflate(strm, Z_SYNC_FLUSH);
                        } else if (bits & 7) {
                            do {
                                ret = deflatePrime(strm, 10, 2);
                                if (ret != Z_OK) break;
                                (void)deflatePending(strm, Z_NULL, &bits);
                            } while (bits & 7);
                            if (ret == Z_OK) ret = deflate(strm, Z_BLOCK);
                        }
                    }
#else
                    ret = deflate(strm, Z_SYNC_FLUSH);
                    int setdict = 0;
#endif
                    if (ret == Z_OK && !g.setdict) {
                        // For independent blocks, add a full flush marker.
                        ret = deflate(strm, Z_FULL_FLUSH);
                    }
                }
            } else if (ret == Z_OK && blk->lens.len > 0 && blk->is_last) {
                // Final finish for rsyncable last block
                do {
                    ret = deflate(strm, Z_FINISH);
                    if (ret != Z_OK && ret != Z_STREAM_END) break;
                    if (strm->avail_out == 0) { ret = Z_BUF_ERROR; break; }
                } while (ret != Z_STREAM_END);
            }
                
            // Stage 6: Finalize Result
            size_t deflate_len = strm->total_out;
            if (ret != (blk->is_last ? Z_STREAM_END : Z_OK)) {
                return cc_err(cc_io_error(CC_IO_OTHER));
            }
            
            pos += deflate_len;
            res->data = cc_slice_from_parts(out_buf, pos, CC_SLICE_ID_UNTRACKED, pos);
            cc_atomic_fetch_add(&g_bytes_out, pos);
        } else {
            // Zopfli compression (level 11) (matches pigz.c:2470-2480)
            // pigz ensures each partial raw-deflate stream ends on a byte boundary so
            // streams can be concatenated.

            // Prepare input = [dict_tail][block_data] so zopfli can benefit from history.
            size_t dict_len = (g.setdict ? dict.len : 0);
            size_t in_len = dict_len + blk->data.len;
            unsigned char* z_in = arena_alloc(unsigned char, res_arena, in_len);
            if (!z_in) return cc_err(cc_io_error(CC_IO_OUT_OF_MEMORY));
            if (dict_len) memcpy(z_in, dict.ptr, dict_len);
            memcpy(z_in + dict_len, blk->data.ptr, blk->data.len);

            unsigned char* out = NULL;
            size_t outsize = 0;
            unsigned char bits = 0; // bit position on return (low 3 bits used)

            // datamode=2 for raw deflate, final=blk->is_last
            ZopfliDeflatePart(&g.zopts, 2, blk->is_last,
                              z_in, dict_len, dict_len + blk->data.len,
                              &bits, &out, &outsize);

            if (!out) return cc_err(cc_io_error(CC_IO_OTHER));

            // If not last block, append markers to end on a byte boundary, and
            // add a second marker for independent blocks (matches pigz.c logic).
            size_t extra = 0;
            if (!blk->is_last) {
                extra += 5;                 // worst-case single marker
                if (!g.setdict) extra += 5; // second marker when independent
            }
            unsigned char* out_buf = arena_alloc(unsigned char, res_arena, outsize + extra);
            if (!out_buf) {
                free(out);
                return cc_err(cc_io_error(CC_IO_OUT_OF_MEMORY));
            }
            memcpy(out_buf, out, outsize);
            free(out);

            size_t out_len = outsize;
            if (!blk->is_last) {
                bits &= 7;
                if ((bits & 1) || !g.setdict) {
                    if (bits == 0 || bits > 5) out_buf[out_len++] = 0;
                    out_buf[out_len++] = 0;
                    out_buf[out_len++] = 0;
                    out_buf[out_len++] = 0xff;
                    out_buf[out_len++] = 0xff;
                } else if (bits) {
                    do {
                        out_buf[out_len - 1] += (unsigned char)(2U << bits);
                        out_buf[out_len++] = 0;
                        bits = (unsigned char)(bits + 2);
                    } while (bits < 8);
                }
                if (!g.setdict) {
                    out_buf[out_len++] = 0;
                    out_buf[out_len++] = 0;
                    out_buf[out_len++] = 0;
                    out_buf[out_len++] = 0xff;
                    out_buf[out_len++] = 0xff;
                }
            }

            res->data = cc_slice_from_parts(out_buf, out_len, CC_SLICE_ID_UNTRACKED, out_len);
            cc_atomic_fetch_add(&g_bytes_out, out_len);
        }

        // Update global statistics
        cc_atomic_fetch_add(&g_bytes_in, blk->data.len);
        cc_atomic_fetch_add(&g_blocks_done, 1);

        // Transfer arena ownership: detach empties res_arena, so block cleanup is no-op
        res->arena = cc_arena_detach(res_arena);
        
        return cc_ok(res);
    }
}

/* Return input arena to pool (or free if no pool) */
static inline void return_input_arena(CCArena* arena, CCChan* pool) {
    if (pool) {
        // Send pointer back to pool (pool stores void* which is CCArena*)
        cc_chan_send(pool, &arena, sizeof(arena));
    } else {
        // No pool - free the arena and its wrapper
        cc_arena_free(arena);
        free(arena);
    }
}

/* ============================================================================
 * Ordered Channel Pattern (Manual Lowering)
 * 
 * This implements the "ordered channels" pattern manually to validate the design.
 * The key insight: __result at offset 0 preserves Result type information.
 * ============================================================================ */

/* Captures struct for ordered channel pattern - __result MUST be at offset 0 */
typedef struct {
    CompressedResultPtr !>(CCIoError) __result;  // offset 0 - Result type preserved!
    Block* blk;                                   // user captures follow
} OrderedCompressCaptures;

/* The actual compression work - called from wrapper */
CompressedResultPtr !>(CCIoError) do_compress_work(Block* blk) {
    // Initialize z_stream for this task if needed (level <= 9)
    z_stream strm;
    z_stream* strm_ptr = NULL;
    if (g.level <= 9) {
        memset(&strm, 0, sizeof(strm));
        int ret = deflateInit2(&strm, g.level, Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY);
        if (ret != Z_OK) {
            return cc_err(cc_io_error(CC_IO_OTHER));
        }
        strm_ptr = &strm;
    }
    
    CompressedResultPtr !>(CCIoError) result = compress_block(strm_ptr, blk, blk->dict, g.level, g.strategy);
    
    // Cleanup z_stream
    if (strm_ptr) {
        deflateEnd(strm_ptr);
    }
    
    return result;
}

/* Wrapper for ordered channel pattern: stores Result in fiber-local storage */
void* ordered_compress_wrapper(void* arg) {
    Block* blk = (Block*)arg;
    
    // Use fiber-local storage instead of malloc'd captures struct
    OrderedCompressCaptures* cap = (OrderedCompressCaptures*)cc_task_result_ptr(sizeof(OrderedCompressCaptures));
    cap->blk = blk;  // For debugging/consistency
    
    // Store Result at offset 0 - preserves error type!
    cap->__result = do_compress_work(blk);
    
    // Return input arena to pool (works for both success and error)
    return_input_arena(blk->arena, blk->pool);
    
    return (void*)cap;
}

/* Note: ordered_spawn and ordered_recv are inlined at use sites (lowered code) */

/* ============================================================================
 * Decompression Engine (matches pigz.c:2700-2750)
 * ============================================================================ */

// decompress_block - currently unused, single-threaded decompression in decompress_file
DecompressedResultPtr !>(CCIoError) decompress_block(CCSlice member, long seq) {
    size_t est_size = 256 * 1024;
    @arena(res_arena, est_size + 8192) {
        DecompressedResult* res = arena_alloc1(DecompressedResult, res_arena);
        if (!res) return cc_err(cc_io_error(CC_IO_OUT_OF_MEMORY));
        res->seq = seq;

        z_stream strm;
        memset(&strm, 0, sizeof(strm));
        if (inflateInit2(&strm, 15 + 16) != Z_OK) return cc_err(cc_io_error(CC_IO_OTHER));
        @defer inflateEnd(&strm);

        strm.next_in = (Bytef*)member.ptr;
        strm.avail_in = (uInt)member.len;

        unsigned char* out_buf = arena_alloc(unsigned char, res_arena, est_size);
        if (!out_buf) return cc_err(cc_io_error(CC_IO_OUT_OF_MEMORY));

        strm.next_out = out_buf;
        strm.avail_out = (uInt)est_size;

        int ret = inflate(&strm, Z_FINISH);
        if (ret != Z_STREAM_END && ret != Z_OK) return cc_err(cc_io_error(CC_IO_OTHER));

        res->data = cc_slice_from_parts(out_buf, strm.total_out, CC_SLICE_ID_UNTRACKED, est_size);
        res->arena = cc_arena_detach(res_arena);
        return cc_ok(res);
    }
}

/* Chunk with arena for pipeline transfer */
typedef struct {
    CCSlice data;
    CCArena arena;
} DecompChunk;

int decompress_file(const char* in_path, const char* out_path, int num_workers) {
    (void)num_workers;
    
    CCFile in_file = {0};
    const char* real_in = in_path ? in_path : "/dev/stdin";
    if (cc_file_open(&in_file, real_in, "rb") != 0) {
        fprintf(stderr, "Failed to open input: %s\n", real_in);
        return 1;
    }
    @defer cc_file_close(&in_file);

    CCFile out_file = {0};
    const char* real_out_path = out_path;
    char real_out_buf[4096];
    if (strcmp(out_path, "/dev/stdout") == 0) {
        real_out_path = "/dev/stdout";
    } else {
        // Remove .gz suffix for output name if it exists
        strncpy(real_out_buf, out_path, sizeof(real_out_buf));
        size_t len = strlen(real_out_buf);
        if (len > 3 && strcmp(real_out_buf + len - 3, ".gz") == 0) {
            real_out_buf[len - 3] = '\0';
        }
        real_out_path = real_out_buf;
    }
    
    if (cc_file_open(&out_file, real_out_path, "wb") != 0) {
        fprintf(stderr, "Failed to open output: %s\n", real_out_path);
        return 1;
    }
    @defer cc_file_close(&out_file);

    CCFile* in_ptr = &in_file;
    CCFile* out_ptr = &out_file;

    /* =========================================================================
     * Parallel I/O Decompression Pipeline
     * 
     *  ┌─────────┐     ┌─────────────┐     ┌─────────┐
     *  │ Reader  │────►│ Decompressor│────►│ Writer  │
     *  └─────────┘     └─────────────┘     └─────────┘
     *    (reads          (CPU work)         (writes
     *     ahead)                             behind)
     * ========================================================================= */
    
    // Channel capacity: how many chunks can be buffered
    int pipe_cap = 4;
    
    // Channels for compressed and decompressed data
    DecompChunk[~pipe_cap >] compressed_tx;
    DecompChunk[~pipe_cap <] compressed_rx;
    DecompChunk[~pipe_cap >] decompressed_tx;
    DecompChunk[~pipe_cap <] decompressed_rx;
    
    CCChan* compressed_ch = channel_pair(&compressed_tx, &compressed_rx);
    CCChan* decompressed_ch = channel_pair(&decompressed_tx, &decompressed_rx);
    @defer cc_chan_free(compressed_ch);
    @defer cc_chan_free(decompressed_ch);

    // Stats (shared across tasks)
    _Atomic size_t total_in = 0;
    _Atomic size_t total_out = 0;
    _Atomic size_t* p_total_in = &total_in;
    _Atomic size_t* p_total_out = &total_out;

    @nursery {
        /* Writer Task - writes decompressed data (runs behind) */
        spawn(() => [out_ptr, decompressed_rx, p_total_out] {
            DecompChunk chunk;
                while (cc_io_avail(chan_recv(decompressed_rx, &chunk))) {
                if (chunk.data.len > 0 && !g.test && !g.list) {
                    CCRes(size_t, CCIoError) wr = cc_file_write_buf(out_ptr, chunk.data.ptr, chunk.data.len);
                    if (cc_is_err(wr)) {
                        fprintf(stderr, "Error writing output\n");
                    }
                }
                cc_atomic_fetch_add(p_total_out, chunk.data.len);
                cc_arena_free(&chunk.arena);
            }
        });

        @nursery closing(decompressed_tx) {
            /* Decompressor Task - CPU work in the middle */
            spawn(() => [compressed_rx, decompressed_tx] {
                z_stream strm;
                memset(&strm, 0, sizeof(strm));
                if (inflateInit2(&strm, 15 + 16) != Z_OK) {
                    fprintf(stderr, "Failed to initialize decompression\n");
                } else {
                    DecompChunk in_chunk;
                    while (cc_io_avail(chan_recv(compressed_rx, &in_chunk))) {
                        strm.next_in = (Bytef*)in_chunk.data.ptr;
                        strm.avail_in = (uInt)in_chunk.data.len;
                        
                        bool error = false;
                        // Decompress all available input
                        while (!error && (strm.avail_in > 0 || strm.avail_out == 0)) {
                            // Allocate output chunk
                            CCArena out_arena = cc_arena_heap(BLOCK_SIZE + 256);
                            unsigned char* out_buf = arena_alloc(unsigned char, &out_arena, BLOCK_SIZE);
                            
                            strm.next_out = out_buf;
                            strm.avail_out = BLOCK_SIZE;
                            
                            int ret = inflate(&strm, Z_NO_FLUSH);
                            if (ret == Z_STREAM_ERROR || ret == Z_DATA_ERROR || ret == Z_MEM_ERROR) {
                                fprintf(stderr, "Decompression error: %d\n", ret);
                                cc_arena_free(&out_arena);
                                error = true;
                                break;
                            }
                            
                            size_t have = BLOCK_SIZE - strm.avail_out;
                            if (have > 0) {
                                DecompChunk out_chunk = {
                                    .data = cc_slice_from_parts(out_buf, have, CC_SLICE_ID_UNTRACKED, BLOCK_SIZE),
                                    .arena = out_arena
                                };
                                (void)chan_send(decompressed_tx, out_chunk);
                            } else {
                                cc_arena_free(&out_arena);
                            }
                            
                            if (ret == Z_STREAM_END) break;
                        }
                        
                        cc_arena_free(&in_chunk.arena);
                    }
                    inflateEnd(&strm);
                }
            });

            /* Reader Task - reads compressed data ahead */
            @nursery closing(compressed_tx) {
                spawn(() => [in_ptr, compressed_tx, p_total_in] {
                    while (true) {
                        // Allocate chunk for this read
                        CCArena chunk_arena = cc_arena_heap(BLOCK_SIZE + 256);
                        unsigned char* buf = arena_alloc(unsigned char, &chunk_arena, BLOCK_SIZE);
                        
                        size_t bytes_read;
                        if (!cc_io_avail(cc_file_read_buf(in_ptr, buf, BLOCK_SIZE, &bytes_read))) {
                            cc_arena_free(&chunk_arena);
                            break;  // EOF or error
                        }
                        
                        cc_atomic_fetch_add(p_total_in, bytes_read);
                        
                        DecompChunk chunk = {
                            .data = cc_slice_from_parts(buf, bytes_read, CC_SLICE_ID_UNTRACKED, BLOCK_SIZE),
                            .arena = chunk_arena
                        };
                        (void)chan_send(compressed_tx, chunk);
                    }
                });
            }
        }
    }

    if (g.list) {
        size_t in_total = cc_atomic_load(p_total_in);
        size_t out_total = cc_atomic_load(p_total_out);
        // pigz-style: percentage saved = (out - in) / out
        double ratio = out_total > 0 ? 100.0 * (double)(out_total - in_total) / (double)out_total : 0.0;
        printf("%10zu %10zu %6.1f%% %s\n", in_total, out_total, ratio, in_path ? in_path : "<stdin>");
    }

    cc_file_sync(&out_file);
    return 0;
}

/* ============================================================================
 * Main Compression Pipeline (matches pigz.c:3400-3500)
 * ============================================================================ */

/* Forward declarations */
int process_path(const char* path, int num_workers, int level, int strategy);

int compress_file(const char* in_path, const char* out_path, int num_workers, int level, int strategy) {
    /* num_workers used for round-robin worker affinity */
    
    // Store level and strategy in globals for task wrapper access
    g.level = level;
    g.strategy = strategy;
    
    // Open input file
    CCFile in_file = {0};
    const char* real_in = in_path ? in_path : "/dev/stdin";
    if (cc_file_open(&in_file, real_in, "rb") != 0) {
        fprintf(stderr, "Failed to open input: %s\n", real_in);
        return 1;
    }
    @defer cc_file_close(&in_file);

    // Open output file
    CCFile out_file = {0};
    if (cc_file_open(&out_file, out_path, "wb") != 0) {
        fprintf(stderr, "Failed to open output: %s\n", out_path);
        return 1;
    }
    @defer cc_file_close(&out_file);

    // Reset error flag
    cc_atomic_store(&g_pipeline_error, 0);

    // Initialize CRC combination globals (matches pigz.c:3400-3410)
    size_t block_size = g.block;
    g.shift = x2nmodp(g.block, 3);
    
    // Channel for task handles (task-handle pattern: spawn per block, FIFO await)
    int chan_cap = CHAN_CAP;
    if (g.max_mem > 0) {
        chan_cap = (int)(g.max_mem / (block_size + 65536));
        if (chan_cap < 1) chan_cap = 1;
        if (chan_cap > 1024) chan_cap = 1024;
    }

    CCTask[~chan_cap >] tasks_tx;
    CCTask[~chan_cap <] tasks_rx;

    CCChan* tasks_ch = channel_pair(&tasks_tx, &tasks_rx);
    @defer cc_chan_free(tasks_ch);

    // Input arena pool - reuse arenas instead of malloc/free each block
    size_t arena_size = block_size + BLOCK_ARENA_OVERHEAD + 65536 + (block_size / 5 * sizeof(size_t));
    
    // Arena pool using owned channel syntax - capacity can now be an expression
    CCArena*[~(chan_cap + 16) owned {
        .create = () => [arena_size] {
            CCArena* a = (CCArena*)malloc(sizeof(CCArena));
            *a = cc_arena_heap(arena_size);
            return a;
        },
        .destroy = (CCArena* a) => {
            cc_arena_free(a);
            free(a);
            return NULL;
        },
        .reset = (CCArena* a) => {
            cc_arena_reset(a);
            return NULL;
        }
    }] arena_pool;
    @defer cc_chan_free(arena_pool);

    // Pointers for closure capture
    CCFile* in_ptr = &in_file;
    CCFile* out_ptr = &out_file;

    @nursery {
        /* Writer Task - awaits task handles in FIFO order (no reorder buffer needed) */
        spawn(() => [out_ptr, block_size, out_path, tasks_rx, tasks_ch] {
            bool write_failed = false;

            // gzip + zip use CRC32 init 0; zlib uses Adler-32 init 1
            unsigned long global_crc = (g.form == 1 ? 1UL : 0UL);
            size_t total_len = 0;
            size_t total_comp_len = 0;
            bool first_block = true;
            
            // zip header bookkeeping (single-entry, non-zip64)
            const char* zip_name = NULL;
            uint16_t zip_name_len = 0;
            uint16_t zip_mtime = 0, zip_mdate = 0;
            if (g.form == 2) {
                zip_name = g.name ? g.name : (g.alias ? g.alias : "stdin");
                size_t nlen = strlen(zip_name);
                if (nlen > 0xffff) nlen = 0xffff;
                zip_name_len = (uint16_t)nlen;
                if (g.mtime != 0) {
                    struct tm* tm = localtime(&g.mtime);
                    if (tm) {
                        zip_mtime = (uint16_t)((tm->tm_hour << 11) | (tm->tm_min << 5) | (tm->tm_sec / 2));
                        int year = tm->tm_year + 1900;
                        if (year < 1980) year = 1980;
                        zip_mdate = (uint16_t)(((year - 1980) << 9) | ((tm->tm_mon + 1) << 5) | tm->tm_mday);
                    }
                }
            }
            
            // Write gzip/zlib header once at the beginning (matches pigz.c:1150-1180)
            if (!g.list && !g.test) {
                if (g.form == 0) {
                    // gzip header
                    unsigned char header[10] = {
                        0x1f, 0x8b,  // Magic
                        0x08,        // Deflate method
                        (unsigned char)((g.name != NULL ? 8 : 0) + (g.comment != NULL ? 16 : 0)), // Flags
                        (unsigned char)(g.mtime & 0xff),
                        (unsigned char)((g.mtime >> 8) & 0xff),
                        (unsigned char)((g.mtime >> 16) & 0xff),
                        (unsigned char)((g.mtime >> 24) & 0xff),
                        (unsigned char)(g.level >= 9 ? 2 : g.level == 1 ? 4 : 0), // Extra flags
                        0x03         // OS = Unix
                    };
                    size_t !>(CCIoError) hdr_wr = cc_file_write(out_ptr, cc_slice_from_parts(header, 10, CC_SLICE_ID_UNTRACKED, 10));
                    if (cc_is_err(hdr_wr)) {
                        fprintf(stderr, "Error: failed to write gzip header\n");
                        cc_atomic_store(&g_pipeline_error, 1);
                        write_failed = true;
                    }
                    
                    // Write filename if present
                    if (!write_failed && g.name != NULL) {
                        size_t nlen = strlen(g.name) + 1;
                        size_t !>(CCIoError) name_wr = cc_file_write(out_ptr, cc_slice_from_parts(g.name, nlen, CC_SLICE_ID_UNTRACKED, nlen));
                        if (cc_is_err(name_wr)) {
                            fprintf(stderr, "Error: failed to write filename to header\n");
                            cc_atomic_store(&g_pipeline_error, 1);
                            write_failed = true;
                        }
                    }
                    
                    // Write comment if present
                    if (!write_failed && g.comment != NULL) {
                        size_t clen = strlen(g.comment) + 1;
                        size_t !>(CCIoError) comm_wr = cc_file_write(out_ptr, cc_slice_from_parts(g.comment, clen, CC_SLICE_ID_UNTRACKED, clen));
                        if (cc_is_err(comm_wr)) {
                            fprintf(stderr, "Error: failed to write comment to header\n");
                            cc_atomic_store(&g_pipeline_error, 1);
                            write_failed = true;
                        }
                    }
                } else if (g.form == 1) {
                    // zlib header
                    unsigned head = (0x78 << 8) +
                                   (g.level >= 9 ? 3 << 6 :
                                    g.level == 1 ? 0 << 6 :
                                    g.level >= 6 ? 1 << 6 :
                                    2 << 6);
                    head += 31 - (head % 31);
                    unsigned char header[2];
                    header[0] = (head >> 8) & 0xff;
                    header[1] = head & 0xff;
                    size_t !>(CCIoError) hdr_wr = cc_file_write(out_ptr, cc_slice_from_parts(header, 2, CC_SLICE_ID_UNTRACKED, 2));
                    if (cc_is_err(hdr_wr)) {
                        fprintf(stderr, "Error: failed to write zlib header\n");
                        cc_atomic_store(&g_pipeline_error, 1);
                        write_failed = true;
                    }
                } else if (g.form == 2) {
                    // zip local header (single entry; central directory written at end)
                    unsigned char header[30] = {
                        0x50, 0x4b, 0x03, 0x04, // Local file header signature
                        0x14, 0x00,             // Version needed to extract (2.0)
                        0x08, 0x00,             // General purpose bit flag (bit 3 set for data descriptor)
                        0x08, 0x00,             // Compression method (deflate)
                        0x00, 0x00,             // Last mod file time (filled below)
                        0x00, 0x00,             // Last mod file date (filled below)
                        0x00, 0x00, 0x00, 0x00, // CRC-32 (will be in data descriptor)
                        0x00, 0x00, 0x00, 0x00, // Compressed size (will be in data descriptor)
                        0x00, 0x00, 0x00, 0x00, // Uncompressed size (will be in data descriptor)
                        0x00, 0x00,             // File name length (filled below)
                        0x00, 0x00              // Extra field length
                    };
                    header[10] = (unsigned char)(zip_mtime & 0xff);
                    header[11] = (unsigned char)((zip_mtime >> 8) & 0xff);
                    header[12] = (unsigned char)(zip_mdate & 0xff);
                    header[13] = (unsigned char)((zip_mdate >> 8) & 0xff);
                    header[26] = (unsigned char)(zip_name_len & 0xff);
                    header[27] = (unsigned char)((zip_name_len >> 8) & 0xff);
                    size_t !>(CCIoError) hdr_wr = cc_file_write(out_ptr, cc_slice_from_parts(header, 30, CC_SLICE_ID_UNTRACKED, 30));
                    if (cc_is_err(hdr_wr)) {
                        fprintf(stderr, "Error: failed to write zip header\n");
                        cc_atomic_store(&g_pipeline_error, 1);
                        write_failed = true;
                    }
                    if (!write_failed && zip_name_len) {
                        size_t !>(CCIoError) nm_wr = cc_file_write(out_ptr, cc_slice_from_parts((void*)zip_name, zip_name_len, CC_SLICE_ID_UNTRACKED, zip_name_len));
                        if (cc_is_err(nm_wr)) {
                            fprintf(stderr, "Error: failed to write zip filename\n");
                            cc_atomic_store(&g_pipeline_error, 1);
                            write_failed = true;
                        }
                    }
                }
            }
            
            // Ordered channel pattern: await recv in FIFO order (no reorder buffer!)
            // [LOWERED from: while (await tasks_rx.recv(&r)?)]
            CompressedResult* r = NULL;
            CCIoError recv_err = {0};
            bool recv_ok = true;
            CCTask task;
            while (!write_failed && cc_io_avail(chan_recv(tasks_rx, &task))) {
                // Check for global error (e.g. SIGINT)
                if (cc_atomic_load(&g_pipeline_error)) {
                    write_failed = true;
                    cc_task_free(&task);
                    break;
                }
                
                // Await task and extract Result from fiber-local storage
                // NOTE: cap points to fiber-local buffer, valid until next spawn on same fiber
                OrderedCompressCaptures* cap = (OrderedCompressCaptures*)(void*)cc_block_on_intptr(task);
                
                // Copy result immediately (fiber-local storage may be reused)
                CompressedResultPtr !>(CCIoError) task_result = cap->__result;
                // cap is now unsafe to access - fiber may be reused
                
                if (cc_is_err(task_result)) {
                    // Task error - preserve error type!
                    recv_err = cc_unwrap_err_as(task_result, CCIoError);
                    recv_ok = false;
                    break;
                }
                r = cc_unwrap_as(task_result, CompressedResult*);
                
                // Accumulate global checksum and total length
                if (first_block) {
                    global_crc = r->crc;
                    first_block = false;
                } else {
                    if (g.form == 1)
                        global_crc = adler32_comb(global_crc, r->crc, r->original_len);
                    else
                        global_crc = crc32_comb_with_size(global_crc, r->crc, r->original_len, block_size);
                }
                total_len += r->original_len;
                total_comp_len += r->data.len;

                // Use Result-based I/O for writing data (unless testing/listing)
                if (!g.list && !g.test) {
                    size_t !>(CCIoError) wr = cc_file_write(out_ptr, r->data);
                    if (cc_is_err(wr)) {
                        fprintf(stderr, "Error: write failed at block %ld\n", r->seq);
                        cc_atomic_store(&g_pipeline_error, 1);
                        write_failed = true;
                    }
                }
                
                cc_arena_free(&r->arena);
            }
            
            // Handle task errors (ordered channel preserves error type!)
            if (!recv_ok) {
                fprintf(stderr, "Compression task failed: error kind %d\n", recv_err.kind);
                cc_atomic_store(&g_pipeline_error, 1);
                write_failed = true;
            }

            // Write gzip/zlib trailer (matches pigz.c:1180-1210)
            if (!write_failed && !g.list && !g.test) {
                if (g.form == 0) {
                    // gzip trailer: CRC32 (4 bytes) + original size mod 2^32 (4 bytes)
                    unsigned char trailer[8];
                    trailer[0] = global_crc & 0xff;
                    trailer[1] = (global_crc >> 8) & 0xff;
                    trailer[2] = (global_crc >> 16) & 0xff;
                    trailer[3] = (global_crc >> 24) & 0xff;
                    trailer[4] = total_len & 0xff;
                    trailer[5] = (total_len >> 8) & 0xff;
                    trailer[6] = (total_len >> 16) & 0xff;
                    trailer[7] = (total_len >> 24) & 0xff;
                    
                    size_t !>(CCIoError) tr_wr = cc_file_write(out_ptr, cc_slice_from_parts(trailer, 8, CC_SLICE_ID_UNTRACKED, 8));
                    if (cc_is_err(tr_wr)) {
                        fprintf(stderr, "Error: failed to write gzip trailer\n");
                        cc_atomic_store(&g_pipeline_error, 1);
                        write_failed = true;
                    }
                } else if (g.form == 1) {
                    // zlib trailer: Adler-32 (4 bytes)
                    unsigned char trailer[4];
                    trailer[0] = (global_crc >> 24) & 0xff;
                    trailer[1] = (global_crc >> 16) & 0xff;
                    trailer[2] = (global_crc >> 8) & 0xff;
                    trailer[3] = global_crc & 0xff;
                    size_t !>(CCIoError) tr_wr = cc_file_write(out_ptr, cc_slice_from_parts(trailer, 4, CC_SLICE_ID_UNTRACKED, 4));
                    if (cc_is_err(tr_wr)) {
                        fprintf(stderr, "Error: failed to write zlib trailer\n");
                        cc_atomic_store(&g_pipeline_error, 1);
                        write_failed = true;
                    }
                } else if (g.form == 2) {
                    // Proper single-entry zip: data descriptor + central directory + EOCD.
                    if (total_len > 0xffffffffu || total_comp_len > 0xffffffffu) {
                        fprintf(stderr, "Error: zip output >4GiB not supported yet\n");
                        cc_atomic_store(&g_pipeline_error, 1);
                        write_failed = true;
                    } else {
                        uint32_t crc32v = (uint32_t)global_crc;
                        uint32_t csize = (uint32_t)total_comp_len;
                        uint32_t usize = (uint32_t)total_len;

                        unsigned char dd[16];
                        dd[0] = 0x50; dd[1] = 0x4b; dd[2] = 0x07; dd[3] = 0x08;
                        dd[4] = (unsigned char)(crc32v & 0xff);
                        dd[5] = (unsigned char)((crc32v >> 8) & 0xff);
                        dd[6] = (unsigned char)((crc32v >> 16) & 0xff);
                        dd[7] = (unsigned char)((crc32v >> 24) & 0xff);
                        dd[8] = (unsigned char)(csize & 0xff);
                        dd[9] = (unsigned char)((csize >> 8) & 0xff);
                        dd[10] = (unsigned char)((csize >> 16) & 0xff);
                        dd[11] = (unsigned char)((csize >> 24) & 0xff);
                        dd[12] = (unsigned char)(usize & 0xff);
                        dd[13] = (unsigned char)((usize >> 8) & 0xff);
                        dd[14] = (unsigned char)((usize >> 16) & 0xff);
                        dd[15] = (unsigned char)((usize >> 24) & 0xff);

                        size_t !>(CCIoError) dd_wr = cc_file_write(out_ptr, cc_slice_from_parts(dd, 16, CC_SLICE_ID_UNTRACKED, 16));
                        if (cc_is_err(dd_wr)) {
                            fprintf(stderr, "Error: failed to write zip data descriptor\n");
                            cc_atomic_store(&g_pipeline_error, 1);
                            write_failed = true;
                        }

                        if (!write_failed) {
                            unsigned char cd[46];
                            memset(cd, 0, sizeof(cd));
                            cd[0] = 0x50; cd[1] = 0x4b; cd[2] = 0x01; cd[3] = 0x02;
                            cd[4] = 0x14; cd[5] = 0x00; // version made by
                            cd[6] = 0x14; cd[7] = 0x00; // version needed
                            cd[8] = 0x08; cd[9] = 0x00; // flags (data descriptor)
                            cd[10] = 0x08; cd[11] = 0x00; // method deflate
                            cd[12] = (unsigned char)(zip_mtime & 0xff);
                            cd[13] = (unsigned char)((zip_mtime >> 8) & 0xff);
                            cd[14] = (unsigned char)(zip_mdate & 0xff);
                            cd[15] = (unsigned char)((zip_mdate >> 8) & 0xff);
                            cd[16] = (unsigned char)(crc32v & 0xff);
                            cd[17] = (unsigned char)((crc32v >> 8) & 0xff);
                            cd[18] = (unsigned char)((crc32v >> 16) & 0xff);
                            cd[19] = (unsigned char)((crc32v >> 24) & 0xff);
                            cd[20] = (unsigned char)(csize & 0xff);
                            cd[21] = (unsigned char)((csize >> 8) & 0xff);
                            cd[22] = (unsigned char)((csize >> 16) & 0xff);
                            cd[23] = (unsigned char)((csize >> 24) & 0xff);
                            cd[24] = (unsigned char)(usize & 0xff);
                            cd[25] = (unsigned char)((usize >> 8) & 0xff);
                            cd[26] = (unsigned char)((usize >> 16) & 0xff);
                            cd[27] = (unsigned char)((usize >> 24) & 0xff);
                            cd[28] = (unsigned char)(zip_name_len & 0xff);
                            cd[29] = (unsigned char)((zip_name_len >> 8) & 0xff);
                            // extra len, comment len = 0
                            // relative offset of local header = 0

                            size_t !>(CCIoError) cd_wr = cc_file_write(out_ptr, cc_slice_from_parts(cd, 46, CC_SLICE_ID_UNTRACKED, 46));
                            if (cc_is_err(cd_wr)) {
                                fprintf(stderr, "Error: failed to write zip central directory\n");
                                cc_atomic_store(&g_pipeline_error, 1);
                                write_failed = true;
                            }
                            if (!write_failed && zip_name_len) {
                                size_t !>(CCIoError) nm2_wr = cc_file_write(out_ptr, cc_slice_from_parts((void*)zip_name, zip_name_len, CC_SLICE_ID_UNTRACKED, zip_name_len));
                                if (cc_is_err(nm2_wr)) {
                                    fprintf(stderr, "Error: failed to write zip central directory name\n");
                                    cc_atomic_store(&g_pipeline_error, 1);
                                    write_failed = true;
                                }
                            }

                            if (!write_failed) {
                                uint32_t cd_size = (uint32_t)(46 + zip_name_len);
                                uint32_t cd_off = (uint32_t)(30 + zip_name_len + total_comp_len + 16);
                                unsigned char eocd[22];
                                memset(eocd, 0, sizeof(eocd));
                                eocd[0] = 0x50; eocd[1] = 0x4b; eocd[2] = 0x05; eocd[3] = 0x06;
                                eocd[8] = 0x01; eocd[10] = 0x01; // total entries on this disk / total
                                eocd[12] = (unsigned char)(cd_size & 0xff);
                                eocd[13] = (unsigned char)((cd_size >> 8) & 0xff);
                                eocd[14] = (unsigned char)((cd_size >> 16) & 0xff);
                                eocd[15] = (unsigned char)((cd_size >> 24) & 0xff);
                                eocd[16] = (unsigned char)(cd_off & 0xff);
                                eocd[17] = (unsigned char)((cd_off >> 8) & 0xff);
                                eocd[18] = (unsigned char)((cd_off >> 16) & 0xff);
                                eocd[19] = (unsigned char)((cd_off >> 24) & 0xff);

                                size_t !>(CCIoError) eocd_wr = cc_file_write(out_ptr, cc_slice_from_parts(eocd, 22, CC_SLICE_ID_UNTRACKED, 22));
                                if (cc_is_err(eocd_wr)) {
                                    fprintf(stderr, "Error: failed to write zip end record\n");
                                    cc_atomic_store(&g_pipeline_error, 1);
                                    write_failed = true;
                                }
                            }
                        }
                    }
                }
            }

            // If we failed, signal Reader to stop sending via upstream error propagation
            if (write_failed) {
                cc_chan_rx_close_err(tasks_ch, EIO);
            }

            // If we failed or were interrupted, delete the partial file (matches pigz.c:3600)
            if (write_failed || cc_atomic_load(&g_pipeline_error)) {
                if (out_path && strcmp(out_path, "/dev/stdout") != 0) {
                    unlink(out_path);
                }
            }
        });

        /* Reader Task - spawns compression tasks and sends handles through channel */
        @nursery closing(tasks_tx) {
            spawn(() => [in_ptr, tasks_tx, arena_pool] {
                long seq = 0;
                bool hit_eof = false;
                Block* prev_blk = NULL;
                unsigned long rolling_hash = 2047; // RSYNCHIT
                
                // Maintain a buffer for the last_tail (32KB)
                unsigned char last_tail_buf[32768];
                size_t last_tail_len = 0;
                
                while (!hit_eof) {
                    // Check if pipeline is shutting down due to error
                    if (cc_atomic_load(&g_pipeline_error)) break;
                    
                    // Borrow arena from pool
                    CCArena* blk_arena = NULL;
                    cc_chan_recv(arena_pool, &blk_arena, sizeof(blk_arena));
                    
                    // Read returns Ok(true)=data, Ok(false)=EOF, Err=error
                    CCSlice data;
                    bool !>(CCIoError) read_res = cc_file_read(in_ptr, blk_arena, block_size, &data);
                    if (cc_is_err(read_res)) {
                        fprintf(stderr, "Read error\n");
                        cc_atomic_store(&g_pipeline_error, 1);
                        return_input_arena(blk_arena, arena_pool);
                        break;
                    }

                    if (!cc_io_avail(read_res)) {
                        // EOF
                        return_input_arena(blk_arena, arena_pool);
                        if (prev_blk) {
                            prev_blk->is_last = true;
                            // [LOWERED from: spawn into(tasks_tx)? () => compress(...)]
                            {
                                // No malloc needed - wrapper uses cc_task_result_ptr
                                CCTask task = cc_fiber_spawn_task(ordered_compress_wrapper, prev_blk);
                                if (!cc_io_avail(chan_send(tasks_tx, task))) {
                                    cc_task_free(&task);
                                }
                            }
                            prev_blk = NULL;
                        }
                        break;  // EOF with no data
                    }
                    
                    // Block struct also lives in the arena
                    Block* blk = arena_alloc1(Block, blk_arena);
                    if (!blk) {
                        cc_atomic_store(&g_pipeline_error, 1);
                        return_input_arena(blk_arena, arena_pool);
                        break;
                    }
                    
                    blk->seq = seq++;
                    blk->data = data;
                    blk->dict = (CCSlice){0};
                    blk->lens = (CCSlice){0};
                    blk->is_last = false;  // set later once we know if this is last
                    blk->arena = blk_arena;  // Transfer ownership to Block
                    blk->pool = arena_pool;  // Remember where to return arena
                    
                    // Rsyncable Logic: Find hits and fill blk->lens
                    if (g.rsync) {
                        // Max hits in a block: block_size / 5 (shortest possible block is 5 bytes)
                        size_t max_hits = block_size / 5;
                        size_t* hits = arena_alloc(size_t, blk_arena, max_hits);
                        if (!hits) {
                            fprintf(stderr, "Failed to allocate hits array\n");
                            cc_atomic_store(&g_pipeline_error, 1);
                            return_input_arena(blk_arena, arena_pool);
                            break;
                        }
                        size_t n_hits = 0;
                        
                        const unsigned char* p = (const unsigned char*)data.ptr;
                        size_t last_hit_pos = 0;
                        for (size_t i = 0; i < data.len; i++) {
                            rolling_hash = ((rolling_hash << 1) ^ p[i]) & 0xFFF; // RSYNCMASK
                            if (rolling_hash == 2047) { // RSYNCHIT
                                if (n_hits < max_hits) {
                                    hits[n_hits++] = (i + 1) - last_hit_pos;
                                    last_hit_pos = i + 1;
                                }
                            }
                        }
                        if (n_hits > 0) {
                            // If there's data left after the last hit, add it as a final segment
                            if (last_hit_pos < data.len) {
                                if (n_hits < max_hits) {
                                    hits[n_hits++] = data.len - last_hit_pos;
                                }
                            }
                            blk->lens = cc_slice_from_parts(hits, n_hits * sizeof(size_t), CC_SLICE_ID_UNTRACKED, n_hits * sizeof(size_t));
                        }
                    }

                    // Dictionary Chaining: Copying Strategy
                    if (g.setdict && last_tail_len > 0) {
                        unsigned char* dict_mem = arena_alloc(unsigned char, blk_arena, last_tail_len);
                        if (!dict_mem) {
                            cc_atomic_store(&g_pipeline_error, 1);
                            return_input_arena(blk_arena, arena_pool);
                            break;
                        }
                        memcpy(dict_mem, last_tail_buf, last_tail_len);
                        blk->dict = cc_slice_from_parts(dict_mem, last_tail_len, CC_SLICE_ID_UNTRACKED, last_tail_len);
                    }
                    
                    // Update last_tail for the next block
                    size_t tail_len = data.len > 32768 ? 32768 : data.len;
                    memcpy(last_tail_buf, (const unsigned char*)data.ptr + data.len - tail_len, tail_len);
                    last_tail_len = tail_len;

                    // If we already have a pending block, spawn task
                    if (prev_blk) {
                        // [LOWERED from: spawn into(tasks_tx)? () => compress(...)]
                        {
                            // No malloc needed - wrapper uses cc_task_result_ptr
                            CCTask task = cc_fiber_spawn_task(ordered_compress_wrapper, prev_blk);
                            if (!cc_io_avail(chan_send(tasks_tx, task))) {
                                cc_task_free(&task);
                                return_input_arena(blk_arena, arena_pool);
                                break;
                            }
                        }
                    }

                    // If this was a short read, it's the last block.
                    if (data.len < block_size) {
                        blk->is_last = true;
                        // [LOWERED from: spawn into(tasks_tx)? () => compress(...)]
                        {
                            // No malloc needed - wrapper uses cc_task_result_ptr
                            CCTask task = cc_fiber_spawn_task(ordered_compress_wrapper, blk);
                            if (!cc_io_avail(chan_send(tasks_tx, task))) {
                                cc_task_free(&task);
                            }
                        }
                        prev_blk = NULL;
                        hit_eof = true;
                        break;
                    }

                    // Otherwise, hold this block until we read the next one
                    prev_blk = blk;
                }
            });
        }
    }

    cc_file_sync(&out_file);
    
    // Deep sync if requested (matches pigz.c:3500)
    if (g.sync) {
        cc_file_sync(&out_file);
    }
    
    // Check if pipeline encountered an error
    if (cc_atomic_load(&g_pipeline_error)) {
        return 1;
    }
    return 0;
}

/* Process a single path (file or directory) recursively (matches pigz.c:4600-4620) */
int process_path(const char* path, int num_workers, int level, int strategy) {
    if (path == NULL) {
        /* Stdin - no stat needed */
        g.mtime = 0;
        g.name = g.alias;
        return compress_file(NULL, "/dev/stdout", num_workers, level, strategy);
    }

    struct stat st;
    if (stat(path, &st) != 0) {
        fprintf(stderr, "pigz_cc: %s: %s\n", path, strerror(errno));
        return 1;
    }

    if (S_ISDIR(st.st_mode)) {
        if (!g.recursive) {
            fprintf(stderr, "pigz_cc: %s is a directory -- ignored\n", path);
            return 0;
        }

        @arena(dir_arena, megabytes(1)) {
            CCDirIter* !>(CCIoError) iter_res = cc_dir_open(dir_arena, path);
            if (cc_is_ok(iter_res)) {
                CCDirIter* iter = cc_unwrap_as(iter_res, CCDirIter*);
                @defer cc_dir_close(iter);

                int ret = 0;
                while (true) {
                    CCDirEntry !>(CCIoError) entry_res = cc_dir_next(iter, dir_arena);
                    if (cc_is_err(entry_res)) {
                        // CCIoError is a struct, need _as variant
                        CCIoError err = cc_unwrap_err_as(entry_res, CCIoError);
                        if (err.kind == CC_IO_OTHER && err.os_code == 0) break; // EOF
                        fprintf(stderr, "pigz_cc: %s: error reading directory\n", path);
                        ret = 1;
                        break;
                    }

                    // CCDirEntry is a struct, need _as variant  
                    CCDirEntry entry = cc_unwrap_as(entry_res, CCDirEntry);
                    const char* name = (const char*)entry.name.ptr;
                    
                    // Skip . and ..
                    if (strcmp(name, ".") == 0 || strcmp(name, "..") == 0) continue;

                    // Join path
                    CCSlice path_slice = cc_slice_from_buffer((void*)path, strlen(path));
                    CCSlice full_path_slice = cc_path_join(dir_arena, path_slice, entry.name);
                    const char* full_path = (const char*)full_path_slice.ptr;

                    ret |= process_path(full_path, num_workers, level, strategy);
                }
                return ret;
            } else {
                fprintf(stderr, "pigz_cc: %s: failed to open directory\n", path);
                return 1;
            }
        }
    }

    /* It's a file - set metadata and build output name */
    g.mtime = (g.headis & 2) ? st.st_mtime : 0;
    g.name = (g.headis & 1) ? justname((char*)path) : NULL;

    char output_file[4096];
    if (g.to_stdout) {
        snprintf(output_file, sizeof(output_file), "/dev/stdout");
    } else if (g.decode) {
        // Decompression: remove suffix
        size_t len = strlen(path);
        size_t slen = strlen(g.sufx);
        if (len > slen && strcmp(path + len - slen, g.sufx) == 0) {
            strncpy(output_file, path, len - slen);
            output_file[len - slen] = '\0';
        } else {
            if (!g.force) {
                if (g.verbosity > 0) fprintf(stderr, "pigz_cc: %s does not have %s suffix -- skipped\n", path, g.sufx);
                return 0;
            }
            snprintf(output_file, sizeof(output_file), "%s.out", path);
        }
    } else {
        // Compression: add suffix
        size_t len = strlen(path);
        size_t slen = strlen(g.sufx);
        if (!g.force && len > slen && strcmp(path + len - slen, g.sufx) == 0) {
            if (g.verbosity > 0) fprintf(stderr, "pigz_cc: %s already has %s suffix -- skipped\n", path, g.sufx);
            return 0;
        }
        snprintf(output_file, sizeof(output_file), "%s%s", path, g.sufx);
    }

    int ret = g.decode ? decompress_file(path, output_file, num_workers)
                       : compress_file(path, output_file, num_workers, level, strategy);
    
    if (ret == 0 && !g.to_stdout) {
        copymeta(path, output_file);
        if (!g.keep) {
            unlink(path);
        }
    }
    
    return ret;
}

/* ============================================================================
 * Command Line Interface (matches pigz.c:4100-4600)
 * ============================================================================ */

void usage(const char *prog) {
    fprintf(stderr, "Usage: %s [options] [file]\n", prog);
    fprintf(stderr, "  -c, --stdout      Write to stdout\n");
    fprintf(stderr, "  -d, --decompress  Decompress\n");
    fprintf(stderr, "  -t, --test        Test integrity\n");
    fprintf(stderr, "  -l, --list        List metadata\n");
    fprintf(stderr, "  -k, --keep        Keep original file\n");
    fprintf(stderr, "  -p, --processes N Use N compression threads (default: 4)\n");
    fprintf(stderr, "  -r, --recursive   Recursive directory processing\n");
    fprintf(stderr, "  -f, --force       Force overwrite\n");
    fprintf(stderr, "  -q, --quiet       Quiet mode\n");
    fprintf(stderr, "  -v, --verbose     Verbose mode\n");
    fprintf(stderr, "  -V, --version     Show version\n");
    fprintf(stderr, "  -S, --suffix .sss Use suffix .sss instead of .gz\n");
    fprintf(stderr, "  -z, --zlib        Compress to zlib format\n");
    fprintf(stderr, "  -i, --independent Independent blocks\n");
    fprintf(stderr, "  -1..-9            Compression level (default: 6)\n");
    fprintf(stderr, "  --fast, --best    Compression levels 1 and 9\n");
    fprintf(stderr, "  -H, --huffman     Huffman-only strategy\n");
    fprintf(stderr, "  -U, --rle         RLE strategy\n");
    fprintf(stderr, "  -h, --help        Show this help\n");
}

int main(int argc, char *argv[]) {
    // Default settings (matches pigz.c:4100-4150)
    g.to_stdout = 0;
    g.keep = 0;
    g.recursive = 0;
    g.force = 0;
    g.verbosity = 1;
    g.sync = 0;
    g.form = 0;
    g.sufx = ".gz";
    g.headis = 3;
    g.rsync = 0;
    g.setdict = 1;
    g.decode = 0;
    g.test = 0;
    g.list = 0;
    g.max_mem = 0; // unlimited
    g.name = NULL;
    g.alias = NULL;
    g.comment = NULL;
    g.mtime = 0;
    g.block = BLOCK_SIZE; // Default block size
    ZopfliInitOptions(&g.zopts);
    int num_workers = 0; // 0 = use runtime default (CC_FIBER_WORKERS or CPU count)
    int level = 6;
    int strategy = Z_DEFAULT_STRATEGY;
    
    /* Set up signal handling (matches pigz.c:4627) */
    signal(SIGINT, cut_short);
    signal(SIGTERM, cut_short);
    
    /* Parse arguments (matches pigz.c:4150-4600) */
    for (int i = 1; i < argc; i++) {
        if (argv[i][0] == '-') {
            if (strcmp(argv[i], "-c") == 0 || strcmp(argv[i], "--stdout") == 0 || strcmp(argv[i], "--to-stdout") == 0) {
                g.to_stdout = 1;
            } else if (strcmp(argv[i], "-d") == 0 || strcmp(argv[i], "--decompress") == 0 || strcmp(argv[i], "--uncompress") == 0) {
                g.decode = 1;
            } else if (strcmp(argv[i], "-t") == 0 || strcmp(argv[i], "--test") == 0) {
                g.decode = 1;
                g.test = 1;
            } else if (strcmp(argv[i], "-l") == 0 || strcmp(argv[i], "--list") == 0) {
                g.decode = 1;
                g.list = 1;
            } else if (strcmp(argv[i], "-k") == 0 || strcmp(argv[i], "--keep") == 0) {
                g.keep = 1;
            } else if (strcmp(argv[i], "-r") == 0 || strcmp(argv[i], "--recursive") == 0) {
                g.recursive = 1;
            } else if (strcmp(argv[i], "-R") == 0 || strcmp(argv[i], "--rsyncable") == 0) {
                g.rsync = 1;
            } else if (strcmp(argv[i], "-f") == 0 || strcmp(argv[i], "--force") == 0) {
                g.force = 1;
            } else if (strcmp(argv[i], "-q") == 0 || strcmp(argv[i], "--quiet") == 0 || strcmp(argv[i], "--silent") == 0) {
                g.verbosity = 0;
            } else if (strcmp(argv[i], "-v") == 0 || strcmp(argv[i], "--verbose") == 0) {
                g.verbosity++;
            } else if (strcmp(argv[i], "-V") == 0 || strcmp(argv[i], "--version") == 0) {
                fprintf(stderr, "pigz_cc 1.0\n");
                return 0;
            } else if (strcmp(argv[i], "-z") == 0 || strcmp(argv[i], "--zlib") == 0) {
                g.form = 1;
                g.sufx = ".zz";
            } else if (strcmp(argv[i], "-K") == 0 || strcmp(argv[i], "--zip") == 0) {
                g.form = 2;
                g.sufx = ".zip";
            } else if (strcmp(argv[i], "-i") == 0 || strcmp(argv[i], "--independent") == 0) {
                g.setdict = 0;
            } else if (strcmp(argv[i], "-Y") == 0 || strcmp(argv[i], "--synchronous") == 0) {
                g.sync = 1;
            } else if (strcmp(argv[i], "-H") == 0 || strcmp(argv[i], "--huffman") == 0) {
                strategy = Z_HUFFMAN_ONLY; // matches pigz.c:4280
            } else if (strcmp(argv[i], "-U") == 0 || strcmp(argv[i], "--rle") == 0) {
                strategy = Z_RLE; // matches pigz.c:4282
            } else if (strcmp(argv[i], "-C") == 0 || strcmp(argv[i], "--comment") == 0) {
                g.comment = (i + 1 < argc ? argv[++i] : NULL);
            } else if (strcmp(argv[i], "-A") == 0 || strcmp(argv[i], "--alias") == 0) {
                g.alias = (i + 1 < argc ? argv[++i] : NULL);
            } else if (strcmp(argv[i], "--fast") == 0) {
                level = 1;
            } else if (strcmp(argv[i], "--best") == 0) {
                level = 9;
            } else if (strcmp(argv[i], "-11") == 0) {
                level = 11;
            } else if (strcmp(argv[i], "-h") == 0 || strcmp(argv[i], "--help") == 0) {
                usage(argv[0]);
                return 0;
            } else if (strncmp(argv[i], "-p", 2) == 0 || strncmp(argv[i], "--processes", 11) == 0) {
                const char *val = (argv[i][1] == 'p' && argv[i][2]) ? &argv[i][2] : 
                                  (strncmp(argv[i], "--processes=", 13) == 0 ? &argv[i][13] :
                                  (i + 1 < argc ? argv[++i] : NULL));
                if (val) num_workers = atoi(val);
                if (num_workers < 1) num_workers = 1;
                if (num_workers > MAX_WORKERS) num_workers = MAX_WORKERS;
            } else if (strncmp(argv[i], "-S", 2) == 0 || strncmp(argv[i], "--suffix", 8) == 0) {
                const char *val = (argv[i][1] == 'S' && argv[i][2]) ? &argv[i][2] : 
                                  (strncmp(argv[i], "--suffix=", 9) == 0 ? &argv[i][9] :
                                  (i + 1 < argc ? argv[++i] : NULL));
                if (val) g.sufx = (char*)val;
            } else if (strncmp(argv[i], "-b", 2) == 0 || strncmp(argv[i], "--blocksize", 11) == 0) {
                const char *val = (argv[i][1] == 'b' && argv[i][2]) ? &argv[i][2] : 
                                  (strncmp(argv[i], "--blocksize=", 12) == 0 ? &argv[i][12] :
                                  (i + 1 < argc ? argv[++i] : NULL));
                if (val) {
                    size_t bsize = (size_t)atoll(val);
                    if (bsize < 32) bsize = 32; // matches pigz.c:4210
                    g.block = bsize * 1024; // input is in KB
                }
            } else if (strcmp(argv[i], "-n") == 0 || strcmp(argv[i], "--no-name") == 0) {
                g.headis &= ~1; // matches pigz.c:4240
            } else if (strcmp(argv[i], "-N") == 0 || strcmp(argv[i], "--name") == 0) {
                g.headis |= 1; // matches pigz.c:4242
            } else if (strcmp(argv[i], "-T") == 0 || strcmp(argv[i], "--no-time") == 0) {
                g.headis &= ~2; // matches pigz.c:4244
            } else if (strncmp(argv[i], "-M", 2) == 0 || strncmp(argv[i], "--max-memory", 12) == 0) {
                const char *val = (argv[i][1] == 'M' && argv[i][2]) ? &argv[i][2] : 
                                  (strncmp(argv[i], "--max-memory=", 13) == 0 ? &argv[i][13] :
                                  (i + 1 < argc ? argv[++i] : NULL));
                if (val) g.max_mem = (size_t)atoll(val) * 1024 * 1024; // input is in MB
            } else if (argv[i][1] >= '0' && argv[i][1] <= '9' && argv[i][2] == '\0') {
                level = argv[i][1] - '0';
            } else {
                fprintf(stderr, "Unknown option: %s\n", argv[i]);
                usage(argv[0]);
                return 1;
            }
        }
    }
    
    if (argc < 2) {
        usage(argv[0]);
        return 1;
    }
    
    /* Let scheduler use default 2x cores; affinity distributes across all workers */
    /* (previously: cc_sched_set_num_workers(num_workers)) */
    
    /* Process path recursively for each input file (matches pigz.c:4600-4620) */
    int ret = 0;
    bool had_input = false;
    for (int i = 1; i < argc; i++) {
        if (argv[i][0] == '-') {
            // Skip options (already parsed)
            if (strcmp(argv[i], "-p") == 0 || strcmp(argv[i], "--processes") == 0 ||
                strcmp(argv[i], "-S") == 0 || strcmp(argv[i], "--suffix") == 0 ||
                strcmp(argv[i], "-b") == 0 || strcmp(argv[i], "--blocksize") == 0 ||
                strcmp(argv[i], "-C") == 0 || strcmp(argv[i], "--comment") == 0 ||
                strcmp(argv[i], "-A") == 0 || strcmp(argv[i], "--alias") == 0) {
                i++;
            }
            continue;
        }
        had_input = true;
        if (strcmp(argv[i], "-") == 0) {
            g.to_stdout = 1;
            ret |= process_path(NULL, num_workers, level, strategy);
        } else {
            ret |= process_path(argv[i], num_workers, level, strategy);
        }
    }
    
    if (!had_input) {
        g.to_stdout = 1;
        ret = process_path(NULL, num_workers, level, strategy);
    }
    
    /* Print statistics */
    long bytes_in = cc_atomic_load(&g_bytes_in);
    long bytes_out = cc_atomic_load(&g_bytes_out);
    int blocks = cc_atomic_load(&g_blocks_done);
    if (g.verbosity > 0 && bytes_in > 0) {
        fprintf(stderr, "Total: %ld -> %ld bytes (%.1f%%), %d blocks, %d workers\n",
                bytes_in, bytes_out,
                100.0 * ((double)bytes_out / (double)bytes_in),
                blocks, num_workers);
    }
    
    return ret;
}

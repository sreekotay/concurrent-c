/*
 * pigz_cc.ccs -- Parallel gzip compression in Concurrent-C
 *
 * This version aims for feature parity with Mark Adler's original pigz,
 * while demonstrating idiomatic Concurrent-C patterns:
 * - Result types (T!>(E)) for error propagation
 * - CCFile with Result-based I/O (cc_file_read, cc_file_write)
 * - @nursery + spawn() for structured concurrency
 * - Arena-backed ownership transfer
 */

#include "stdarg.h"
#define _STDARG_H
#include <ccc/std/prelude.cch>
#include <ccc/cc_atomic.cch>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <zlib.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <signal.h>
#include <errno.h>
#include <dirent.h>
#include "/opt/homebrew/include/zopfli.h"

// Manual declaration for ZopfliDeflatePart (matches pigz.c:435-438)
void ZopfliDeflatePart(const ZopfliOptions* options, int datamode, int final,
                       const unsigned char* in, size_t instart, size_t inend,
                       unsigned char* bp, unsigned char** out, size_t* outsize);

#include "pigz_cc.cch"

/* ============================================================================
 * Global State & Statistics
 * ============================================================================ */

/* Global statistics */
cc_atomic_i64 g_bytes_in = 0;
cc_atomic_i64 g_bytes_out = 0;
cc_atomic_int g_blocks_done = 0;

/* Global error flag - when set, all tasks should exit ASAP */
cc_atomic_int g_pipeline_error = 0;

/* ============================================================================
 * Compression Worker
 * ============================================================================ */

/*
 * Compress a single block using a provided z_stream.
 * Returns a CompressedResult*!>(CCIoError) to demonstrate idiomatic error propagation.
 * (matches pigz.c:2310-2350)
 * 
 * Uses @arena block with cc_arena_detach() for clean ownership transfer:
 * - On error: @arena cleanup frees the memory
 * - On success: arena_detach() transfers ownership, cleanup is no-op
 */
CompressedResult* !> (CCIoError) compress_block(z_stream* strm, Block* blk, CCSlice dict, int level, int strategy) {
    // Arena sizing: CompressedResult struct + deflate output
    // Deflate worst case is ~0.03% expansion + 11 bytes; we allow 12.5% + 8KB for safety
    size_t arena_size = blk->data.len + (blk->data.len >> 3) + 8192;
    
    @arena(res_arena, arena_size) {
        CompressedResult* res = arena_alloc1(CompressedResult, res_arena);
        if (!res) return cc_err(CC_IO_OUT_OF_MEMORY);
        
        res->seq = blk->seq;
        res->is_last = blk->is_last;
        res->original_len = blk->data.len;

        // Stage 1: Setup & Checksum (matches pigz.c:2323-2324)
        if (g.form == 0) {
            res->crc = crc32(0UL, (const Bytef*)blk->data.ptr, (uInt)blk->data.len);
        } else {
            res->crc = adler32(1UL, (const Bytef*)blk->data.ptr, (uInt)blk->data.len);
        }

        if (level <= 9) {
            (void)deflateReset(strm);
            (void)deflateParams(strm, level, strategy);

            // Stage 2: Output Buffer Allocation
            // Use deflateBound to ensure we have enough space for the compressed data
            // For rsyncable, we might have many sync markers which add overhead (~5 bytes each)
            size_t max_out = deflateBound(strm, (uLong)blk->data.len) + 128;
            if (blk->lens.len > 0) {
                max_out += (blk->lens.len / sizeof(size_t)) * 10; // Extra space for sync markers
            }
            unsigned char* out_buf = arena_alloc(unsigned char, res_arena, max_out);
            if (!out_buf) return cc_err(CC_IO_OUT_OF_MEMORY);

            size_t pos = 0;

            // Stage 3: Dictionary Loading (matches pigz.c:2330-2335)
            if (dict.len > 0) {
                deflateSetDictionary(strm, (const Bytef*)dict.ptr, (uInt)dict.len);
            }
            
            strm->next_in = (Bytef*)blk->data.ptr;
            strm->avail_in = (uInt)blk->data.len;
            strm->next_out = out_buf + pos;
            strm->avail_out = (uInt)(max_out - pos);
            
            int ret;
            // Stage 4: Deflate Loop (matches pigz.c:2340-2350)
            if (blk->lens.len == 0) {
                // Standard single-segment block
                while (strm->avail_in > 0) {
                    ret = deflate(strm, Z_NO_FLUSH);
                    if (ret != Z_OK) break;
                    if (strm->avail_out == 0) { ret = Z_BUF_ERROR; break; }
                }
            } else {
                // Rsyncable multi-segment block (matches pigz.c:1787-1856)
                size_t* lens = (size_t*)blk->lens.ptr;
                size_t n_lens = blk->lens.len / sizeof(size_t);
                size_t total_in = 0;
                ret = Z_OK;
                
                for (size_t i = 0; i < n_lens; i++) {
                    size_t segment_len = lens[i];
                    if (segment_len == 0) segment_len = blk->data.len - total_in;
                    
                    strm->avail_in = (uInt)segment_len;
                    // next_in is already set correctly at the start or by previous deflate calls
                    total_in += segment_len;
                    
                    // Deflate segment
                    while (strm->avail_in > 0) {
                        ret = deflate(strm, Z_NO_FLUSH);
                        if (ret != Z_OK) break;
                        if (strm->avail_out == 0) { ret = Z_BUF_ERROR; break; }
                    }
                    if (ret != Z_OK) break;
                    
                    // Flush at rsync boundary (unless it's the very end of the last block)
                    if (total_in < blk->data.len || !blk->is_last) {
#if ZLIB_VERNUM >= 0x1260
                        int setdict = (dict.len > 0 || i > 0);
                        ret = deflate(strm, Z_BLOCK);
                        if (ret == Z_OK) {
                            int bits = 0;
                            (void)deflatePending(strm, Z_NULL, &bits);
                            if ((bits & 1) || !setdict) {
                                ret = deflate(strm, Z_SYNC_FLUSH);
                            } else if (bits & 7) {
                                do {
                                    ret = deflatePrime(strm, 10, 2);
                                    if (ret != Z_OK) break;
                                    (void)deflatePending(strm, Z_NULL, &bits);
                                } while (bits & 7);
                                if (ret == Z_OK) ret = deflate(strm, Z_BLOCK);
                            }
                        }
#else
                        ret = deflate(strm, Z_SYNC_FLUSH);
#endif
                        if (ret != Z_OK) break;
                    }
                }
            }

            // Stage 5: Block Boundary Alignment (matches pigz.c:1990-2010)
            // (Only needed if not already handled by the rsyncable loop)
            if (ret == Z_OK && blk->lens.len == 0) {
                if (blk->is_last) {
                    // Finish the stream on the last block.
                    do {
                        ret = deflate(strm, Z_FINISH);
                        if (ret != Z_OK && ret != Z_STREAM_END) break;
                        if (strm->avail_out == 0) { ret = Z_BUF_ERROR; break; }
                    } while (ret != Z_STREAM_END);
                } else {
#if ZLIB_VERNUM >= 0x1260
                    int setdict = (dict.len > 0);
                    // Align to byte boundary without finishing the stream
                    ret = deflate(strm, Z_BLOCK);
                    if (ret == Z_OK) {
                        int bits = 0;
                        (void)deflatePending(strm, Z_NULL, &bits);
                        if ((bits & 1) || !setdict) {
                            ret = deflate(strm, Z_SYNC_FLUSH);
                        } else if (bits & 7) {
                            do {
                                ret = deflatePrime(strm, 10, 2);
                                if (ret != Z_OK) break;
                                (void)deflatePending(strm, Z_NULL, &bits);
                            } while (bits & 7);
                            if (ret == Z_OK) ret = deflate(strm, Z_BLOCK);
                        }
                    }
#else
                    ret = deflate(strm, Z_SYNC_FLUSH);
                    int setdict = 0;
#endif
                    if (ret == Z_OK && !setdict) {
                        // For independent blocks, add a full flush marker.
                        ret = deflate(strm, Z_FULL_FLUSH);
                    }
                }
            } else if (ret == Z_OK && blk->lens.len > 0 && blk->is_last) {
                // Final finish for rsyncable last block
                do {
                    ret = deflate(strm, Z_FINISH);
                    if (ret != Z_OK && ret != Z_STREAM_END) break;
                    if (strm->avail_out == 0) { ret = Z_BUF_ERROR; break; }
                } while (ret != Z_STREAM_END);
            }
                
            // Stage 6: Finalize Result
            size_t deflate_len = strm->total_out;
            if (ret != (blk->is_last ? Z_STREAM_END : Z_OK)) {
                return cc_err(CC_IO_OTHER);
            }
            
            pos += deflate_len;
            res->data = cc_slice_from_parts(out_buf, pos, CC_SLICE_ID_UNTRACKED, pos);
            cc_atomic_fetch_add(&g_bytes_out, pos);
        } else {
            // Zopfli compression (level 11) (matches pigz.c:2470-2480)
            unsigned char* out = NULL;
            size_t outsize = 0;
            unsigned char bp = 0;
            
            // Use ZopfliDeflatePart for exact parity with pigz.c
            // datamode=2 for raw deflate, final=blk->is_last
            ZopfliDeflatePart(&g.zopts, 2, blk->is_last, (const unsigned char*)blk->data.ptr, 0, blk->data.len, &bp, &out, &outsize);
            
            if (!out) return cc_err(CC_IO_OTHER);
            
            // Copy Zopfli output to arena
            unsigned char* out_buf = arena_alloc(unsigned char, res_arena, outsize);
            if (!out_buf) {
                free(out);
                return cc_err(CC_IO_OUT_OF_MEMORY);
            }
            memcpy(out_buf, out, outsize);
            free(out);
            
            res->data = cc_slice_from_parts(out_buf, outsize, CC_SLICE_ID_UNTRACKED, outsize);
            cc_atomic_fetch_add(&g_bytes_out, outsize);
        }

        // Update global statistics
        cc_atomic_fetch_add(&g_bytes_in, blk->data.len);
        cc_atomic_fetch_add(&g_blocks_done, 1);

        // Transfer arena ownership: detach empties res_arena, so block cleanup is no-op
        res->arena = cc_arena_detach(res_arena);
        
        return cc_ok(res);
    }
}

/* ============================================================================
 * Decompression Engine (matches pigz.c:2700-2750)
 * ============================================================================ */

// decompress_block - currently unused, single-threaded decompression in decompress_file
DecompressedResult* !> (CCIoError) decompress_block(CCSlice member, long seq) {
    size_t est_size = 256 * 1024;
    @arena(res_arena, est_size + 8192) {
        DecompressedResult* res = arena_alloc1(DecompressedResult, res_arena);
        if (!res) return cc_err(CC_IO_OUT_OF_MEMORY);
        res->seq = seq;

        z_stream strm;
        memset(&strm, 0, sizeof(strm));
        if (inflateInit2(&strm, 15 + 16) != Z_OK) return cc_err(CC_IO_OTHER);
        @defer inflateEnd(&strm);

        strm.next_in = (Bytef*)member.ptr;
        strm.avail_in = (uInt)member.len;

        unsigned char* out_buf = arena_alloc(unsigned char, res_arena, est_size);
        if (!out_buf) return cc_err(CC_IO_OUT_OF_MEMORY);

        strm.next_out = out_buf;
        strm.avail_out = (uInt)est_size;

        int ret = inflate(&strm, Z_FINISH);
        if (ret != Z_STREAM_END && ret != Z_OK) return cc_err(CC_IO_OTHER);

        res->data = cc_slice_from_parts(out_buf, strm.total_out, CC_SLICE_ID_UNTRACKED, est_size);
        res->arena = cc_arena_detach(res_arena);
        return cc_ok(res);
    }
}

int decompress_file(const char* in_path, const char* out_path, int num_workers) {
    (void)num_workers;  // Single-threaded for now
    
    CCFile in_file = {0};
    const char* real_in = in_path ? in_path : "/dev/stdin";
    if (cc_file_open(&in_file, real_in, "rb") != 0) {
        fprintf(stderr, "Failed to open input: %s\n", real_in);
        return 1;
    }
    @defer cc_file_close(&in_file);

    CCFile out_file = {0};
    const char* real_out_path = out_path;
    char real_out_buf[4096];
    if (strcmp(out_path, "/dev/stdout") == 0) {
        real_out_path = "/dev/stdout";
    } else {
        // Remove .gz suffix for output name if it exists
        strncpy(real_out_buf, out_path, sizeof(real_out_buf));
        size_t len = strlen(real_out_buf);
        if (len > 3 && strcmp(real_out_buf + len - 3, ".gz") == 0) {
            real_out_buf[len - 3] = '\0';
        }
        real_out_path = real_out_buf;
    }
    
    if (cc_file_open(&out_file, real_out_path, "wb") != 0) {
        fprintf(stderr, "Failed to open output: %s\n", real_out_path);
        return 1;
    }
    @defer cc_file_close(&out_file);

    // Single-threaded streaming decompression
    z_stream strm;
    memset(&strm, 0, sizeof(strm));
    if (inflateInit2(&strm, 15 + 16) != Z_OK) {  // 15 + 16 for gzip
        fprintf(stderr, "Failed to initialize decompression\n");
        return 1;
    }
    @defer inflateEnd(&strm);

    unsigned char in_buf[BLOCK_SIZE];
    unsigned char out_buf[BLOCK_SIZE];
    size_t total_in = 0, total_out = 0;
    int ret;

    do {
        // Read compressed data using buffer API (no arena allocation)
        CCRes(size_t, CCIoError) read_res = cc_file_read_buf(&in_file, in_buf, sizeof(in_buf));
        if (cc_is_err(read_res)) {
            fprintf(stderr, "Error reading input\n");
            return 1;
        }
        size_t bytes_read = cc_unwrap(read_res);
        if (bytes_read == 0) break;
        
        total_in += bytes_read;
        strm.next_in = in_buf;
        strm.avail_in = (uInt)bytes_read;

        // Decompress and write
        do {
            strm.next_out = out_buf;
            strm.avail_out = sizeof(out_buf);
            
            ret = inflate(&strm, Z_NO_FLUSH);
            if (ret == Z_STREAM_ERROR || ret == Z_DATA_ERROR || ret == Z_MEM_ERROR) {
                fprintf(stderr, "Decompression error: %d\n", ret);
                return 1;
            }

            size_t have = sizeof(out_buf) - strm.avail_out;
            if (have > 0 && !g.test && !g.list) {
                CCRes(size_t, CCIoError) write_res = cc_file_write_buf(&out_file, out_buf, have);
                if (cc_is_err(write_res) || cc_unwrap(write_res) != have) {
                    fprintf(stderr, "Error writing output\n");
                    return 1;
                }
                total_out += have;
            }
        } while (strm.avail_out == 0);
        
    } while (ret != Z_STREAM_END);

    if (g.list) {
        double ratio = total_in > 0 ? 100.0 * (1.0 - (double)total_in / total_out) : 0.0;
        printf("%10zu %10zu %6.1f%% %s\n", total_in, total_out, ratio, in_path ? in_path : "<stdin>");
    }

    cc_file_sync(&out_file);
    return 0;
}

/* ============================================================================
 * Main Compression Pipeline (matches pigz.c:3400-3500)
 * ============================================================================ */

/* Forward declarations */
int process_path(const char* path, int num_workers, int level, int strategy);

int compress_file(const char* in_path, const char* out_path, int num_workers, int level, int strategy) {
    // Open input file
    CCFile in_file = {0};
    const char* real_in = in_path ? in_path : "/dev/stdin";
    if (cc_file_open(&in_file, real_in, "rb") != 0) {
        fprintf(stderr, "Failed to open input: %s\n", real_in);
        return 1;
    }
    @defer cc_file_close(&in_file);

    // Open output file
    CCFile out_file = {0};
    if (cc_file_open(&out_file, out_path, "wb") != 0) {
        fprintf(stderr, "Failed to open output: %s\n", out_path);
        return 1;
    }
    @defer cc_file_close(&out_file);

    // Reset error flag
    cc_atomic_store(&g_pipeline_error, 0);

    // Initialize CRC combination globals (matches pigz.c:3400-3410)
    size_t block_size = g.block;
    g.shift = x2nmodp(g.block, 3);
    
    // Channels for pipeline (capacity matches REORDER_CAP calculation)
    int chan_cap = CHAN_CAP;
    if (g.max_mem > 0) {
        chan_cap = (int)(g.max_mem / (block_size + 65536));
        if (chan_cap < 1) chan_cap = 1;
        if (chan_cap > 1024) chan_cap = 1024;
    }
    int reorder_cap = chan_cap + num_workers;

    Block*[~chan_cap >] blocks_tx;
    Block*[~chan_cap <] blocks_rx;
    CompressedResult*[~chan_cap >] results_tx;
    CompressedResult*[~chan_cap <] results_rx;

    CCChan* blocks_ch = channel_pair(&blocks_tx, &blocks_rx);
    CCChan* results_ch = channel_pair(&results_tx, &results_rx);
    @defer cc_chan_free(blocks_ch);
    @defer cc_chan_free(results_ch);

    // Pointers for closure capture
    CCFile* in_ptr = &in_file;
    CCFile* out_ptr = &out_file;

    @nursery {
        /* Writer Task - must write blocks in sequence order */
        spawn([out_ptr, block_size, out_path, reorder_cap]() => {
            long next_seq = 0;
            CompressedResult** pending = (CompressedResult**)calloc(reorder_cap, sizeof(CompressedResult*));
            @defer free(pending);
            bool write_failed = false;

            unsigned long global_crc = (g.form == 0 ? 0UL : 1UL);
            size_t total_len = 0;
            bool first_block = true;
            
            // Write gzip/zlib header once at the beginning (matches pigz.c:1150-1180)
            if (!g.list && !g.test) {
                if (g.form == 0) {
                    // gzip header
                    unsigned char header[10] = {
                        0x1f, 0x8b,  // Magic
                        0x08,        // Deflate method
                        (unsigned char)((g.name != NULL ? 8 : 0) + (g.comment != NULL ? 16 : 0)), // Flags
                        (unsigned char)(g.mtime & 0xff),
                        (unsigned char)((g.mtime >> 8) & 0xff),
                        (unsigned char)((g.mtime >> 16) & 0xff),
                        (unsigned char)((g.mtime >> 24) & 0xff),
                        (unsigned char)(level >= 9 ? 2 : level == 1 ? 4 : 0), // Extra flags
                        0x03         // OS = Unix
                    };
                    size_t !> (CCIoError) hdr_wr = cc_file_write(out_ptr, cc_slice_from_parts(header, 10, CC_SLICE_ID_UNTRACKED, 10));
                    if (cc_is_err(hdr_wr)) {
                        fprintf(stderr, "Error: failed to write gzip header\n");
                        cc_atomic_store(&g_pipeline_error, 1);
                        write_failed = true;
                    }
                    
                    // Write filename if present
                    if (!write_failed && g.name != NULL) {
                        size_t nlen = strlen(g.name) + 1;
                        size_t !> (CCIoError) name_wr = cc_file_write(out_ptr, cc_slice_from_parts(g.name, nlen, CC_SLICE_ID_UNTRACKED, nlen));
                        if (cc_is_err(name_wr)) {
                            fprintf(stderr, "Error: failed to write filename to header\n");
                            cc_atomic_store(&g_pipeline_error, 1);
                            write_failed = true;
                        }
                    }
                    
                    // Write comment if present
                    if (!write_failed && g.comment != NULL) {
                        size_t clen = strlen(g.comment) + 1;
                        size_t !> (CCIoError) comm_wr = cc_file_write(out_ptr, cc_slice_from_parts(g.comment, clen, CC_SLICE_ID_UNTRACKED, clen));
                        if (cc_is_err(comm_wr)) {
                            fprintf(stderr, "Error: failed to write comment to header\n");
                            cc_atomic_store(&g_pipeline_error, 1);
                            write_failed = true;
                        }
                    }
                } else if (g.form == 1) {
                    // zlib header
                    unsigned head = (0x78 << 8) +
                                   (level >= 9 ? 3 << 6 :
                                    level == 1 ? 0 << 6 :
                                    level >= 6 ? 1 << 6 :
                                    2 << 6);
                    head += 31 - (head % 31);
                    unsigned char header[2];
                    header[0] = (head >> 8) & 0xff;
                    header[1] = head & 0xff;
                    size_t !> (CCIoError) hdr_wr = cc_file_write(out_ptr, cc_slice_from_parts(header, 2, CC_SLICE_ID_UNTRACKED, 2));
                    if (cc_is_err(hdr_wr)) {
                        fprintf(stderr, "Error: failed to write zlib header\n");
                        cc_atomic_store(&g_pipeline_error, 1);
                        write_failed = true;
                    }
                } else if (g.form == 2) {
                    // zip header (matches pigz.c:1212-1250)
                    unsigned char header[30] = {
                        0x50, 0x4b, 0x03, 0x04, // Local file header signature
                        0x14, 0x00,             // Version needed to extract (2.0)
                        0x08, 0x00,             // General purpose bit flag (bit 3 set for data descriptor)
                        0x08, 0x00,             // Compression method (deflate)
                        0x00, 0x00,             // Last mod file time
                        0x00, 0x00,             // Last mod file date
                        0x00, 0x00, 0x00, 0x00, // CRC-32 (will be in data descriptor)
                        0x00, 0x00, 0x00, 0x00, // Compressed size (will be in data descriptor)
                        0x00, 0x00, 0x00, 0x00, // Uncompressed size (will be in data descriptor)
                        0x00, 0x00,             // File name length
                        0x00, 0x00              // Extra field length
                    };
                    size_t !> (CCIoError) hdr_wr = cc_file_write(out_ptr, cc_slice_from_parts(header, 30, CC_SLICE_ID_UNTRACKED, 30));
                    if (cc_is_err(hdr_wr)) {
                        fprintf(stderr, "Error: failed to write zip header\n");
                        cc_atomic_store(&g_pipeline_error, 1);
                        write_failed = true;
                    }
                }
            }
            
            CompressedResult* r;
            while (!write_failed && chan_recv(results_rx, &r) == 0) {
                // Check for global error (e.g. SIGINT)
                if (cc_atomic_load(&g_pipeline_error)) {
                    write_failed = true;
                    cc_heap_arena_free(&r->arena);
                    break;
                }

                // Insert using modular indexing
                size_t slot = (size_t)(r->seq % reorder_cap);
                
                // Collision is a logic bug in pipeline sizing - abort immediately
                if (pending[slot] != NULL) {
                    fprintf(stderr, "FATAL: Reorder buffer collision at seq %ld (slot %zu holds seq %ld)\n", 
                            r->seq, slot, pending[slot]->seq);
                    fprintf(stderr, "This indicates REORDER_CAP (%d) is too small for the pipeline.\n", reorder_cap);
                    abort();
                }
                pending[slot] = r;
                
                // Drain all consecutive blocks starting from next_seq
                while (!write_failed && pending[next_seq % reorder_cap] != NULL) {
                    slot = (size_t)(next_seq % reorder_cap);
                    r = pending[slot];
                    pending[slot] = NULL;
                    
                    // Accumulate global checksum and total length
                    if (first_block) {
                        global_crc = r->crc;
                        first_block = false;
                    } else {
                        if (g.form == 0) {
                            global_crc = crc32_comb_with_size(global_crc, r->crc, r->original_len, block_size);
                        } else {
                            global_crc = adler32_comb(global_crc, r->crc, r->original_len);
                        }
                    }
                    total_len += r->original_len;

                    // Use Result-based I/O for writing data (unless testing/listing)
                    if (!g.list && !g.test) {
                        size_t !> (CCIoError) wr = cc_file_write(out_ptr, r->data);
                        if (cc_is_ok(wr)) {
                            // Block written successfully
                        } else {
                            fprintf(stderr, "Error: write failed at block %ld\n", r->seq);
                            cc_atomic_store(&g_pipeline_error, 1);
                            write_failed = true;
                        }
                    }
                    
                    cc_heap_arena_free(&r->arena);
                    next_seq++;
                }
            }

            // Write gzip/zlib trailer (matches pigz.c:1180-1210)
            if (!write_failed && !g.list && !g.test) {
                if (g.form == 0) {
                    // gzip trailer: CRC32 (4 bytes) + original size mod 2^32 (4 bytes)
                    unsigned char trailer[8];
                    trailer[0] = global_crc & 0xff;
                    trailer[1] = (global_crc >> 8) & 0xff;
                    trailer[2] = (global_crc >> 16) & 0xff;
                    trailer[3] = (global_crc >> 24) & 0xff;
                    trailer[4] = total_len & 0xff;
                    trailer[5] = (total_len >> 8) & 0xff;
                    trailer[6] = (total_len >> 16) & 0xff;
                    trailer[7] = (total_len >> 24) & 0xff;
                    
                    size_t !> (CCIoError) tr_wr = cc_file_write(out_ptr, cc_slice_from_parts(trailer, 8, CC_SLICE_ID_UNTRACKED, 8));
                    if (cc_is_err(tr_wr)) {
                        fprintf(stderr, "Error: failed to write gzip trailer\n");
                        cc_atomic_store(&g_pipeline_error, 1);
                        write_failed = true;
                    }
                } else if (g.form == 1) {
                    // zlib trailer: Adler-32 (4 bytes)
                    unsigned char trailer[4];
                    trailer[0] = (global_crc >> 24) & 0xff;
                    trailer[1] = (global_crc >> 16) & 0xff;
                    trailer[2] = (global_crc >> 8) & 0xff;
                    trailer[3] = global_crc & 0xff;
                    size_t !> (CCIoError) tr_wr = cc_file_write(out_ptr, cc_slice_from_parts(trailer, 4, CC_SLICE_ID_UNTRACKED, 4));
                    if (cc_is_err(tr_wr)) {
                        fprintf(stderr, "Error: failed to write zlib trailer\n");
                        cc_atomic_store(&g_pipeline_error, 1);
                        write_failed = true;
                    }
                } else if (g.form == 2) {
                    // zip data descriptor (matches pigz.c:1252-1270)
                    unsigned char trailer[16];
                    trailer[0] = 0x50; trailer[1] = 0x4b; trailer[2] = 0x07; trailer[3] = 0x08;
                    trailer[4] = global_crc & 0xff;
                    trailer[5] = (global_crc >> 8) & 0xff;
                    trailer[6] = (global_crc >> 16) & 0xff;
                    trailer[7] = (global_crc >> 24) & 0xff;
                    trailer[8] = total_len & 0xff; // compressed size (simplified)
                    trailer[9] = (total_len >> 8) & 0xff;
                    trailer[10] = (total_len >> 16) & 0xff;
                    trailer[11] = (total_len >> 24) & 0xff;
                    trailer[12] = total_len & 0xff; // uncompressed size
                    trailer[13] = (total_len >> 8) & 0xff;
                    trailer[14] = (total_len >> 16) & 0xff;
                    trailer[15] = (total_len >> 24) & 0xff;
                    
                    size_t !> (CCIoError) tr_wr = cc_file_write(out_ptr, cc_slice_from_parts(trailer, 16, CC_SLICE_ID_UNTRACKED, 16));
                    if (cc_is_err(tr_wr)) {
                        fprintf(stderr, "Error: failed to write zip trailer\n");
                        cc_atomic_store(&g_pipeline_error, 1);
                        write_failed = true;
                    }
                }
            }

            // If we failed or were interrupted, delete the partial file (matches pigz.c:3600)
            if (write_failed || cc_atomic_load(&g_pipeline_error)) {
                if (out_path && strcmp(out_path, "/dev/stdout") != 0) {
                    unlink(out_path);
                }
            }

            // Cleanup any remaining pending blocks
            for (int i = 0; i < reorder_cap; i++) {
                if (pending[i]) cc_heap_arena_free(&pending[i]->arena);
            }
        });

        @nursery closing(results_tx) {
            /* Compression Workers */
            for (int w = 0; w < num_workers; w++) {
                spawn([level, strategy, results_tx, blocks_rx]() => {
                    // Initialize z_stream once per worker (matches pigz.c:2310-2320)
                    z_stream strm;
                    memset(&strm, 0, sizeof(strm));
                    if (level <= 9) {
                        int ret = deflateInit2(&strm, level, Z_DEFLATED, -15, 8, strategy);
                        if (ret != Z_OK) {
                            fprintf(stderr, "Worker failed to initialize zlib\n");
                            cc_atomic_store(&g_pipeline_error, 1);
                        } else {
                            Block* blk;
                            while (chan_recv(blocks_rx, &blk) == 0) {
                                // Check if pipeline is shutting down due to error
                                if (cc_atomic_load(&g_pipeline_error)) {
                                    cc_heap_arena_free(&blk->arena);
                                    continue;  // Drain channel but don't process
                                }
                                
                                // Compress and send result; on error, log and continue
                                CompressedResult* !> (CCIoError) res_val = compress_block(&strm, blk, blk->dict, level, strategy);
                                if (cc_is_ok(res_val)) {
                                    chan_send(results_tx, cc_unwrap(res_val));
                                } else {
                                    // Error is either OUT_OF_MEMORY or OTHER (zlib failure)
                                    fprintf(stderr, "Compression error (seq=%ld)\n", blk->seq);
                                }
                                
                                // Free input block arena
                                cc_heap_arena_free(&blk->arena);
                            }
                            deflateEnd(&strm);
                        }
                    } else {
                        Block* blk;
                        while (chan_recv(blocks_rx, &blk) == 0) {
                            // Check if pipeline is shutting down due to error
                            if (cc_atomic_load(&g_pipeline_error)) {
                                cc_heap_arena_free(&blk->arena);
                                continue;  // Drain channel but don't process
                            }
                            
                            // Compress and send result; on error, log and continue
                            CompressedResult* !> (CCIoError) res_val = compress_block(&strm, blk, blk->dict, level, strategy);
                            if (cc_is_ok(res_val)) {
                                chan_send(results_tx, cc_unwrap(res_val));
                            } else {
                                // Error is either OUT_OF_MEMORY or OTHER (zlib failure)
                                CCIoError err = cc_unwrap_err_as(res_val, CCIoError);
                                fprintf(stderr, "Compression error (seq=%ld, kind=%d, os_code=%d)\n", blk->seq, err.kind, err.os_code);
                            }
                            
                            // Free input block arena
                            cc_heap_arena_free(&blk->arena);
                        }
                    }
                });
            }

            /* Reader Task */
            @nursery closing(blocks_tx) {
                spawn([in_ptr, blocks_tx]() => {
                    long seq = 0;
                    bool hit_eof = false;
                    Block* prev_blk = NULL;
                    unsigned long rolling_hash = 2047; // RSYNCHIT
                    
                    // Maintain a buffer for the last_tail (32KB)
                    unsigned char last_tail_buf[32768];
                    size_t last_tail_len = 0;
                    
                    while (!hit_eof) {
                        // Check if pipeline is shutting down due to error
                        if (cc_atomic_load(&g_pipeline_error)) break;
                        
                        // Arena needs space for data, Block struct, dictionary copy, and rsync hits
                        CCArena blk_arena = cc_heap_arena(block_size + BLOCK_ARENA_OVERHEAD + 65536 + (block_size / 5 * sizeof(size_t)));
                        
                        // Read returns Ok(slice) or Err; empty slice on EOF
                        CCSlice !> (CCIoError) read_res = cc_file_read(in_ptr, &blk_arena, block_size);
                        if (cc_is_err(read_res)) {
                            fprintf(stderr, "Read error\n");
                            cc_atomic_store(&g_pipeline_error, 1);
                            cc_heap_arena_free(&blk_arena);
                            break;
                        }
                        CCSlice data = cc_unwrap_as(read_res, CCSlice);

                        if (data.len == 0) {
                            cc_heap_arena_free(&blk_arena);
                            if (prev_blk) {
                                prev_blk->is_last = true;
                                chan_send(blocks_tx, prev_blk);
                                prev_blk = NULL;
                            }
                            break;  // EOF with no data
                        }
                        
                        // Block struct also lives in the arena
                        Block* blk = arena_alloc1(Block, &blk_arena);
                        if (!blk) {
                            cc_atomic_store(&g_pipeline_error, 1);
                            cc_heap_arena_free(&blk_arena);
                            break;
                        }
                        
                        blk->seq = seq++;
                        blk->data = data;
                        blk->dict = (CCSlice){0};
                        blk->lens = (CCSlice){0};
                        blk->is_last = false;  // set later once we know if this is last
                        blk->arena = blk_arena;  // Transfer ownership to Block
                        
                        // Rsyncable Logic: Find hits and fill blk->lens
                        if (g.rsync) {
                            // Max hits in a block: block_size / 5 (shortest possible block is 5 bytes)
                            size_t max_hits = block_size / 5;
                            size_t* hits = arena_alloc(size_t, &blk_arena, max_hits);
                            if (!hits) {
                                fprintf(stderr, "Failed to allocate hits array\n");
                                cc_atomic_store(&g_pipeline_error, 1);
                                cc_heap_arena_free(&blk_arena);
                                break;
                            }
                            size_t n_hits = 0;
                            
                            const unsigned char* p = (const unsigned char*)data.ptr;
                            size_t last_hit_pos = 0;
                            for (size_t i = 0; i < data.len; i++) {
                                rolling_hash = ((rolling_hash << 1) ^ p[i]) & 0xFFF; // RSYNCMASK
                                if (rolling_hash == 2047) { // RSYNCHIT
                                    if (n_hits < max_hits) {
                                        hits[n_hits++] = (i + 1) - last_hit_pos;
                                        last_hit_pos = i + 1;
                                    }
                                }
                            }
                            if (n_hits > 0) {
                                // If there's data left after the last hit, add it as a final segment
                                if (last_hit_pos < data.len) {
                                    if (n_hits < max_hits) {
                                        hits[n_hits++] = data.len - last_hit_pos;
                                    }
                                }
                                blk->lens = cc_slice_from_parts(hits, n_hits * sizeof(size_t), CC_SLICE_ID_UNTRACKED, n_hits * sizeof(size_t));
                            }
                        }

                        // Dictionary Chaining: Copying Strategy
                        if (last_tail_len > 0) {
                            unsigned char* dict_mem = arena_alloc(unsigned char, &blk_arena, last_tail_len);
                            if (!dict_mem) {
                                cc_atomic_store(&g_pipeline_error, 1);
                                cc_heap_arena_free(&blk_arena);
                                break;
                            }
                            memcpy(dict_mem, last_tail_buf, last_tail_len);
                            blk->dict = cc_slice_from_parts(dict_mem, last_tail_len, CC_SLICE_ID_UNTRACKED, last_tail_len);
                        }
                        
                        // Update last_tail for the next block
                        size_t tail_len = data.len > 32768 ? 32768 : data.len;
                        memcpy(last_tail_buf, (const unsigned char*)data.ptr + data.len - tail_len, tail_len);
                        last_tail_len = tail_len;

                        // If we already have a pending block, send it now.
                        if (prev_blk) {
                            chan_send(blocks_tx, prev_blk);
                        }

                        // If this was a short read, it's the last block.
                        if (data.len < block_size) {
                            blk->is_last = true;
                            chan_send(blocks_tx, blk);
                            prev_blk = NULL;
                            hit_eof = true;
                            break;
                        }

                        // Otherwise, hold this block until we read the next one
                        prev_blk = blk;
                    }
                });
            }
        }
    }

    cc_file_sync(&out_file);
    
    // Deep sync if requested (matches pigz.c:3500)
    if (g.sync) {
        cc_file_sync(&out_file);
    }
    
    // Check if pipeline encountered an error
    if (cc_atomic_load(&g_pipeline_error)) {
        return 1;
    }
    return 0;
}

/* Process a single path (file or directory) recursively (matches pigz.c:4600-4620) */
int process_path(const char* path, int num_workers, int level, int strategy) {
    if (path == NULL) {
        /* Stdin - no stat needed */
        g.mtime = 0;
        g.name = g.alias;
        return compress_file(NULL, "/dev/stdout", num_workers, level, strategy);
    }

    struct stat st;
    if (stat(path, &st) != 0) {
        fprintf(stderr, "pigz_cc: %s: %s\n", path, strerror(errno));
        return 1;
    }

    if (S_ISDIR(st.st_mode)) {
        if (!g.recursive) {
            fprintf(stderr, "pigz_cc: %s is a directory -- ignored\n", path);
            return 0;
        }

        @arena(dir_arena, megabytes(1)) {
            CCDirIter* !> (CCIoError) iter_res = cc_dir_open(dir_arena, path);
            if (cc_is_ok(iter_res)) {
                CCDirIter* iter = cc_unwrap(iter_res);
                @defer cc_dir_close(iter);

                int ret = 0;
                while (true) {
                    CCDirEntry !> (CCIoError) entry_res = cc_dir_next(iter, dir_arena);
                    if (cc_is_err(entry_res)) {
                        // CCIoError is a struct, need _as variant
                        CCIoError err = cc_unwrap_err_as(entry_res, CCIoError);
                        if (err.kind == CC_IO_OTHER && err.os_code == 0) break; // EOF
                        fprintf(stderr, "pigz_cc: %s: error reading directory\n", path);
                        ret = 1;
                        break;
                    }

                    // CCDirEntry is a struct, need _as variant  
                    CCDirEntry entry = cc_unwrap_as(entry_res, CCDirEntry);
                    const char* name = (const char*)entry.name.ptr;
                    
                    // Skip . and ..
                    if (strcmp(name, ".") == 0 || strcmp(name, "..") == 0) continue;

                    // Join path
                    CCSlice path_slice = cc_slice_from_buffer((void*)path, strlen(path));
                    CCSlice full_path_slice = cc_path_join(dir_arena, path_slice, entry.name);
                    const char* full_path = (const char*)full_path_slice.ptr;

                    ret |= process_path(full_path, num_workers, level, strategy);
                }
                return ret;
            } else {
                fprintf(stderr, "pigz_cc: %s: failed to open directory\n", path);
                return 1;
            }
        }
    }

    /* It's a file - set metadata and build output name */
    g.mtime = (g.headis & 2) ? st.st_mtime : 0;
    g.name = (g.headis & 1) ? justname((char*)path) : NULL;

    char output_file[4096];
    if (g.to_stdout) {
        snprintf(output_file, sizeof(output_file), "/dev/stdout");
    } else if (g.decode) {
        // Decompression: remove suffix
        size_t len = strlen(path);
        size_t slen = strlen(g.sufx);
        if (len > slen && strcmp(path + len - slen, g.sufx) == 0) {
            strncpy(output_file, path, len - slen);
            output_file[len - slen] = '\0';
        } else {
            if (!g.force) {
                if (g.verbosity > 0) fprintf(stderr, "pigz_cc: %s does not have %s suffix -- skipped\n", path, g.sufx);
                return 0;
            }
            snprintf(output_file, sizeof(output_file), "%s.out", path);
        }
    } else {
        // Compression: add suffix
        size_t len = strlen(path);
        size_t slen = strlen(g.sufx);
        if (!g.force && len > slen && strcmp(path + len - slen, g.sufx) == 0) {
            if (g.verbosity > 0) fprintf(stderr, "pigz_cc: %s already has %s suffix -- skipped\n", path, g.sufx);
            return 0;
        }
        snprintf(output_file, sizeof(output_file), "%s%s", path, g.sufx);
    }

    int ret = g.decode ? decompress_file(path, output_file, num_workers)
                       : compress_file(path, output_file, num_workers, level, strategy);
    
    if (ret == 0 && !g.to_stdout) {
        copymeta(path, output_file);
        if (!g.keep) {
            unlink(path);
        }
    }
    
    return ret;
}

/* ============================================================================
 * Command Line Interface (matches pigz.c:4100-4600)
 * ============================================================================ */

void usage(const char *prog) {
    fprintf(stderr, "Usage: %s [options] [file]\n", prog);
    fprintf(stderr, "  -c, --stdout      Write to stdout\n");
    fprintf(stderr, "  -d, --decompress  Decompress\n");
    fprintf(stderr, "  -t, --test        Test integrity\n");
    fprintf(stderr, "  -l, --list        List metadata\n");
    fprintf(stderr, "  -k, --keep        Keep original file\n");
    fprintf(stderr, "  -p, --processes N Use N compression threads (default: 4)\n");
    fprintf(stderr, "  -r, --recursive   Recursive directory processing\n");
    fprintf(stderr, "  -f, --force       Force overwrite\n");
    fprintf(stderr, "  -q, --quiet       Quiet mode\n");
    fprintf(stderr, "  -v, --verbose     Verbose mode\n");
    fprintf(stderr, "  -V, --version     Show version\n");
    fprintf(stderr, "  -S, --suffix .sss Use suffix .sss instead of .gz\n");
    fprintf(stderr, "  -z, --zlib        Compress to zlib format\n");
    fprintf(stderr, "  -i, --independent Independent blocks\n");
    fprintf(stderr, "  -1..-9            Compression level (default: 6)\n");
    fprintf(stderr, "  --fast, --best    Compression levels 1 and 9\n");
    fprintf(stderr, "  -H, --huffman     Huffman-only strategy\n");
    fprintf(stderr, "  -U, --rle         RLE strategy\n");
    fprintf(stderr, "  -h, --help        Show this help\n");
}

int main(int argc, char *argv[]) {
    // Default settings (matches pigz.c:4100-4150)
    g.to_stdout = 0;
    g.keep = 0;
    g.recursive = 0;
    g.force = 0;
    g.verbosity = 1;
    g.sync = 0;
    g.form = 0;
    g.sufx = ".gz";
    g.headis = 3;
    g.rsync = 0;
    g.decode = 0;
    g.test = 0;
    g.list = 0;
    g.max_mem = 0; // unlimited
    g.name = NULL;
    g.alias = NULL;
    g.comment = NULL;
    g.mtime = 0;
    g.block = BLOCK_SIZE; // Default block size
    ZopfliInitOptions(&g.zopts);
    int num_workers = 4;
    int level = 6;
    int strategy = Z_DEFAULT_STRATEGY;
    
    /* Set up signal handling (matches pigz.c:4627) */
    signal(SIGINT, cut_short);
    signal(SIGTERM, cut_short);
    
    /* Parse arguments (matches pigz.c:4150-4600) */
    for (int i = 1; i < argc; i++) {
        if (argv[i][0] == '-') {
            if (strcmp(argv[i], "-c") == 0 || strcmp(argv[i], "--stdout") == 0 || strcmp(argv[i], "--to-stdout") == 0) {
                g.to_stdout = 1;
            } else if (strcmp(argv[i], "-d") == 0 || strcmp(argv[i], "--decompress") == 0 || strcmp(argv[i], "--uncompress") == 0) {
                g.decode = 1;
            } else if (strcmp(argv[i], "-t") == 0 || strcmp(argv[i], "--test") == 0) {
                g.decode = 1;
                g.test = 1;
            } else if (strcmp(argv[i], "-l") == 0 || strcmp(argv[i], "--list") == 0) {
                g.decode = 1;
                g.list = 1;
            } else if (strcmp(argv[i], "-k") == 0 || strcmp(argv[i], "--keep") == 0) {
                g.keep = 1;
            } else if (strcmp(argv[i], "-r") == 0 || strcmp(argv[i], "--recursive") == 0) {
                g.recursive = 1;
            } else if (strcmp(argv[i], "-R") == 0 || strcmp(argv[i], "--rsyncable") == 0) {
                g.rsync = 1;
            } else if (strcmp(argv[i], "-f") == 0 || strcmp(argv[i], "--force") == 0) {
                g.force = 1;
            } else if (strcmp(argv[i], "-q") == 0 || strcmp(argv[i], "--quiet") == 0 || strcmp(argv[i], "--silent") == 0) {
                g.verbosity = 0;
            } else if (strcmp(argv[i], "-v") == 0 || strcmp(argv[i], "--verbose") == 0) {
                g.verbosity++;
            } else if (strcmp(argv[i], "-V") == 0 || strcmp(argv[i], "--version") == 0) {
                fprintf(stderr, "pigz_cc 1.0\n");
                return 0;
            } else if (strcmp(argv[i], "-z") == 0 || strcmp(argv[i], "--zlib") == 0) {
                g.form = 1;
                g.sufx = ".zz";
            } else if (strcmp(argv[i], "-K") == 0 || strcmp(argv[i], "--zip") == 0) {
                g.form = 2;
                g.sufx = ".zip";
            } else if (strcmp(argv[i], "-i") == 0 || strcmp(argv[i], "--independent") == 0) {
                // Already default
            } else if (strcmp(argv[i], "-Y") == 0 || strcmp(argv[i], "--synchronous") == 0) {
                g.sync = 1;
            } else if (strcmp(argv[i], "-H") == 0 || strcmp(argv[i], "--huffman") == 0) {
                strategy = Z_HUFFMAN_ONLY; // matches pigz.c:4280
            } else if (strcmp(argv[i], "-U") == 0 || strcmp(argv[i], "--rle") == 0) {
                strategy = Z_RLE; // matches pigz.c:4282
            } else if (strcmp(argv[i], "-C") == 0 || strcmp(argv[i], "--comment") == 0) {
                g.comment = (i + 1 < argc ? argv[++i] : NULL);
            } else if (strcmp(argv[i], "-A") == 0 || strcmp(argv[i], "--alias") == 0) {
                g.alias = (i + 1 < argc ? argv[++i] : NULL);
            } else if (strcmp(argv[i], "--fast") == 0) {
                level = 1;
            } else if (strcmp(argv[i], "--best") == 0) {
                level = 9;
            } else if (strcmp(argv[i], "-11") == 0) {
                level = 11;
            } else if (strcmp(argv[i], "-h") == 0 || strcmp(argv[i], "--help") == 0) {
                usage(argv[0]);
                return 0;
            } else if (strncmp(argv[i], "-p", 2) == 0 || strncmp(argv[i], "--processes", 11) == 0) {
                const char *val = (argv[i][1] == 'p' && argv[i][2]) ? &argv[i][2] : 
                                  (strncmp(argv[i], "--processes=", 13) == 0 ? &argv[i][13] :
                                  (i + 1 < argc ? argv[++i] : NULL));
                if (val) num_workers = atoi(val);
                if (num_workers < 1) num_workers = 1;
                if (num_workers > MAX_WORKERS) num_workers = MAX_WORKERS;
            } else if (strncmp(argv[i], "-S", 2) == 0 || strncmp(argv[i], "--suffix", 8) == 0) {
                const char *val = (argv[i][1] == 'S' && argv[i][2]) ? &argv[i][2] : 
                                  (strncmp(argv[i], "--suffix=", 9) == 0 ? &argv[i][9] :
                                  (i + 1 < argc ? argv[++i] : NULL));
                if (val) g.sufx = (char*)val;
            } else if (strncmp(argv[i], "-b", 2) == 0 || strncmp(argv[i], "--blocksize", 11) == 0) {
                const char *val = (argv[i][1] == 'b' && argv[i][2]) ? &argv[i][2] : 
                                  (strncmp(argv[i], "--blocksize=", 12) == 0 ? &argv[i][12] :
                                  (i + 1 < argc ? argv[++i] : NULL));
                if (val) {
                    size_t bsize = (size_t)atoll(val);
                    if (bsize < 32) bsize = 32; // matches pigz.c:4210
                    g.block = bsize * 1024; // input is in KB
                }
            } else if (strcmp(argv[i], "-n") == 0 || strcmp(argv[i], "--no-name") == 0) {
                g.headis &= ~1; // matches pigz.c:4240
            } else if (strcmp(argv[i], "-N") == 0 || strcmp(argv[i], "--name") == 0) {
                g.headis |= 1; // matches pigz.c:4242
            } else if (strcmp(argv[i], "-T") == 0 || strcmp(argv[i], "--no-time") == 0) {
                g.headis &= ~2; // matches pigz.c:4244
            } else if (strncmp(argv[i], "-M", 2) == 0 || strncmp(argv[i], "--max-memory", 12) == 0) {
                const char *val = (argv[i][1] == 'M' && argv[i][2]) ? &argv[i][2] : 
                                  (strncmp(argv[i], "--max-memory=", 13) == 0 ? &argv[i][13] :
                                  (i + 1 < argc ? argv[++i] : NULL));
                if (val) g.max_mem = (size_t)atoll(val) * 1024 * 1024; // input is in MB
            } else if (argv[i][1] >= '0' && argv[i][1] <= '9' && argv[i][2] == '\0') {
                level = argv[i][1] - '0';
            } else {
                fprintf(stderr, "Unknown option: %s\n", argv[i]);
                usage(argv[0]);
                return 1;
            }
        }
    }
    
    if (argc < 2) {
        usage(argv[0]);
        return 1;
    }
    
    /* Process path recursively for each input file (matches pigz.c:4600-4620) */
    int ret = 0;
    bool had_input = false;
    for (int i = 1; i < argc; i++) {
        if (argv[i][0] == '-') {
            // Skip options (already parsed)
            if (strcmp(argv[i], "-p") == 0 || strcmp(argv[i], "--processes") == 0 ||
                strcmp(argv[i], "-S") == 0 || strcmp(argv[i], "--suffix") == 0 ||
                strcmp(argv[i], "-b") == 0 || strcmp(argv[i], "--blocksize") == 0 ||
                strcmp(argv[i], "-C") == 0 || strcmp(argv[i], "--comment") == 0 ||
                strcmp(argv[i], "-A") == 0 || strcmp(argv[i], "--alias") == 0) {
                i++;
            }
            continue;
        }
        had_input = true;
        if (strcmp(argv[i], "-") == 0) {
            g.to_stdout = 1;
            ret |= process_path(NULL, num_workers, level, strategy);
        } else {
            ret |= process_path(argv[i], num_workers, level, strategy);
        }
    }
    
    if (!had_input) {
        g.to_stdout = 1;
        ret = process_path(NULL, num_workers, level, strategy);
    }
    
    /* Print statistics */
    long bytes_in = cc_atomic_load(&g_bytes_in);
    long bytes_out = cc_atomic_load(&g_bytes_out);
    int blocks = cc_atomic_load(&g_blocks_done);
    if (g.verbosity > 0 && bytes_in > 0) {
        fprintf(stderr, "Total: %ld -> %ld bytes (%.1f%%), %d blocks, %d workers\n",
                bytes_in, bytes_out,
                100.0 * (1.0 - (double)bytes_out / bytes_in),
                blocks, num_workers);
    }
    
    return ret;
}

/*
 * pigz_cc.ccs -- Parallel gzip compression in Concurrent-C
 *
 * This version aims for feature parity with Mark Adler's original pigz,
 * while demonstrating idiomatic Concurrent-C patterns:
 * - Result types (T!>(E)) for error propagation
 * - CCFile with Result-based I/O (cc_file_read, cc_file_write)
 * - @nursery + spawn() for structured concurrency
 * - Arena-backed ownership transfer
 */

#include <ccc/std/prelude.cch>
#include <ccc/cc_atomic.cch>
#include "/Users/skotay/Documents/code/concurrent-c/third_party/tcc/include/stdarg.h"
#define _STDARG_H
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <zlib.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <signal.h>
#include <errno.h>
#include <dirent.h>
#include "/opt/homebrew/include/zopfli.h"

/* ============================================================================
 * Configuration
 * ============================================================================ */

#define BLOCK_SIZE (128 * 1024)
#define BLOCK_ARENA_OVERHEAD 1024  // Space for Block struct + alignment
#define MAX_WORKERS 16
#define CHAN_CAP 64
// Reorder buffer must hold: channel capacity + workers (each may hold 1 block)
#define REORDER_CAP (CHAN_CAP + MAX_WORKERS)

/* ============================================================================
 * Data Types
 * ============================================================================ */

typedef uint32_t crc_t;

typedef struct {
    long seq;
    CCSlice data;
    CCSlice dict;  // Copy of previous block's tail
    CCSlice lens;  // Optional: list of rsyncable segment lengths (size_t)
    bool is_last;
    CCArena arena; // Owns data, dict, and lens
} Block;

typedef struct {
    long seq;
    CCSlice data;
    unsigned long crc;
    size_t original_len;
    bool is_last;
    CCArena arena;  // Owns the compressed data buffer
} CompressedResult;

typedef struct {
    long seq;
    CCSlice data;
    CCArena arena;
} DecompressedResult;

typedef struct {
    long seq;
    CCSlice member;
    CCArena arena;
} MemberJob;

typedef DecompressedResult* DecompressedResultPtr;
typedef CompressedResult* CompressedResultPtr;

/* Global configuration and state */
struct {
    size_t block;           // uncompressed input size per thread
    crc_t shift;            // pre-calculated CRC-32 shift for length block
    int strategy;           // compression strategy
    int recursive;          // recursive directory processing
    int keep;               // keep original file
    int to_stdout;          // write to stdout
    int force;              // force overwrite
    int verbosity;          // verbosity level
    int sync;               // force sync to storage
    int form;               // 0=gzip, 1=zlib
    char *sufx;             // compressed file suffix
    int headis;             // header bits (matches pigz.c)
    ZopfliOptions zopts;    // zopfli compression options
    int rsync;              // true for rsync blocking
    int decode;             // 0=compress, 1=decompress
    char *name;             // name for gzip header
    char *alias;            // name for zip header when input is stdin
    char *comment;          // comment for gzip or zip header
    time_t mtime;           // modification time for header
} g;

/* Global statistics */
cc_atomic_i64 g_bytes_in = 0;
cc_atomic_i64 g_bytes_out = 0;
cc_atomic_int g_blocks_done = 0;

/* Global error flag - when set, all tasks should exit ASAP */
cc_atomic_int g_pipeline_error = 0;

/* Signal handling */
static void cut_short(int sig) {
    (void)sig;
    cc_atomic_store(&g_pipeline_error, 1);
}

/* Metadata preservation (matches pigz.c:3857) */
static int copymeta(const char *from, const char *to) {
    struct stat st;
    struct timeval times[2];

    if (stat(from, &st) != 0 || !S_ISREG(st.st_mode))
        return -1;

    // Set mode bits
    int ret = chmod(to, st.st_mode & 07777);

    // Copy owner and group
    ret += chown(to, st.st_uid, st.st_gid);

    // Copy access and modify times
    times[0].tv_sec = st.st_atime;
    times[0].tv_usec = 0;
    times[1].tv_sec = st.st_mtime;
    times[1].tv_usec = 0;
    ret += utimes(to, times);
    return ret;
}

/* Extract just the filename from a path (matches pigz.c:justname) */
static char *justname(char *path) {
    char *p = strrchr(path, '/');
    return p == NULL ? path : p + 1;
}

/* ============================================================================
 * CRC32 Combination
 * ============================================================================ */

// CRC-32 polynomial, reflected.
#define POLY 0xedb88320

// Return a(x) multiplied by b(x) modulo p(x), where p(x) is the CRC
// polynomial, reflected. For speed, this requires that a not be zero.
// (matches pigz.c:1328-1344)
static crc_t multmodp(crc_t a, crc_t b) {
    crc_t m = (crc_t)1 << 31;
    crc_t p = 0;
    for (;;) {
        if (a & m) {
            p ^= b;
            if ((a & (m - 1)) == 0)
                break;
        }
        m >>= 1;
        b = b & 1 ? (b >> 1) ^ POLY : b >> 1;
    }
    return p;
}

// Table of x^2^n modulo p(x).
static const crc_t x2n_table[] = {
    0x40000000, 0x20000000, 0x08000000, 0x00800000, 0x00008000,
    0xedb88320, 0xb1e6b092, 0xa06a2517, 0xed627dae, 0x88d14467,
    0xd7bbfe6a, 0xec447f11, 0x8e7ea170, 0x6427800e, 0x4d47bae0,
    0x09fe548f, 0x83852d0f, 0x30362f1a, 0x7b5a9cc3, 0x31fec169,
    0x9fec022a, 0x6c8dedc4, 0x15d6874d, 0x5fde7a4e, 0xbad90e37,
    0x2e4e5eef, 0x4eaba214, 0xa8a472c0, 0x429a969e, 0x148d302a,
    0xc40ba6d0, 0xc4e22c3c};

// Return x^(n*2^k) modulo p(x).
// (matches pigz.c:1350-1361)
static crc_t x2nmodp(size_t n, unsigned k) {
    crc_t p = (crc_t)1 << 31;       // x^0 == 1
    while (n) {
        if (n & 1)
            p = multmodp(x2n_table[k & 31], p);
        n >>= 1;
        k++;
    }
    return p;
}

// This uses the pre-computed g.shift value most of the time. Only the last
// combination requires a new x2nmodp() calculation.
// (matches pigz.c:1363-1367)
static unsigned long crc32_comb_with_size(unsigned long crc1, unsigned long crc2,
                               size_t len2, size_t block_size) {
    return multmodp(len2 == block_size ? g.shift : x2nmodp(len2, 3), crc1) ^ crc2;
}

/* ============================================================================
 * Adler-32 Combination (matches pigz.c:1403-1421)
 * ============================================================================ */

#define ADLER_BASE 65521U
#define LOW16 0xffff

static unsigned long adler32_comb(unsigned long adler1, unsigned long adler2, size_t len2) {
    unsigned long sum1;
    unsigned long sum2;
    unsigned rem;

    rem = (unsigned)(len2 % ADLER_BASE);
    sum1 = adler1 & LOW16;
    sum2 = (rem * sum1) % ADLER_BASE;
    sum1 += (adler2 & LOW16) + ADLER_BASE - 1;
    sum2 += ((adler1 >> 16) & LOW16) + ((adler2 >> 16) & LOW16) + ADLER_BASE - rem;
    if (sum1 >= ADLER_BASE) sum1 -= ADLER_BASE;
    if (sum1 >= ADLER_BASE) sum1 -= ADLER_BASE;
    if (sum2 >= (ADLER_BASE << 1)) sum2 -= (ADLER_BASE << 1);
    if (sum2 >= ADLER_BASE) sum2 -= ADLER_BASE;
    return sum1 | (sum2 << 16);
}

/* ============================================================================
 * Compression Worker
 * ============================================================================ */

/*
 * Compress a single block using a provided z_stream.
 * Returns a CompressedResult*!>(CCIoError) to demonstrate idiomatic error propagation.
 * (matches pigz.c:2310-2350)
 * 
 * Uses @arena block with cc_arena_detach() for clean ownership transfer:
 * - On error: @arena cleanup frees the memory
 * - On success: arena_detach() transfers ownership, cleanup is no-op
 */
CompressedResult* !> (CCIoError) compress_block(z_stream* strm, Block* blk, CCSlice dict, int level, int strategy) {
    // Arena sizing: CompressedResult struct + deflate output
    // Deflate worst case is ~0.03% expansion + 11 bytes; we allow 12.5% + 8KB for safety
    size_t arena_size = blk->data.len + (blk->data.len >> 3) + 8192;
    
    @arena(res_arena, arena_size) {
        CompressedResult* res = arena_alloc1(CompressedResult, res_arena);
        if (!res) return cc_err(CC_IO_OUT_OF_MEMORY);
        
        res->seq = blk->seq;
        res->is_last = blk->is_last;
        res->original_len = blk->data.len;

        // Stage 1: Setup & Checksum (matches pigz.c:2323-2324)
        if (g.form == 0) {
            res->crc = crc32(0UL, (const Bytef*)blk->data.ptr, (uInt)blk->data.len);
        } else {
            res->crc = adler32(1UL, (const Bytef*)blk->data.ptr, (uInt)blk->data.len);
        }

        if (level <= 9) {
            (void)deflateReset(strm);
            (void)deflateParams(strm, level, strategy);

            // Stage 2: Output Buffer Allocation
            // Use deflateBound to ensure we have enough space for the compressed data
            // For rsyncable, we might have many sync markers which add overhead (~5 bytes each)
            size_t max_out = deflateBound(strm, (uLong)blk->data.len) + 128;
            if (blk->lens.len > 0) {
                max_out += (blk->lens.len / sizeof(size_t)) * 10; // Extra space for sync markers
            }
            unsigned char* out_buf = arena_alloc(unsigned char, res_arena, max_out);
            if (!out_buf) return cc_err(CC_IO_OUT_OF_MEMORY);

            size_t pos = 0;

            // Stage 3: Dictionary Loading (matches pigz.c:2330-2335)
            if (dict.len > 0) {
                deflateSetDictionary(strm, (const Bytef*)dict.ptr, (uInt)dict.len);
            }
            
            strm->next_in = (Bytef*)blk->data.ptr;
            strm->avail_in = (uInt)blk->data.len;
            strm->next_out = out_buf + pos;
            strm->avail_out = (uInt)(max_out - pos);
            
            int ret;
            // Stage 4: Deflate Loop (matches pigz.c:2340-2350)
            if (blk->lens.len == 0) {
                // Standard single-segment block
                while (strm->avail_in > 0) {
                    ret = deflate(strm, Z_NO_FLUSH);
                    if (ret != Z_OK) break;
                    if (strm->avail_out == 0) { ret = Z_BUF_ERROR; break; }
                }
            } else {
                // Rsyncable multi-segment block (matches pigz.c:1787-1856)
                size_t* lens = (size_t*)blk->lens.ptr;
                size_t n_lens = blk->lens.len / sizeof(size_t);
                size_t total_in = 0;
                ret = Z_OK;
                
                for (size_t i = 0; i < n_lens; i++) {
                    size_t segment_len = lens[i];
                    if (segment_len == 0) segment_len = blk->data.len - total_in;
                    
                    strm->avail_in = (uInt)segment_len;
                    // next_in is already set correctly at the start or by previous deflate calls
                    total_in += segment_len;
                    
                    // Deflate segment
                    while (strm->avail_in > 0) {
                        ret = deflate(strm, Z_NO_FLUSH);
                        if (ret != Z_OK) break;
                        if (strm->avail_out == 0) { ret = Z_BUF_ERROR; break; }
                    }
                    if (ret != Z_OK) break;
                    
                    // Flush at rsync boundary (unless it's the very end of the last block)
                    if (total_in < blk->data.len || !blk->is_last) {
#if ZLIB_VERNUM >= 0x1260
                        int setdict = (dict.len > 0 || i > 0);
                        ret = deflate(strm, Z_BLOCK);
                        if (ret == Z_OK) {
                            int bits = 0;
                            (void)deflatePending(strm, Z_NULL, &bits);
                            if ((bits & 1) || !setdict) {
                                ret = deflate(strm, Z_SYNC_FLUSH);
                            } else if (bits & 7) {
                                do {
                                    ret = deflatePrime(strm, 10, 2);
                                    if (ret != Z_OK) break;
                                    (void)deflatePending(strm, Z_NULL, &bits);
                                } while (bits & 7);
                                if (ret == Z_OK) ret = deflate(strm, Z_BLOCK);
                            }
                        }
#else
                        ret = deflate(strm, Z_SYNC_FLUSH);
#endif
                        if (ret != Z_OK) break;
                    }
                }
            }

            // Stage 5: Block Boundary Alignment (matches pigz.c:1990-2010)
            // (Only needed if not already handled by the rsyncable loop)
            if (ret == Z_OK && blk->lens.len == 0) {
                if (blk->is_last) {
                    // Finish the stream on the last block.
                    do {
                        ret = deflate(strm, Z_FINISH);
                        if (ret != Z_OK && ret != Z_STREAM_END) break;
                        if (strm->avail_out == 0) { ret = Z_BUF_ERROR; break; }
                    } while (ret != Z_STREAM_END);
                } else {
#if ZLIB_VERNUM >= 0x1260
                    int setdict = (dict.len > 0);
                    // Align to byte boundary without finishing the stream
                    ret = deflate(strm, Z_BLOCK);
                    if (ret == Z_OK) {
                        int bits = 0;
                        (void)deflatePending(strm, Z_NULL, &bits);
                        if ((bits & 1) || !setdict) {
                            ret = deflate(strm, Z_SYNC_FLUSH);
                        } else if (bits & 7) {
                            do {
                                ret = deflatePrime(strm, 10, 2);
                                if (ret != Z_OK) break;
                                (void)deflatePending(strm, Z_NULL, &bits);
                            } while (bits & 7);
                            if (ret == Z_OK) ret = deflate(strm, Z_BLOCK);
                        }
                    }
#else
                    ret = deflate(strm, Z_SYNC_FLUSH);
                    int setdict = 0;
#endif
                    if (ret == Z_OK && !setdict) {
                        // For independent blocks, add a full flush marker.
                        ret = deflate(strm, Z_FULL_FLUSH);
                    }
                }
            } else if (ret == Z_OK && blk->lens.len > 0 && blk->is_last) {
                // Final finish for rsyncable last block
                do {
                    ret = deflate(strm, Z_FINISH);
                    if (ret != Z_OK && ret != Z_STREAM_END) break;
                    if (strm->avail_out == 0) { ret = Z_BUF_ERROR; break; }
                } while (ret != Z_STREAM_END);
            }
                
            // Stage 6: Finalize Result
            size_t deflate_len = strm->total_out;
            if (ret != (blk->is_last ? Z_STREAM_END : Z_OK)) {
                return cc_err(CC_IO_OTHER);
            }
            
            pos += deflate_len;
            res->data = cc_slice_from_parts(out_buf, pos, CC_SLICE_ID_UNTRACKED, pos);
            cc_atomic_fetch_add(&g_bytes_out, pos);
        } else {
            // Zopfli compression (level 11)
            unsigned char* out = NULL;
            size_t outsize = 0;
            
            // Zopfli only supports raw deflate for parts, we'll need to wrap it ourselves
            // or use ZopfliCompress for the whole block. pigz.c uses ZopfliDeflatePart.
            // For simplicity in this first pass, we use ZopfliCompress which handles the format.
            ZopfliFormat format = ZOPFLI_FORMAT_DEFLATE; // We want raw deflate to match our manual header/trailer
            
            ZopfliCompress(&g.zopts, format, (const unsigned char*)blk->data.ptr, blk->data.len, &out, &outsize);
            
            if (!out) return cc_err(CC_IO_OTHER);
            
            // Copy Zopfli output to arena
            unsigned char* out_buf = arena_alloc(unsigned char, res_arena, outsize);
            if (!out_buf) {
                free(out);
                return cc_err(CC_IO_OUT_OF_MEMORY);
            }
            memcpy(out_buf, out, outsize);
            free(out);
            
            res->data = cc_slice_from_parts(out_buf, outsize, CC_SLICE_ID_UNTRACKED, outsize);
            cc_atomic_fetch_add(&g_bytes_out, outsize);
        }

        // Update global statistics
        cc_atomic_fetch_add(&g_bytes_in, blk->data.len);
        cc_atomic_fetch_add(&g_blocks_done, 1);

        // Transfer arena ownership: detach empties res_arena, so block cleanup is no-op
        res->arena = cc_arena_detach(res_arena);
        
        return cc_ok(res);
    }
}

/* ============================================================================
 * Decompression Engine (matches pigz.c:2700-2750)
 * ============================================================================ */

DecompressedResult* !> (CCIoError) decompress_block(CCSlice member, long seq) {
    // Initial estimate for decompressed size (gzip members are usually 128KB)
    size_t est_size = 256 * 1024;
    @arena(res_arena, est_size + 8192) {
        DecompressedResult* res = arena_alloc1(DecompressedResult, res_arena);
        if (!res) return cc_err(CC_IO_OUT_OF_MEMORY);
        res->seq = seq;

        z_stream strm;
        memset(&strm, 0, sizeof(strm));
        // 15 + 16 for gzip decoding
        if (inflateInit2(&strm, 15 + 16) != Z_OK) return cc_err(CC_IO_OTHER);
        @defer inflateEnd(&strm);

        strm.next_in = (Bytef*)member.ptr;
        strm.avail_in = (uInt)member.len;

        // Allocate output buffer
        unsigned char* out_buf = arena_alloc(unsigned char, res_arena, est_size);
        if (!out_buf) return cc_err(CC_IO_OUT_OF_MEMORY);

        strm.next_out = out_buf;
        strm.avail_out = (uInt)est_size;

        int ret = inflate(&strm, Z_FINISH);
        if (ret != Z_STREAM_END && ret != Z_OK) {
            return cc_err(CC_IO_OTHER);
        }

        size_t actual_size = strm.total_out;
        res->data = cc_slice_from_parts(out_buf, actual_size, CC_SLICE_ID_UNTRACKED, est_size);
        res->arena = cc_arena_detach(res_arena);
        return cc_ok(res);
    }
}

int decompress_file(const char* in_path, const char* out_path, int num_workers) {
    CCFile in_file = {0};
    const char* real_in = in_path ? in_path : "/dev/stdin";
    if (cc_file_open(&in_file, real_in, "rb") != 0) {
        fprintf(stderr, "Failed to open input: %s\n", real_in);
        return 1;
    }
    @defer cc_file_close(&in_file);

    CCFile out_file = {0};
    const char* real_out_path = out_path;
    char real_out_buf[4096];
    if (strcmp(out_path, "/dev/stdout") == 0) {
        real_out_path = "/dev/stdout";
    } else {
        // Remove .gz suffix for output name if it exists
        strncpy(real_out_buf, out_path, sizeof(real_out_buf));
        size_t len = strlen(real_out_buf);
        if (len > 3 && strcmp(real_out_buf + len - 3, ".gz") == 0) {
            real_out_buf[len - 3] = '\0';
        }
        real_out_path = real_out_buf;
    }
    
    if (cc_file_open(&out_file, real_out_path, "wb") != 0) {
        fprintf(stderr, "Failed to open output: %s\n", real_out_path);
        return 1;
    }
    @defer cc_file_close(&out_file);

    CCFile* out_ptr = &out_file;
    CCFile* in_ptr = &in_file;

    MemberJob*[~64 >] members_tx;
    MemberJob*[~64 <] members_rx;
    DecompressedResult*[~64 >] results_tx;
    DecompressedResult*[~64 <] results_rx;

    CCChan* members_ch = channel_pair(&members_tx, &members_rx);
    CCChan* results_ch = channel_pair(&results_tx, &results_rx);
    @defer cc_chan_free(members_ch);
    @defer cc_chan_free(results_ch);

    @nursery {
        /* Writer Task */
        spawn([out_ptr, results_rx]() => {
            long next_seq = 0;
            DecompressedResult* pending[REORDER_CAP];
            memset(pending, 0, sizeof(pending));
            
            DecompressedResult* r;
            while (chan_recv(results_rx, &r) == 0) {
                pending[r->seq % REORDER_CAP] = r;
                while (pending[next_seq % REORDER_CAP]) {
                    r = pending[next_seq % REORDER_CAP];
                    pending[next_seq % REORDER_CAP] = NULL;
                    (void)cc_file_write(out_ptr, r->data);
                    cc_heap_arena_free(&r->arena);
                    next_seq++;
                }
            }
        });

        @nursery closing(results_tx) {
            /* Workers */
            for (int i = 0; i < num_workers; i++) {
                spawn([members_rx, results_tx]() => {
                    MemberJob* job;
                    while (chan_recv(members_rx, &job) == 0) {
                        DecompressedResult* !> (CCIoError) res_val = decompress_block(job->member, job->seq);
                        if (cc_is_ok(res_val)) {
                            chan_send(results_tx, cc_unwrap(res_val));
                        }
                        cc_heap_arena_free(&job->arena);
                    }
                });
            }

            /* Reader Task - Serial Member Identification */
            @nursery closing(members_tx) {
                spawn([in_ptr, members_tx]() => {
                    long seq = 0;
                    while (true) {
                        CCArena job_arena = cc_heap_arena(BLOCK_SIZE + 1024);
                        CCSlice !> (CCIoError) res = cc_file_read(in_ptr, &job_arena, BLOCK_SIZE);
                        if (cc_is_err(res)) { cc_heap_arena_free(&job_arena); break; }
                        CCSlice data = cc_unwrap_as(res, CCSlice);
                        if (data.len == 0) { cc_heap_arena_free(&job_arena); break; }

                        MemberJob* job = arena_alloc1(MemberJob, &job_arena);
                        if (!job) { cc_heap_arena_free(&job_arena); break; }
                        job->seq = seq++;
                        job->member = data;
                        job->arena = job_arena;
                        chan_send(members_tx, job);
                    }
                });
            }
        }
    }

    return 0;
}

/* ============================================================================
 * Main Compression Pipeline (matches pigz.c:3400-3500)
 * ============================================================================ */

/* Forward declarations */
int process_path(const char* path, int num_workers, int level, int strategy);

int compress_file(const char* in_path, const char* out_path, int num_workers, int level, int strategy) {
    // Open input file
    CCFile in_file = {0};
    const char* real_in = in_path ? in_path : "/dev/stdin";
    if (cc_file_open(&in_file, real_in, "rb") != 0) {
        fprintf(stderr, "Failed to open input: %s\n", real_in);
        return 1;
    }
    @defer cc_file_close(&in_file);

    // Open output file
    CCFile out_file = {0};
    if (cc_file_open(&out_file, out_path, "wb") != 0) {
        fprintf(stderr, "Failed to open output: %s\n", out_path);
        return 1;
    }
    @defer cc_file_close(&out_file);

    // Reset error flag
    cc_atomic_store(&g_pipeline_error, 0);

    // Initialize CRC combination globals (matches pigz.c:3400-3410)
    size_t block_size = BLOCK_SIZE;
    g.block = block_size;
    g.shift = x2nmodp(g.block, 3);
    
    // Channels for pipeline (capacity matches REORDER_CAP calculation)
    Block*[~64 >] blocks_tx;
    Block*[~64 <] blocks_rx;
    CompressedResult*[~64 >] results_tx;
    CompressedResult*[~64 <] results_rx;

    CCChan* blocks_ch = channel_pair(&blocks_tx, &blocks_rx);
    CCChan* results_ch = channel_pair(&results_tx, &results_rx);
    @defer cc_chan_free(blocks_ch);
    @defer cc_chan_free(results_ch);

    // Pointers for closure capture
    CCFile* in_ptr = &in_file;
    CCFile* out_ptr = &out_file;

    @nursery {
        /* Writer Task - must write blocks in sequence order */
        spawn([out_ptr, block_size]() => {
            long next_seq = 0;
            CompressedResult* pending[REORDER_CAP];
            memset(pending, 0, sizeof(pending));
            bool write_failed = false;

            unsigned long global_crc = (g.form == 0 ? 0UL : 1UL);
            size_t total_len = 0;
            bool first_block = true;
            
            // Write gzip/zlib header once at the beginning
            if (g.form == 0) {
                // gzip header (matches pigz.c:1166-1175)
                unsigned char header[10] = {
                    0x1f, 0x8b,  // Magic
                    0x08,        // Deflate method
                    (unsigned char)((g.name != NULL ? 8 : 0) + (g.comment != NULL ? 16 : 0)), // Flags
                    (unsigned char)(g.mtime & 0xff),
                    (unsigned char)((g.mtime >> 8) & 0xff),
                    (unsigned char)((g.mtime >> 16) & 0xff),
                    (unsigned char)((g.mtime >> 24) & 0xff),
                    (unsigned char)(level >= 9 ? 2 : level == 1 ? 4 : 0), // Extra flags
                    0x03         // OS = Unix
                };
                size_t !> (CCIoError) hdr_wr = cc_file_write(out_ptr, cc_slice_from_parts(header, 10, CC_SLICE_ID_UNTRACKED, 10));
                if (cc_is_err(hdr_wr)) {
                    fprintf(stderr, "Error: failed to write gzip header\n");
                    cc_atomic_store(&g_pipeline_error, 1);
                    write_failed = true;
                }
                
                // Write filename if present (matches pigz.c:1176-1177)
                if (!write_failed && g.name != NULL) {
                    size_t nlen = strlen(g.name) + 1;
                    size_t !> (CCIoError) name_wr = cc_file_write(out_ptr, cc_slice_from_parts(g.name, nlen, CC_SLICE_ID_UNTRACKED, nlen));
                    if (cc_is_err(name_wr)) {
                        fprintf(stderr, "Error: failed to write filename to header\n");
                        cc_atomic_store(&g_pipeline_error, 1);
                        write_failed = true;
                    }
                }
                
                // Write comment if present (matches pigz.c:1178-1179)
                if (!write_failed && g.comment != NULL) {
                    size_t clen = strlen(g.comment) + 1;
                    size_t !> (CCIoError) comm_wr = cc_file_write(out_ptr, cc_slice_from_parts(g.comment, clen, CC_SLICE_ID_UNTRACKED, clen));
                    if (cc_is_err(comm_wr)) {
                        fprintf(stderr, "Error: failed to write comment to header\n");
                        cc_atomic_store(&g_pipeline_error, 1);
                        write_failed = true;
                    }
                }
            } else {
                // zlib header (matches pigz.c:1154-1163)
                unsigned head = (0x78 << 8) +
                               (level >= 9 ? 3 << 6 :
                                level == 1 ? 0 << 6 :
                                level >= 6 ? 1 << 6 :
                                2 << 6);
                head += 31 - (head % 31);
                unsigned char header[2];
                header[0] = (head >> 8) & 0xff;
                header[1] = head & 0xff;
                size_t !> (CCIoError) hdr_wr = cc_file_write(out_ptr, cc_slice_from_parts(header, 2, CC_SLICE_ID_UNTRACKED, 2));
                if (cc_is_err(hdr_wr)) {
                    fprintf(stderr, "Error: failed to write zlib header\n");
                    cc_atomic_store(&g_pipeline_error, 1);
                    write_failed = true;
                }
            }
            
            CompressedResult* r;
            while (!write_failed && chan_recv(results_rx, &r) == 0) {
                // Insert using modular indexing
                size_t slot = (size_t)(r->seq % REORDER_CAP);
                
                // Collision is a logic bug in pipeline sizing - abort immediately
                if (pending[slot] != NULL) {
                    fprintf(stderr, "FATAL: Reorder buffer collision at seq %ld (slot %zu holds seq %ld)\n", 
                            r->seq, slot, pending[slot]->seq);
                    fprintf(stderr, "This indicates REORDER_CAP (%d) is too small for the pipeline.\n", REORDER_CAP);
                    abort();
                }
                pending[slot] = r;
                
                // Drain all consecutive blocks starting from next_seq
                while (!write_failed && pending[next_seq % REORDER_CAP] != NULL) {
                    slot = (size_t)(next_seq % REORDER_CAP);
                    r = pending[slot];
                    pending[slot] = NULL;
                    
                    // Accumulate global checksum and total length
                    if (first_block) {
                        global_crc = r->crc;
                        first_block = false;
                    } else {
                        if (g.form == 0) {
                            global_crc = crc32_comb_with_size(global_crc, r->crc, r->original_len, block_size);
                        } else {
                            global_crc = adler32_comb(global_crc, r->crc, r->original_len);
                        }
                    }
                    total_len += r->original_len;

                    // Use Result-based I/O for writing data
                    size_t !> (CCIoError) wr = cc_file_write(out_ptr, r->data);
                    if (cc_is_ok(wr)) {
                        // Block written successfully
                    } else {
                        fprintf(stderr, "Error: write failed at block %ld\n", r->seq);
                        cc_atomic_store(&g_pipeline_error, 1);
                        write_failed = true;
                    }
                    
                    cc_heap_arena_free(&r->arena);
                    next_seq++;
                }
            }

            // Write gzip/zlib trailer
            if (!write_failed) {
                if (g.form == 0) {
                    // gzip trailer: CRC32 (4 bytes) + original size mod 2^32 (4 bytes)
                    unsigned char trailer[8];
                    trailer[0] = global_crc & 0xff;
                    trailer[1] = (global_crc >> 8) & 0xff;
                    trailer[2] = (global_crc >> 16) & 0xff;
                    trailer[3] = (global_crc >> 24) & 0xff;
                    trailer[4] = total_len & 0xff;
                    trailer[5] = (total_len >> 8) & 0xff;
                    trailer[6] = (total_len >> 16) & 0xff;
                    trailer[7] = (total_len >> 24) & 0xff;
                    
                    size_t !> (CCIoError) tr_wr = cc_file_write(out_ptr, cc_slice_from_parts(trailer, 8, CC_SLICE_ID_UNTRACKED, 8));
                    if (cc_is_err(tr_wr)) {
                        fprintf(stderr, "Error: failed to write gzip trailer\n");
                        cc_atomic_store(&g_pipeline_error, 1);
                    }
                } else {
                    // zlib trailer: Adler-32 (4 bytes)
                    unsigned char trailer[4];
                    trailer[0] = (global_crc >> 24) & 0xff;
                    trailer[1] = (global_crc >> 16) & 0xff;
                    trailer[2] = (global_crc >> 8) & 0xff;
                    trailer[3] = global_crc & 0xff;
                    size_t !> (CCIoError) tr_wr = cc_file_write(out_ptr, cc_slice_from_parts(trailer, 4, CC_SLICE_ID_UNTRACKED, 4));
                    if (cc_is_err(tr_wr)) {
                        fprintf(stderr, "Error: failed to write zlib trailer\n");
                        cc_atomic_store(&g_pipeline_error, 1);
                    }
                }
            }

            // Cleanup any remaining pending blocks
            for (int i = 0; i < REORDER_CAP; i++) {
                if (pending[i]) cc_heap_arena_free(&pending[i]->arena);
            }
        });

        @nursery closing(results_tx) {
            /* Compression Workers */
            for (int w = 0; w < num_workers; w++) {
                spawn([level, strategy, results_tx, blocks_rx]() => {
                    // Initialize z_stream once per worker (matches pigz.c:2310-2320)
                    z_stream strm;
                    memset(&strm, 0, sizeof(strm));
                    if (level <= 9) {
                        int ret = deflateInit2(&strm, level, Z_DEFLATED, -15, 8, strategy);
                        if (ret != Z_OK) {
                            fprintf(stderr, "Worker failed to initialize zlib\n");
                            cc_atomic_store(&g_pipeline_error, 1);
                        } else {
                            Block* blk;
                            while (chan_recv(blocks_rx, &blk) == 0) {
                                // Check if pipeline is shutting down due to error
                                if (cc_atomic_load(&g_pipeline_error)) {
                                    cc_heap_arena_free(&blk->arena);
                                    continue;  // Drain channel but don't process
                                }
                                
                                // Compress and send result; on error, log and continue
                                CompressedResult* !> (CCIoError) res_val = compress_block(&strm, blk, blk->dict, level, strategy);
                                if (cc_is_ok(res_val)) {
                                    chan_send(results_tx, cc_unwrap(res_val));
                                } else {
                                    // Error is either OUT_OF_MEMORY or OTHER (zlib failure)
                                    fprintf(stderr, "Compression error (seq=%ld)\n", blk->seq);
                                }
                                
                                // Free input block arena
                                cc_heap_arena_free(&blk->arena);
                            }
                            deflateEnd(&strm);
                        }
                    } else {
                        Block* blk;
                        while (chan_recv(blocks_rx, &blk) == 0) {
                            // Check if pipeline is shutting down due to error
                            if (cc_atomic_load(&g_pipeline_error)) {
                                cc_heap_arena_free(&blk->arena);
                                continue;  // Drain channel but don't process
                            }
                            
                            // Compress and send result; on error, log and continue
                            CompressedResult* !> (CCIoError) res_val = compress_block(&strm, blk, blk->dict, level, strategy);
                            if (cc_is_ok(res_val)) {
                                chan_send(results_tx, cc_unwrap(res_val));
                            } else {
                                // Error is either OUT_OF_MEMORY or OTHER (zlib failure)
                                CCIoError err = cc_unwrap_err_as(res_val, CCIoError);
                                fprintf(stderr, "Compression error (seq=%ld, kind=%d, os_code=%d)\n", blk->seq, err.kind, err.os_code);
                            }
                            
                            // Free input block arena
                            cc_heap_arena_free(&blk->arena);
                        }
                    }
                });
            }

            /* Reader Task */
            @nursery closing(blocks_tx) {
                spawn([in_ptr, blocks_tx]() => {
                    long seq = 0;
                    bool hit_eof = false;
                    Block* prev_blk = NULL;
                    unsigned long rolling_hash = 2047; // RSYNCHIT
                    
                    // Maintain a buffer for the last_tail (32KB)
                    unsigned char last_tail_buf[32768];
                    size_t last_tail_len = 0;
                    
                    while (!hit_eof) {
                        // Check if pipeline is shutting down due to error
                        if (cc_atomic_load(&g_pipeline_error)) break;
                        
                        // Arena needs space for data, Block struct, dictionary copy, and rsync hits
                        CCArena blk_arena = cc_heap_arena(BLOCK_SIZE + BLOCK_ARENA_OVERHEAD + 65536 + (BLOCK_SIZE / 5 * sizeof(size_t)));
                        
                        // Read returns Ok(slice) or Err; empty slice on EOF
                        CCSlice !> (CCIoError) read_res = cc_file_read(in_ptr, &blk_arena, BLOCK_SIZE);
                        if (cc_is_err(read_res)) {
                            fprintf(stderr, "Read error\n");
                            cc_atomic_store(&g_pipeline_error, 1);
                            cc_heap_arena_free(&blk_arena);
                            break;
                        }
                        CCSlice data = cc_unwrap_as(read_res, CCSlice);

                        if (data.len == 0) {
                            cc_heap_arena_free(&blk_arena);
                            if (prev_blk) {
                                prev_blk->is_last = true;
                                chan_send(blocks_tx, prev_blk);
                                prev_blk = NULL;
                            }
                            break;  // EOF with no data
                        }
                        
                        // Block struct also lives in the arena
                        Block* blk = arena_alloc1(Block, &blk_arena);
                        if (!blk) {
                            cc_atomic_store(&g_pipeline_error, 1);
                            cc_heap_arena_free(&blk_arena);
                            break;
                        }
                        
                        blk->seq = seq++;
                        blk->data = data;
                        blk->dict = (CCSlice){0};
                        blk->lens = (CCSlice){0};
                        blk->is_last = false;  // set later once we know if this is last
                        blk->arena = blk_arena;  // Transfer ownership to Block
                        
                        // Rsyncable Logic: Find hits and fill blk->lens
                        if (g.rsync) {
                            // Max hits in a block: BLOCK_SIZE / 5 (shortest possible block is 5 bytes)
                            size_t max_hits = BLOCK_SIZE / 5;
                            size_t* hits = arena_alloc(size_t, &blk_arena, max_hits);
                            if (!hits) {
                                fprintf(stderr, "Failed to allocate hits array\n");
                                cc_atomic_store(&g_pipeline_error, 1);
                                cc_heap_arena_free(&blk_arena);
                                break;
                            }
                            size_t n_hits = 0;
                            
                            const unsigned char* p = (const unsigned char*)data.ptr;
                            size_t last_hit_pos = 0;
                            for (size_t i = 0; i < data.len; i++) {
                                rolling_hash = ((rolling_hash << 1) ^ p[i]) & 0xFFF; // RSYNCMASK
                                if (rolling_hash == 2047) { // RSYNCHIT
                                    if (n_hits < max_hits) {
                                        hits[n_hits++] = (i + 1) - last_hit_pos;
                                        last_hit_pos = i + 1;
                                    }
                                }
                            }
                            if (n_hits > 0) {
                                // If there's data left after the last hit, add it as a final segment
                                if (last_hit_pos < data.len) {
                                    if (n_hits < max_hits) {
                                        hits[n_hits++] = data.len - last_hit_pos;
                                    }
                                }
                                blk->lens = cc_slice_from_parts(hits, n_hits * sizeof(size_t), CC_SLICE_ID_UNTRACKED, n_hits * sizeof(size_t));
                            }
                        }

                        // Dictionary Chaining: Copying Strategy
                        if (last_tail_len > 0) {
                            unsigned char* dict_mem = arena_alloc(unsigned char, &blk_arena, last_tail_len);
                            if (!dict_mem) {
                                cc_atomic_store(&g_pipeline_error, 1);
                                cc_heap_arena_free(&blk_arena);
                                break;
                            }
                            memcpy(dict_mem, last_tail_buf, last_tail_len);
                            blk->dict = cc_slice_from_parts(dict_mem, last_tail_len, CC_SLICE_ID_UNTRACKED, last_tail_len);
                        }
                        
                        // Update last_tail for the next block
                        size_t tail_len = data.len > 32768 ? 32768 : data.len;
                        memcpy(last_tail_buf, (const unsigned char*)data.ptr + data.len - tail_len, tail_len);
                        last_tail_len = tail_len;

                        // If we already have a pending block, send it now.
                        if (prev_blk) {
                            chan_send(blocks_tx, prev_blk);
                        }

                        // If this was a short read, it's the last block.
                        if (data.len < BLOCK_SIZE) {
                            blk->is_last = true;
                            chan_send(blocks_tx, blk);
                            prev_blk = NULL;
                            hit_eof = true;
                            break;
                        }

                        // Otherwise, hold this block until we read the next one
                        prev_blk = blk;
                    }
                });
            }
        }
    }

    cc_file_sync(&out_file);
    
    // Check if pipeline encountered an error
    if (cc_atomic_load(&g_pipeline_error)) {
        return 1;
    }
    return 0;
}

/* Process a single path (file or directory) recursively */
// (matches pigz.c:3800-3900)
int process_path(const char* path, int num_workers, int level, int strategy) {
    if (path == NULL) {
        /* Stdin - no stat needed */
        g.mtime = 0;
        g.name = g.alias;
        return compress_file(NULL, "/dev/stdout", num_workers, level, strategy);
    }

    struct stat st;
    if (stat(path, &st) != 0) {
        fprintf(stderr, "pigz_cc: %s: %s\n", path, strerror(errno));
        return 1;
    }

    if (S_ISDIR(st.st_mode)) {
        if (!g.recursive) {
            fprintf(stderr, "pigz_cc: %s is a directory -- ignored\n", path);
            return 0;
        }

        @arena(dir_arena, megabytes(1)) {
            CCDirIter* !> (CCIoError) iter_res = cc_dir_open(dir_arena, path);
            if (cc_is_ok(iter_res)) {
                CCDirIter* iter = cc_unwrap(iter_res);
                @defer cc_dir_close(iter);

                int ret = 0;
                while (true) {
                    CCDirEntry !> (CCIoError) entry_res = cc_dir_next(iter, dir_arena);
                    if (cc_is_err(entry_res)) {
                        // CCIoError is a struct, need _as variant
                        CCIoError err = cc_unwrap_err_as(entry_res, CCIoError);
                        if (err.kind == CC_IO_OTHER && err.os_code == 0) break; // EOF
                        fprintf(stderr, "pigz_cc: %s: error reading directory\n", path);
                        ret = 1;
                        break;
                    }

                    // CCDirEntry is a struct, need _as variant  
                    CCDirEntry entry = cc_unwrap_as(entry_res, CCDirEntry);
                    const char* name = (const char*)entry.name.ptr;
                    
                    // Skip . and ..
                    if (strcmp(name, ".") == 0 || strcmp(name, "..") == 0) continue;

                    // Join path
                    CCSlice path_slice = cc_slice_from_buffer((void*)path, strlen(path));
                    CCSlice full_path_slice = cc_path_join(dir_arena, path_slice, entry.name);
                    const char* full_path = (const char*)full_path_slice.ptr;

                    ret |= process_path(full_path, num_workers, level, strategy);
                }
                return ret;
            } else {
                fprintf(stderr, "pigz_cc: %s: failed to open directory\n", path);
                return 1;
            }
        }
    }

    /* It's a file - set metadata and build output name */
    g.mtime = (g.headis & 2) ? st.st_mtime : 0;
    g.name = (g.headis & 1) ? justname((char*)path) : NULL;

    char output_file[4096];
    if (g.to_stdout) {
        snprintf(output_file, sizeof(output_file), "/dev/stdout");
    } else if (g.decode) {
        // Decompression: remove suffix
        size_t len = strlen(path);
        size_t slen = strlen(g.sufx);
        if (len > slen && strcmp(path + len - slen, g.sufx) == 0) {
            strncpy(output_file, path, len - slen);
            output_file[len - slen] = '\0';
        } else {
            if (!g.force) {
                if (g.verbosity > 0) fprintf(stderr, "pigz_cc: %s does not have %s suffix -- skipped\n", path, g.sufx);
                return 0;
            }
            snprintf(output_file, sizeof(output_file), "%s.out", path);
        }
    } else {
        // Compression: add suffix
        size_t len = strlen(path);
        size_t slen = strlen(g.sufx);
        if (!g.force && len > slen && strcmp(path + len - slen, g.sufx) == 0) {
            if (g.verbosity > 0) fprintf(stderr, "pigz_cc: %s already has %s suffix -- skipped\n", path, g.sufx);
            return 0;
        }
        snprintf(output_file, sizeof(output_file), "%s%s", path, g.sufx);
    }

    int ret = g.decode ? decompress_file(path, output_file, num_workers)
                       : compress_file(path, output_file, num_workers, level, strategy);
    
    if (ret == 0 && !g.to_stdout) {
        copymeta(path, output_file);
        if (!g.keep) {
            unlink(path);
        }
    }
    
    return ret;
}

/* ============================================================================
 * Command Line Interface (matches pigz.c:4100-4600)
 * ============================================================================ */

void usage(const char *prog) {
    fprintf(stderr, "Usage: %s [options] [file]\n", prog);
    fprintf(stderr, "  -c, --stdout      Write to stdout\n");
    fprintf(stderr, "  -d, --decompress  Decompress\n");
    fprintf(stderr, "  -k, --keep        Keep original file\n");
    fprintf(stderr, "  -p, --processes N Use N compression threads (default: 4)\n");
    fprintf(stderr, "  -r, --recursive   Recursive directory processing\n");
    fprintf(stderr, "  -f, --force       Force overwrite\n");
    fprintf(stderr, "  -q, --quiet       Quiet mode\n");
    fprintf(stderr, "  -v, --verbose     Verbose mode\n");
    fprintf(stderr, "  -V, --version     Show version\n");
    fprintf(stderr, "  -S, --suffix .sss Use suffix .sss instead of .gz\n");
    fprintf(stderr, "  -z, --zlib        Compress to zlib format\n");
    fprintf(stderr, "  -i, --independent Independent blocks\n");
    fprintf(stderr, "  -1..-9            Compression level (default: 6)\n");
    fprintf(stderr, "  --fast, --best    Compression levels 1 and 9\n");
    fprintf(stderr, "  -H, --huffman     Huffman-only strategy\n");
    fprintf(stderr, "  -U, --rle         RLE strategy\n");
    fprintf(stderr, "  -h, --help        Show this help\n");
}

int main(int argc, char *argv[]) {
    // Default settings (matches pigz.c:4100-4150)
    g.to_stdout = 0;
    g.keep = 0;
    g.recursive = 0;
    g.force = 0;
    g.verbosity = 1;
    g.sync = 0;
    g.form = 0;
    g.sufx = ".gz";
    g.headis = 3;
    g.rsync = 0;
    g.decode = 0;
    g.name = NULL;
    g.alias = NULL;
    g.comment = NULL;
    g.mtime = 0;
    ZopfliInitOptions(&g.zopts);
    int num_workers = 4;
    int level = 6;
    int strategy = Z_DEFAULT_STRATEGY;
    
    /* Set up signal handling (matches pigz.c:4627) */
    signal(SIGINT, cut_short);
    signal(SIGTERM, cut_short);
    
    /* Parse arguments (matches pigz.c:4150-4600) */
    for (int i = 1; i < argc; i++) {
        if (argv[i][0] == '-') {
            if (strcmp(argv[i], "-c") == 0 || strcmp(argv[i], "--stdout") == 0 || strcmp(argv[i], "--to-stdout") == 0) {
                g.to_stdout = 1;
            } else if (strcmp(argv[i], "-d") == 0 || strcmp(argv[i], "--decompress") == 0 || strcmp(argv[i], "--uncompress") == 0) {
                g.decode = 1;
            } else if (strcmp(argv[i], "-k") == 0 || strcmp(argv[i], "--keep") == 0) {
                g.keep = 1;
            } else if (strcmp(argv[i], "-r") == 0 || strcmp(argv[i], "--recursive") == 0) {
                g.recursive = 1;
            } else if (strcmp(argv[i], "-R") == 0 || strcmp(argv[i], "--rsyncable") == 0) {
                g.rsync = 1;
            } else if (strcmp(argv[i], "-f") == 0 || strcmp(argv[i], "--force") == 0) {
                g.force = 1;
            } else if (strcmp(argv[i], "-q") == 0 || strcmp(argv[i], "--quiet") == 0 || strcmp(argv[i], "--silent") == 0) {
                g.verbosity = 0;
            } else if (strcmp(argv[i], "-v") == 0 || strcmp(argv[i], "--verbose") == 0) {
                g.verbosity++;
            } else if (strcmp(argv[i], "-V") == 0 || strcmp(argv[i], "--version") == 0) {
                fprintf(stderr, "pigz_cc 1.0\n");
                return 0;
            } else if (strcmp(argv[i], "-z") == 0 || strcmp(argv[i], "--zlib") == 0) {
                g.form = 1;
                g.sufx = ".zz";
            } else if (strcmp(argv[i], "-i") == 0 || strcmp(argv[i], "--independent") == 0) {
                // Already default
            } else if (strcmp(argv[i], "-Y") == 0 || strcmp(argv[i], "--synchronous") == 0) {
                g.sync = 1;
            } else if (strcmp(argv[i], "-H") == 0 || strcmp(argv[i], "--huffman") == 0) {
                strategy = Z_HUFFMAN_ONLY; // matches pigz.c:4280
            } else if (strcmp(argv[i], "-U") == 0 || strcmp(argv[i], "--rle") == 0) {
                strategy = Z_RLE; // matches pigz.c:4282
            } else if (strcmp(argv[i], "-C") == 0 || strcmp(argv[i], "--comment") == 0) {
                g.comment = (i + 1 < argc ? argv[++i] : NULL);
            } else if (strcmp(argv[i], "-A") == 0 || strcmp(argv[i], "--alias") == 0) {
                g.alias = (i + 1 < argc ? argv[++i] : NULL);
            } else if (strcmp(argv[i], "--fast") == 0) {
                level = 1;
            } else if (strcmp(argv[i], "--best") == 0) {
                level = 9;
            } else if (strcmp(argv[i], "-11") == 0) {
                level = 11;
            } else if (strcmp(argv[i], "-h") == 0 || strcmp(argv[i], "--help") == 0) {
                usage(argv[0]);
                return 0;
            } else if (strncmp(argv[i], "-p", 2) == 0 || strncmp(argv[i], "--processes", 11) == 0) {
                const char *val = (argv[i][1] == 'p' && argv[i][2]) ? &argv[i][2] : 
                                  (strncmp(argv[i], "--processes=", 13) == 0 ? &argv[i][13] :
                                  (i + 1 < argc ? argv[++i] : NULL));
                if (val) num_workers = atoi(val);
                if (num_workers < 1) num_workers = 1;
                if (num_workers > MAX_WORKERS) num_workers = MAX_WORKERS;
            } else if (strncmp(argv[i], "-S", 2) == 0 || strncmp(argv[i], "--suffix", 8) == 0) {
                const char *val = (argv[i][1] == 'S' && argv[i][2]) ? &argv[i][2] : 
                                  (strncmp(argv[i], "--suffix=", 9) == 0 ? &argv[i][9] :
                                  (i + 1 < argc ? argv[++i] : NULL));
                if (val) g.sufx = (char*)val;
            } else if (strncmp(argv[i], "-b", 2) == 0 || strncmp(argv[i], "--blocksize", 11) == 0) {
                const char *val = (argv[i][1] == 'b' && argv[i][2]) ? &argv[i][2] : 
                                  (strncmp(argv[i], "--blocksize=", 12) == 0 ? &argv[i][12] :
                                  (i + 1 < argc ? argv[++i] : NULL));
                if (val) {
                    // TODO: implement dynamic block size
                }
            } else if (argv[i][1] >= '0' && argv[i][1] <= '9' && argv[i][2] == '\0') {
                level = argv[i][1] - '0';
            } else {
                fprintf(stderr, "Unknown option: %s\n", argv[i]);
                usage(argv[0]);
                return 1;
            }
        }
    }
    
    if (argc < 2) {
        usage(argv[0]);
        return 1;
    }
    
    /* Process path recursively for each input file (matches pigz.c:4600-4620) */
    int ret = 0;
    bool had_input = false;
    for (int i = 1; i < argc; i++) {
        if (argv[i][0] == '-') {
            // Skip options (already parsed)
            if (strcmp(argv[i], "-p") == 0 || strcmp(argv[i], "--processes") == 0 ||
                strcmp(argv[i], "-S") == 0 || strcmp(argv[i], "--suffix") == 0 ||
                strcmp(argv[i], "-b") == 0 || strcmp(argv[i], "--blocksize") == 0 ||
                strcmp(argv[i], "-C") == 0 || strcmp(argv[i], "--comment") == 0 ||
                strcmp(argv[i], "-A") == 0 || strcmp(argv[i], "--alias") == 0) {
                i++;
            }
            continue;
        }
        had_input = true;
        if (strcmp(argv[i], "-") == 0) {
            g.to_stdout = 1;
            ret |= process_path(NULL, num_workers, level, strategy);
        } else {
            ret |= process_path(argv[i], num_workers, level, strategy);
        }
    }
    
    if (!had_input) {
        g.to_stdout = 1;
        ret = process_path(NULL, num_workers, level, strategy);
    }
    
    /* Print statistics */
    long bytes_in = cc_atomic_load(&g_bytes_in);
    long bytes_out = cc_atomic_load(&g_bytes_out);
    int blocks = cc_atomic_load(&g_blocks_done);
    if (g.verbosity > 0 && bytes_in > 0) {
        fprintf(stderr, "Total: %ld -> %ld bytes (%.1f%%), %d blocks, %d workers\n",
                bytes_in, bytes_out,
                100.0 * (1.0 - (double)bytes_out / bytes_in),
                blocks, num_workers);
    }
    
    return ret;
}

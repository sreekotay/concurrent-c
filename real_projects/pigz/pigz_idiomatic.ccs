/*
 * pigz_idiomatic.ccs -- Parallel gzip compression in IDIOMATIC Concurrent-C
 *
 * This version demonstrates:
 * - Result types (T!>(E)) for error propagation
 * - CCFile with Result-based I/O (cc_file_read, cc_file_write)
 * - @defer for guaranteed cleanup
 * - if @try for ergonomic error handling
 * - Arena-backed ownership transfer
 */

#include <ccc/std/prelude.cch>
#include <ccc/cc_atomic.cch>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <zlib.h>

/* ============================================================================
 * Configuration
 * ============================================================================ */

#define BLOCK_SIZE (128 * 1024)
#define MAX_WORKERS 16

/* ============================================================================
 * Data Types
 * ============================================================================ */

typedef struct {
    long seq;
    CCSlice data;
    int last;
    CCArena arena; // Owns the data
} Block;

typedef struct {
    long seq;
    CCSlice data;
    unsigned long crc;
    size_t ulen;
    int last;
    CCArena arena; // Owns the compressed data
} CompressedResult;

/* Global statistics */
cc_atomic_i64 g_bytes_in = 0;
cc_atomic_i64 g_bytes_out = 0;
cc_atomic_int g_blocks_done = 0;

/* ============================================================================
 * Compression Worker
 * ============================================================================ */

/*
 * Compress a single block. 
 * Returns a CompressedResult*!>(IoError) to demonstrate idiomatic error propagation.
 * 
 * Uses @arena block with cc_arena_detach() for clean ownership transfer:
 * - On error: @arena cleanup frees the memory
 * - On success: arena_detach() transfers ownership, cleanup is no-op
 */
CompressedResult*!>(CCIoError) compress_block(Block* blk, int level) {
    // Arena needs space for: CompressedResult struct + compressed output (up to ~112.5% of input + overhead)
    size_t arena_size = blk->data.len + (blk->data.len >> 3) + 8192;
    
    @arena(res_arena, arena_size) {
        CompressedResult* res = arena_alloc1(CompressedResult, res_arena);
        if (!res) return cc_err(CC_IO_OUT_OF_MEMORY);
        
        res->seq = blk->seq;
        res->last = blk->last;
        res->ulen = blk->data.len;

        // Calculate CRC using zlib directly
        res->crc = crc32(0UL, (const Bytef*)blk->data.ptr, (uInt)blk->data.len);

        // Allocate output buffer in the result arena
        size_t max_out = blk->data.len + (blk->data.len >> 3) + 256;
        unsigned char* out_buf = arena_alloc(unsigned char, res_arena, max_out);
        if (!out_buf) return cc_err(CC_IO_OUT_OF_MEMORY);

        // Write gzip header (10 bytes)
        unsigned char header[10] = {
            0x1f, 0x8b,  // Magic
            0x08,        // Deflate method
            0x00,        // Flags (none)
            0, 0, 0, 0,  // Mtime (not set)
            0x00,        // Extra flags
            0x03         // OS = Unix
        };
        memcpy(out_buf, header, 10);
        size_t pos = 10;

        // Compress with zlib (raw deflate, -15 window bits)
        z_stream strm;
        memset(&strm, 0, sizeof(strm));
        
        int ret = deflateInit2(&strm, level, Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY);
        if (ret != Z_OK) return cc_err(CC_IO_OTHER);
        
        strm.next_in = (Bytef*)blk->data.ptr;
        strm.avail_in = (uInt)blk->data.len;
        strm.next_out = out_buf + pos;
        strm.avail_out = (uInt)(max_out - pos - 8);  // Reserve space for trailer
        
        ret = deflate(&strm, Z_FINISH);
        size_t deflate_len = strm.total_out;
        deflateEnd(&strm);
        
        if (ret != Z_STREAM_END) {
            return cc_err(CC_IO_OTHER);
        }
        
        pos += deflate_len;
        
        // Write gzip trailer: CRC32 (4 bytes) + original size mod 2^32 (4 bytes)
        unsigned long crc = res->crc;
        size_t in_len = blk->data.len;
        out_buf[pos++] = crc & 0xff;
        out_buf[pos++] = (crc >> 8) & 0xff;
        out_buf[pos++] = (crc >> 16) & 0xff;
        out_buf[pos++] = (crc >> 24) & 0xff;
        out_buf[pos++] = in_len & 0xff;
        out_buf[pos++] = (in_len >> 8) & 0xff;
        out_buf[pos++] = (in_len >> 16) & 0xff;
        out_buf[pos++] = (in_len >> 24) & 0xff;

        res->data = cc_slice_from_parts(out_buf, pos, CC_SLICE_ID_UNTRACKED, pos);

        // Update statistics
        cc_atomic_fetch_add(&g_bytes_in, blk->data.len);
        cc_atomic_fetch_add(&g_bytes_out, pos);
        cc_atomic_fetch_add(&g_blocks_done, 1);

        // Transfer arena ownership: detach empties res_arena, so block cleanup is no-op
        res->arena = cc_arena_detach(res_arena);
        
        return cc_ok(res);
    }
    
    // Unreachable - all paths return from inside @arena block
    return cc_err(CC_IO_OTHER);
}

/* ============================================================================
 * Main Compression Pipeline
 * ============================================================================ */

int compress_file(const char* in_path, const char* out_path, int num_workers, int level) {
    // Open input file
    CCFile in_file;
    if (cc_file_open(&in_file, in_path, "rb") != 0) {
        fprintf(stderr, "Failed to open input: %s\n", in_path);
        return 1;
    }
    @defer cc_file_close(&in_file);

    // Open output file
    CCFile out_file;
    if (cc_file_open(&out_file, out_path, "wb") != 0) {
        fprintf(stderr, "Failed to open output: %s\n", out_path);
        return 1;
    }
    @defer cc_file_close(&out_file);

    // Channels for pipeline
    Block*[~64 >] blocks_tx;
    Block*[~64 <] blocks_rx;
    CompressedResult*[~64 >] results_tx;
    CompressedResult*[~64 <] results_rx;

    CCChan* blocks_ch = channel_pair(&blocks_tx, &blocks_rx);
    CCChan* results_ch = channel_pair(&results_tx, &results_rx);
    @defer cc_chan_free(blocks_ch);
    @defer cc_chan_free(results_ch);

    // Pointers for closure capture
    CCFile* in_ptr = &in_file;
    CCFile* out_ptr = &out_file;

    @nursery {
        /* Writer Task - must write blocks in sequence order */
        spawn([out_ptr]() => {
            long next_seq = 0;
            // Reorder buffer sized for max expected blocks (1024 > 800 blocks for 100MB)
            #define PENDING_CAP 1024
            CompressedResult* pending[PENDING_CAP];
            memset(pending, 0, sizeof(pending));
            
            CompressedResult* r;
            while (chan_recv(results_rx, &r) == 0) {
                // Insert using modular indexing
                size_t slot = (size_t)(r->seq % PENDING_CAP);
                if (pending[slot] != NULL) {
                    fprintf(stderr, "Error: reorder slot collision (seq=%ld, existing=%ld)\n", 
                            r->seq, pending[slot]->seq);
                    cc_heap_arena_free(&r->arena);
                    continue;
                }
                pending[slot] = r;
                
                // Drain all consecutive blocks starting from next_seq
                while (pending[next_seq % PENDING_CAP] != NULL) {
                    slot = (size_t)(next_seq % PENDING_CAP);
                    r = pending[slot];
                    pending[slot] = NULL;
                    
                    cc_file_write(out_ptr, r->data);
                    cc_heap_arena_free(&r->arena);
                    next_seq++;
                }
            }
            #undef PENDING_CAP
        });

        @nursery closing(results_tx) {
            /* Compression Workers */
            for (int w = 0; w < num_workers; w++) {
                spawn([level]() => {
                    Block* blk;
                    while (chan_recv(blocks_rx, &blk) == 0) {
                        // Compress and send result, log errors
                        if @try (CompressedResult* res = compress_block(blk, level)) {
                            chan_send(results_tx, res);
                        } else {
                            fprintf(stderr, "Worker compression error (seq=%ld)\n", blk->seq);
                        }
                        
                        // Cleanup input block (Block is inside its arena)
                        cc_heap_arena_free(&blk->arena);
                    }
                });
            }

            /* Reader Task */
            @nursery closing(blocks_tx) {
                spawn([in_ptr]() => {
                    long seq = 0;
                    while (1) {
                        CCArena blk_arena = cc_heap_arena(BLOCK_SIZE + 1024);
                        
                        // Read a block using CCFile - returns Ok(Some(slice)), Ok(None) on EOF, Err on error
                        CCResultOptSliceIoError read_res = cc_file_read(in_ptr, &blk_arena, BLOCK_SIZE);
                        if (read_res.is_err) {
                            cc_heap_arena_free(&blk_arena);
                            break;  // Read error
                        }
                        
                        CCOptional_CCSlice opt_data = read_res.ok;
                        if (!opt_data.has) {
                            cc_heap_arena_free(&blk_arena);
                            break;  // EOF
                        }
                        
                        CCSlice data = opt_data.u.value;
                        
                        // Block struct also in arena
                        Block* blk = arena_alloc1(Block, &blk_arena);
                        if (!blk) {
                            cc_heap_arena_free(&blk_arena);
                            break;
                        }
                        
                        blk->seq = seq++;
                        blk->data = data;
                        blk->last = (data.len < BLOCK_SIZE);
                        blk->arena = blk_arena;  // Transfer ownership
                        
                        chan_send(blocks_tx, blk);
                        if (blk->last) break;
                    }
                });
            }
        }
    }

    cc_file_sync(&out_file);
    return 0;
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <file>\n", argv[0]);
        return 1;
    }
    
    char out_name[4096];
    snprintf(out_name, sizeof(out_name), "%s.gz", argv[1]);
    
    int ret = compress_file(argv[1], out_name, 4, 6);
    
    if (ret == 0) {
        printf("Compressed %s to %s\n", argv[1], out_name);
        printf("Stats: %lld bytes in, %lld bytes out, %d blocks\n",
               (long long)cc_atomic_load(&g_bytes_in),
               (long long)cc_atomic_load(&g_bytes_out),
               cc_atomic_load(&g_blocks_done));
    }
    
    return ret;
}

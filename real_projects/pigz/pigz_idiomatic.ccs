/*
 * pigz_idiomatic.ccs -- Parallel gzip compression in IDIOMATIC Concurrent-C
 *
 * Demonstrates the chan_send_task pattern:
 * - chan_send_task(ch, () => expr) - spawn task, send handle
 * - chan_recv on ordered channels awaits task internally
 * - 'ordered' flag ensures FIFO result delivery
 *
 * Uses manual lowering until compiler support lands.
 * See spec-progress/language-patterns-v3.md Section 7.
 */

#include <ccc/std/prelude.cch>
#include <ccc/cc_atomic.cch>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <zlib.h>

#define BLOCK_SIZE (128 * 1024)
#define BLOCK_ARENA_OVERHEAD 1024
#define CHAN_CAP 16

typedef struct {
    long seq;
    CCSlice data;
    bool is_last;
    CCArena arena;
} Block;

typedef struct {
    long seq;
    CCSlice data;
    unsigned long crc;
    size_t original_len;
    bool is_last;
    CCArena arena;
} CompressedResult;

cc_atomic_i64 g_bytes_in = 0;
cc_atomic_i64 g_bytes_out = 0;
cc_atomic_int g_blocks_done = 0;

CompressedResult* !>(CCIoError) compress_block(Block* blk, int level) {
    size_t arena_size = blk->data.len + (blk->data.len >> 3) + 8192;
    
    @arena(res_arena, arena_size) {
        CompressedResult* res = arena_alloc1(CompressedResult, res_arena);
        if (!res) return cc_err(cc_io_error(CC_IO_OUT_OF_MEMORY));
        
        res->seq = blk->seq;
        res->is_last = blk->is_last;
        res->original_len = blk->data.len;
        res->crc = crc32(0UL, (const Bytef*)blk->data.ptr, (uInt)blk->data.len);

        size_t max_out = blk->data.len + (blk->data.len >> 3) + 256;
        unsigned char* out_buf = arena_alloc(unsigned char, res_arena, max_out);
        if (!out_buf) return cc_err(cc_io_error(CC_IO_OUT_OF_MEMORY));

        unsigned char header[10] = {0x1f, 0x8b, 0x08, 0x00, 0, 0, 0, 0, 0x00, 0x03};
        memcpy(out_buf, header, 10);
        size_t pos = 10;

        z_stream strm = {0};
        if (deflateInit2(&strm, level, Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY) != Z_OK) {
            return cc_err(cc_io_error(CC_IO_OTHER));
        }
        strm.next_in = (Bytef*)blk->data.ptr;
        strm.avail_in = (uInt)blk->data.len;
        strm.next_out = out_buf + pos;
        strm.avail_out = (uInt)(max_out - pos - 8);
        
        int ret = deflate(&strm, Z_FINISH);
        pos += strm.total_out;
        deflateEnd(&strm);
        
        if (ret != Z_STREAM_END) return cc_err(cc_io_error(CC_IO_OTHER));
        
        unsigned long crc = res->crc;
        size_t in_len = blk->data.len;
        out_buf[pos++] = crc & 0xff;
        out_buf[pos++] = (crc >> 8) & 0xff;
        out_buf[pos++] = (crc >> 16) & 0xff;
        out_buf[pos++] = (crc >> 24) & 0xff;
        out_buf[pos++] = in_len & 0xff;
        out_buf[pos++] = (in_len >> 8) & 0xff;
        out_buf[pos++] = (in_len >> 16) & 0xff;
        out_buf[pos++] = (in_len >> 24) & 0xff;

        res->data = cc_slice_from_parts(out_buf, pos, CC_SLICE_ID_UNTRACKED, pos);
        cc_atomic_fetch_add(&g_bytes_in, blk->data.len);
        cc_atomic_fetch_add(&g_bytes_out, pos);
        cc_atomic_fetch_add(&g_blocks_done, 1);

        res->arena = cc_arena_detach(res_arena);
        return cc_ok(res);
    }
}

// Task wrapper - stores result in fiber-local storage (what ordered_recv expects)
void* compress_task_wrapper(void* arg) {
    Block* blk = (Block*)arg;
    CompressedResult* !>(CCIoError) res = compress_block(blk, 6);
    cc_heap_arena_free(&blk->arena);
    
    // Store result in fiber-local storage at offset 0 (what ordered_recv expects)
    typedef struct { CompressedResult* __result; } __result_t;
    __result_t* storage = (__result_t*)cc_task_result_ptr(sizeof(__result_t));
    if (!storage) return NULL;
    
    storage->__result = cc_is_err(res) ? NULL : cc_unwrap_as(res, CompressedResult*);
    return storage;
}

/*
 * IDEAL SYNTAX (what we want):
 *   CompressedResult*[~16 ordered] results;
 *   chan_send_task(results, () => [blk] compress_block(blk, 6));
 *   while (chan_recv(results, &r)) { use(r); }
 *
 * MANUAL LOWERING (what works today):
 *   CCTask channel + ordered_recv helper
 */

int compress_file(const char* in_path, const char* out_path, int level) {
    (void)level;
    
    CCFile in_file;
    if (cc_file_open(&in_file, in_path, "rb") != 0) {
        fprintf(stderr, "Failed to open input: %s\n", in_path);
        return 1;
    }
    @defer cc_file_close(&in_file);

    CCFile out_file;
    if (cc_file_open(&out_file, out_path, "wb") != 0) {
        fprintf(stderr, "Failed to open output: %s\n", out_path);
        return 1;
    }
    @defer cc_file_close(&out_file);

    // Internal representation: channel of CCTask handles
    CCTask[~CHAN_CAP >] tasks_tx;
    CCTask[~CHAN_CAP <] tasks_rx;
    CCChan* ch = channel_pair(&tasks_tx, &tasks_rx);
    @defer cc_chan_free(ch);

    CCFile* in_ptr = &in_file;
    CCFile* out_ptr = &out_file;

    @nursery {
        // Consumer: ordered_recv awaits task and extracts result
        spawn(() => [out_ptr, tasks_rx] {
            void* result;
            while (ordered_recv(tasks_rx, &result) == 1) {
                CompressedResult* r = (CompressedResult*)result;
                if (r) {
                    cc_file_write(out_ptr, r->data);
                    cc_heap_arena_free(&r->arena);
                }
            }
        });

        // Producer: spawn task + send handle (manual chan_send_task)
        @nursery closing(tasks_tx) {
            spawn(() => [in_ptr, tasks_tx] {
                long seq = 0;
                while (true) {
                    CCArena blk_arena = cc_heap_arena(BLOCK_SIZE + BLOCK_ARENA_OVERHEAD);
                    CCSlice data;
                    bool !>(CCIoError) read_res = cc_file_read(in_ptr, &blk_arena, BLOCK_SIZE, &data);
                    
                    if (cc_is_err(read_res) || !cc_io_avail(read_res)) {
                        cc_heap_arena_free(&blk_arena);
                        break;
                    }
                    
                    Block* blk = arena_alloc1(Block, &blk_arena);
                    if (!blk) {
                        cc_heap_arena_free(&blk_arena);
                        break;
                    }
                    
                    blk->seq = seq++;
                    blk->data = data;
                    blk->is_last = (data.len < BLOCK_SIZE);
                    blk->arena = blk_arena;
                    
                    // Manual lowering of: chan_send_task(tx, () => compress_block(blk))
                    CCTask task = cc_fiber_spawn_task(compress_task_wrapper, blk);
                    cc_chan_send(tasks_tx.raw, &task, sizeof(task));
                    
                    if (blk->is_last) break;
                }
            });
        }
    }

    cc_file_sync(&out_file);
    return 0;
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <file>\n", argv[0]);
        return 1;
    }
    
    char out_name[4096];
    snprintf(out_name, sizeof(out_name), "%s.gz", argv[1]);
    
    int ret = compress_file(argv[1], out_name, 6);
    
    if (ret == 0) {
        printf("Compressed %s -> %s\n", argv[1], out_name);
        printf("Stats: %lld bytes in, %lld bytes out, %d blocks\n",
               (long long)cc_atomic_load(&g_bytes_in),
               (long long)cc_atomic_load(&g_bytes_out),
               cc_atomic_load(&g_blocks_done));
    }
    
    return ret;
}

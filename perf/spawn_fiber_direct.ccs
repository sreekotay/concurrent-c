/*
 * Direct fiber spawn benchmark - bypass nursery overhead.
 * Measures: raw fiber spawn/join throughput.
 */
#include <ccc/std/prelude.cch>
#include <stdio.h>
#include <time.h>

#define ITERATIONS 100000

/* Forward declare internal fiber type */
struct fiber_task;
extern struct fiber_task* cc_fiber_spawn(void* (*fn)(void*), void* arg);
extern int cc_fiber_join(struct fiber_task* t, void** out_result);
extern void cc_fiber_task_free(struct fiber_task* t);

static cc_atomic_int global_counter = 0;

static void* increment_task(void* arg) {
    (void)arg;
    cc_atomic_fetch_add(&global_counter, 1);
    return NULL;
}

static double time_now_ms(void) {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return ts.tv_sec * 1000.0 + ts.tv_nsec / 1000000.0;
}

int main(void) {
    printf("spawn_fiber_direct: measuring direct fiber spawn throughput\n");

    double start = time_now_ms();

    for (int i = 0; i < ITERATIONS; i++) {
        struct fiber_task* t = cc_fiber_spawn(increment_task, NULL);
        if (t) {
            cc_fiber_join(t, NULL);
            cc_fiber_task_free(t);
        }
    }

    double elapsed = time_now_ms() - start;
    int total_spawns = cc_atomic_load(&global_counter);
    double spawns_per_sec = total_spawns / (elapsed / 1000.0);

    printf("  fiber spawns: %.0f spawns/sec (%.1f ms, total=%d)\n",
           spawns_per_sec, elapsed, total_spawns);

    printf("spawn_fiber_direct: DONE\n");
    return 0;
}
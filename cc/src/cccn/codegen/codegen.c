#include "codegen.h"
#include <string.h>

static void emit_node(const CCCNNode* node, FILE* out, int indent);

static void emit_indent(int indent, FILE* out) {
    for (int i = 0; i < indent; i++) fprintf(out, "  ");
}

static void emit_node(const CCCNNode* node, FILE* out, int indent) {
    if (!node) return;

    switch (node->kind) {
        case CC_AST_FN:
            fprintf(out, "\n");
            if (node->as.fn.is_async) fprintf(out, "/* @async */ ");
            fprintf(out, "void %s(", node->as.fn.name);
            for (int i = 0; i < node->as.fn.params_len; i++) {
                emit_node(node->as.fn.params[i], out, 0);
                if (i < node->as.fn.params_len - 1) fprintf(out, ", ");
            }
            fprintf(out, ") ");
            emit_node(node->as.fn.body, out, indent);
            fprintf(out, "\n");
            break;

        case CC_AST_BLOCK:
            fprintf(out, "{\n");
            for (int i = 0; i < node->as.block.stmts_len; i++) {
                emit_indent(indent + 1, out);
                emit_node(node->as.block.stmts[i], out, indent + 1);
                fprintf(out, ";\n");
            }
            emit_indent(indent, out);
            fprintf(out, "}");
            break;

        case CC_AST_CALL:
            if (node->as.call.is_ufcs && node->as.call.receiver) {
                fprintf(out, "%s(", node->as.call.method);
                emit_node(node->as.call.receiver, out, 0);
                if (node->as.call.args_len > 0) fprintf(out, ", ");
            } else {
                fprintf(out, "%s(", node->as.call.method);
            }
            for (int i = 0; i < node->as.call.args_len; i++) {
                emit_node(node->as.call.args[i], out, 0);
                if (i < node->as.call.args_len - 1) fprintf(out, ", ");
            }
            fprintf(out, ")");
            break;

        case CC_AST_IDENT:
            fprintf(out, "%s", node->as.ident.name);
            break;

        case CC_AST_LITERAL:
            fprintf(out, "%s", node->as.literal.value);
            break;

        case CC_AST_LET:
            fprintf(out, "auto %s = ", node->as.let.name);
            emit_node(node->as.let.init, out, 0);
            break;

        default:
            fprintf(out, "/* unknown node kind %d */", node->kind);
            break;
    }
}

int cccn_emit_c(const CCCNRoot* root, FILE* out) {
    if (!root || !out) return -1;

    fprintf(out, "/* Generated by cccn */\n");
    fprintf(out, "#include <ccc/cc_runtime.cch>\n\n");

    for (int i = 0; i < root->items_len; i++) {
        emit_node(root->items[i], out, 0);
    }

    return 0;
}

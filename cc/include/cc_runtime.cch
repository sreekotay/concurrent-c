#ifndef CC_RUNTIME_H
#define CC_RUNTIME_H

#include <stddef.h>
#include <stdint.h>
#include <string.h>

#include "cc_slice.cch"
#include "cc_arena.cch"
#include "cc_io.cch"
#include "cc_optional.cch"
#include "cc_result.cch"
#include "cc_channel.cch"
#include "cc_sched.cch"
#include "cc_nursery.cch"
#include "std/task_intptr.cch"

/* Surface channel helpers (ergonomic layer over CCChanTx/CCChanRx).
   These are macros so they can infer sizes from expressions / pointers. */
#ifdef CC_PARSER_MODE
/* In parser-only mode (TCC stub-AST generation), we only need the code to parse.
   Avoid macros like `&(literal)` that can trip "lvalue expected" errors under TCC. */
#define chan_send(tx, value) (0)
#define chan_recv(rx, out_ptr) (0)
#define chan_close(tx) ((void)0)
#define chan_free(h) ((void)0)
#define chan_try_recv(rx, out_ptr) (0)
#define chan_try_send(tx, value) (0)
#define chan_send_take_ptr(tx, ptr) (0)
#define chan_send_take_slice(tx, slice_ptr) (0)
#define chan_send_take(tx, x) (0)
#else
#if (defined(__clang__) || defined(__GNUC__)) && !defined(__TINYC__)
/* Send by value (copies `value` into a temporary to take its address). Returns 0 or errno-style code. */
#define chan_send(tx, value) ({ __typeof__(value) __cc_tmp = (value); cc_chan_send((tx).raw, &__cc_tmp, sizeof(__cc_tmp)); })
/* Recv into pointer `out_ptr`. Returns 0, EPIPE (closed+drained), or errno-style code. */
#define chan_recv(rx, out_ptr) (cc_chan_recv((rx).raw, (out_ptr), sizeof(*(out_ptr))))
/* Close the underlying channel (valid on tx). */
#define chan_close(tx) (cc_chan_close((tx).raw))
/* Free the underlying channel (call exactly once for a (tx,rx) pair).
   For handles: chan_free(tx) or tx.free()
   For CCChan*: cc_chan_free(ch) */
#define chan_free(h) (cc_chan_free((h).raw))
/* Try-recv/try-send helpers */
#define chan_try_recv(rx, out_ptr) (cc_chan_try_recv((rx).raw, (out_ptr), sizeof(*(out_ptr))))
#define chan_try_send(tx, value) ({ __typeof__(value) __cc_tmp = (value); cc_chan_try_send((tx).raw, &__cc_tmp, sizeof(__cc_tmp)); })
/* send_take primitives */
#define chan_send_take_ptr(tx, ptr) (cc_chan_send_take((tx).raw, (void*)(ptr)))
#define chan_send_take_slice(tx, slice_ptr) (cc_chan_send_take_slice((tx).raw, (const CCSlice*)(slice_ptr)))
#define chan_send_take(tx, x) ({ \
  __typeof__(x) __cc_v = (x); \
  int __cc_is_slice = (__builtin_types_compatible_p(__typeof__(__cc_v), CCSlice) || __builtin_types_compatible_p(__typeof__(__cc_v), CCSliceUnique)); \
  __cc_is_slice ? cc_chan_send_take_slice((tx).raw, (const CCSlice*)&__cc_v) : cc_chan_send_take((tx).raw, (void*)(__cc_v)); \
})
#else
/* Fallbacks (less ergonomic): still avoid `.raw` at call sites for common cases. */
#define chan_send(tx, value) (cc_chan_send((tx).raw, &(value), sizeof(value)))
#define chan_recv(rx, out_ptr) (cc_chan_recv((rx).raw, (out_ptr), sizeof(*(out_ptr))))
#define chan_close(tx) (cc_chan_close((tx).raw))
/* Free the underlying channel - for handles use chan_free(tx), for CCChan* use cc_chan_free(ch) */
#define chan_free(h) (cc_chan_free((h).raw))
#define chan_try_recv(rx, out_ptr) (cc_chan_try_recv((rx).raw, (out_ptr), sizeof(*(out_ptr))))
#define chan_try_send(tx, value) (cc_chan_try_send((tx).raw, &(value), sizeof(value)))
#define chan_send_take_ptr(tx, ptr) (cc_chan_send_take((tx).raw, (void*)(ptr)))
#define chan_send_take_slice(tx, slice_ptr) (cc_chan_send_take_slice((tx).raw, (const CCSlice*)(slice_ptr)))
#define chan_send_take(tx, x) chan_send_take_ptr(tx, x)
#endif
#endif /* CC_PARSER_MODE */

/* Surface constructor marker. This is lowered by the CC frontend; the runtime does not implement it.
   Declared here to avoid implicit-declaration warnings if the lowering misses a call site.
   
   Usage:
     Statement form (legacy): channel_pair(&tx, &rx);
     Expression form (preferred): CCChan* ch = channel_pair(&tx, &rx);
   
   The expression form returns the underlying channel for explicit cleanup with chan_free(ch). */
CCChan* channel_pair(CCChanTx* tx, CCChanRx* rx);

/* Language-level cancellation helpers.
   The runtime already provides cc_cancel(CCDeadline*) / cc_is_cancelled(const CCDeadline*).
   At the language surface, `cc_cancel()` / `cc_is_cancelled()` refer to the current deadline scope
   established by `with_deadline(...) { ... }` lowering. */
#define cc_cancel() cc_cancel_current()
#define cc_is_cancelled() cc_is_cancelled_current()

// Forward declarations for runtime handles.
typedef struct CCChan CCChan;
typedef struct CCTask CCTask;

/* Explicit move primitive.
   Best-effort: uses GNU statement-expr supported by Clang/GCC.
   For now we "poison" the moved-from value by zeroing it.
   The compiler will enforce use-after-move for certain move-only values (e.g. unique slices) over time. */
#if defined(CC_PARSER_MODE)
/* During TCC parse-to-stub-AST, macros expand before recording. We emit a real call the recorder can see. */
static inline void cc__move_marker_impl(void* p) { (void)p; }
#define cc_move(x) (cc__move_marker_impl(&(x)), (x))
#elif (defined(__clang__) || defined(__GNUC__)) && !defined(__TINYC__)
#define cc_move(x) ({ __typeof__(x) __cc_tmp = (x); memset(&(x), 0, sizeof(x)); __cc_tmp; })
#else
#define cc_move(x) (x)
#endif

#endif // CC_RUNTIME_H


/*
 * CC closure ABI (early, minimal).
 *
 * This is the foundation for:
 * - `() => { ... }` closures (capture-by-copy)
 * - passing closures into runtimes (nursery spawn, blocking executor, etc.)
 *
 * NOTE: For now we only standardize a 0-arg closure returning void* (like pthread).
 * Higher-arity + typed closures will layer on top as compiler support grows.
 */
#ifndef CC_CLOSURE_H
#define CC_CLOSURE_H

#include <stddef.h>
#include <stdint.h>

/* TSan annotations for closure make functions */
#if defined(__SANITIZE_THREAD__) || (defined(__has_feature) && __has_feature(thread_sanitizer))
extern void __tsan_write8(void* addr);
extern void __tsan_read8(void* addr);
/* Mark writes to local struct as benign - these are thread-local stack writes */
#define TSAN_IGNORE_LOCAL_WRITE(addr) do { \
    __tsan_write8(addr); \
    __tsan_read8(addr); \
} while(0)
#else
#define TSAN_IGNORE_LOCAL_WRITE(addr) ((void)0)
#endif

/* Forward declaration to avoid include cycles (`cc_nursery.cch` may include runtime types). */
typedef struct CCNursery CCNursery;

#if defined(CC_PARSER_MODE)
/* TCC parse-to-stub-AST runs after preprocessing. For CC syntax like `() => {}`,
   we intentionally use a dummy type so the C parser doesn't reject otherwise-valid CC code.
   The real ABI type is used for the final emitted C compilation. */
typedef int CCClosure0;
#define CCClosure1 CCClosure0
#define CCClosure2 CCClosure0
#else
typedef struct {
    void* (*fn)(void* env);
    void* env;
    void (*drop)(void* env); /* optional; can be NULL */
} CCClosure0;

typedef struct {
    void* (*fn)(void* env, intptr_t arg0);
    void* env;
    void (*drop)(void* env); /* optional; can be NULL */
} CCClosure1;

typedef struct {
    void* (*fn)(void* env, intptr_t arg0, intptr_t arg1);
    void* env;
    void (*drop)(void* env); /* optional; can be NULL */
} CCClosure2;
#endif

#if defined(__SANITIZE_THREAD__) || (defined(__has_feature) && __has_feature(thread_sanitizer))
/* TSan can report false positives on local stack writes in tiny inline helpers.
   These helpers only touch a local struct, so suppressing TSan here is safe. */
#define CC_TSAN_NOSAN_FN __attribute__((no_sanitize("thread")))
#else
#define CC_TSAN_NOSAN_FN
#endif

/* Run a closure on a blocking OS thread and wait for completion.
   Early stub: implemented via pthread spawn + join. */
int cc_run_blocking_closure0(CCClosure0 c);

/* Run a closure on a blocking OS thread and return its `void*` result. */
void* cc_run_blocking_closure0_ptr(CCClosure0 c);


/* Invoke a 1-arg closure. */
void* cc_closure1_call(CCClosure1 c, intptr_t arg0);
/* Invoke a 2-arg closure. */
void* cc_closure2_call(CCClosure2 c, intptr_t arg0, intptr_t arg1);

/* Spawn arity-1/2 closures in a nursery (bridge for `spawn(c, arg...)`). */
int cc_nursery_spawn_closure1(CCNursery* n, CCClosure1 c, intptr_t arg0);
int cc_nursery_spawn_closure2(CCNursery* n, CCClosure2 c, intptr_t arg0, intptr_t arg1);

static inline CCClosure0 cc_closure0_make(void* (*fn)(void*), void* env, void (*drop)(void*)) CC_TSAN_NOSAN_FN {
#if defined(CC_PARSER_MODE)
    (void)fn; (void)env; (void)drop;
    return 0;
#else
    CCClosure0 c;
    /* TSan: Mark writes to local struct as benign (thread-local stack memory) */
    TSAN_IGNORE_LOCAL_WRITE(&c);
    c.fn = fn;
    c.env = env;
    c.drop = drop;
    return c;
#endif
}

static inline CCClosure1 cc_closure1_make(void* (*fn)(void*, intptr_t), void* env, void (*drop)(void*)) CC_TSAN_NOSAN_FN {
#if defined(CC_PARSER_MODE)
    (void)fn; (void)env; (void)drop;
    return 0;
#else
    CCClosure1 c;
    /* TSan: Mark writes to local struct as benign (thread-local stack memory) */
    TSAN_IGNORE_LOCAL_WRITE(&c);
    c.fn = fn;
    c.env = env;
    c.drop = drop;
    return c;
#endif
}

static inline CCClosure2 cc_closure2_make(void* (*fn)(void*, intptr_t, intptr_t), void* env, void (*drop)(void*)) CC_TSAN_NOSAN_FN {
#if defined(CC_PARSER_MODE)
    (void)fn; (void)env; (void)drop;
    return 0;
#else
    CCClosure2 c;
    /* TSan: Mark writes to local struct as benign (thread-local stack memory) */
    TSAN_IGNORE_LOCAL_WRITE(&c);
    c.fn = fn;
    c.env = env;
    c.drop = drop;
    return c;
#endif
}

#endif /* CC_CLOSURE_H */


/*
 * Minimal executor for async offload (pthread work queue).
 * This is a portability layer; backpressure returns EBUSY/EAGAIN.
 */
#ifndef CC_EXEC_H
#define CC_EXEC_H

#include <ccc/cc_compat.cch>
#include <errno.h>

typedef struct CCExec CCExec;

typedef void (*cc_exec_fn)(void *arg);

typedef struct {
    size_t workers;
    size_t queue_cap;
    size_t queue_len;
    int shutting_down;
} CCExecStats;

// Initialize executor with a fixed worker count and queue capacity.
// Returns NULL on failure.
CCExec* cc_exec_create(size_t workers, size_t queue_cap);
static inline CCExec* cc_exec_init(size_t workers, size_t queue_cap) {
    return cc_exec_create(workers, queue_cap);
}

// Submit a job; returns 0 on success, EAGAIN/EBUSY on full, or errno on failure.
int cc_exec_submit(CCExec* ex, cc_exec_fn fn, void *arg);

// Graceful shutdown: no new work, waits for queued tasks to finish.
void cc_exec_shutdown(CCExec* ex);

// Snapshot executor stats; returns 0 on success.
int cc_exec_stats(CCExec* ex, CCExecStats* out);

// Force free (after shutdown).
void cc_exec_free(CCExec* ex);
static inline void cc_exec_destroy(CCExec* ex) { cc_exec_free(ex); }

#endif // CC_EXEC_H




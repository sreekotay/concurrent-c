/*
 * Arena-backed hash map for Concurrent-C stdlib.
 * 
 * Built on khashl (MIT, Attractive Chaos) with these benefits:
 * - 1-bit per bucket flags (32x smaller than naive)
 * - No tombstones (backshift deletion)
 * - Fibonacci hashing (better distribution)
 * - Linear probing (cache-friendly)
 * 
 * Spec-compliant API:
 * - Name_get(h, key) returns V? (optional, None if not found)
 * - Name_get_ptr(h, key) returns V* (mutable access, NULL if not found)
 * - Name_insert(h, key, val) inserts or updates
 * - Name_remove(h, key) returns bool (true if existed)
 * 
 * Usage:
 *   CC_MAP_DECL_ARENA_FULL(int, int, IntMap, CCOptional_int, hash_i32, eq_i32)
 *   IntMap *m = IntMap_init(&arena);
 *   IntMap_insert(m, 42, 100);
 *   int? val = IntMap_get(m, 42);  // returns optional
 */
#ifndef CC_STD_MAP_H
#define CC_STD_MAP_H

#include <stdlib.h>
#include <stdint.h>
#include <string.h>

#ifndef __has_include
#define __has_include(x) 0
#endif
#if __has_include(<stdbool.h>)
#include <stdbool.h>
#else
#ifndef __bool_true_false_are_defined
typedef int bool;
#define true 1
#define false 0
#define __bool_true_false_are_defined 1
#endif
#endif

#include <ccc/cc_arena.cch>
#include <ccc/cc_optional.cch>

/*
 * TCC PARSER MODE: Map types use a generic placeholder during parsing.
 *
 * The CC preprocessor rewrites Map<K,V> to __CC_MAP(K_mangled, V_mangled)*.
 * In parser mode, this macro expands to __CCMapGeneric.
 * In codegen, it's rewritten to Map_K_V with proper declarations emitted.
 */
#ifdef CC_PARSER_MODE

/* Generic Map placeholder struct for parser mode - any key/value types.
   Simplified struct that just needs to compile for type checking.
   Guard allows cccn parse stubs to predefine this. */
#ifndef __CC_MAP_GENERIC_DEFINED
#define __CC_MAP_GENERIC_DEFINED
typedef struct __CCMapGeneric {
    size_t count;    /* Number of entries */
    void *keys;      /* Key storage */
    void *vals;      /* Value storage */
    void *arena;     /* CCArena* */
} __CCMapGeneric;
#endif

/* THE KEY MACRO: In parser mode, all Map types resolve to generic.
   Usage: __CC_MAP(int, int) expands to __CCMapGeneric
   Codegen rewrites this to Map_int_int */
#ifndef __CC_MAP
#define __CC_MAP(K, V) __CCMapGeneric
#endif

/* Generic constructor - parser mode doesn't actually run,
   so just return a pointer to NULL-like value. Uses a static to have an address. */
static __CCMapGeneric __cc_map_generic_dummy = {0, NULL, NULL, NULL};
static inline __CCMapGeneric* __cc_map_generic_init(void *arena) {
    (void)arena;
    return &__cc_map_generic_dummy;
}

/* Macro-based init that accepts any key/value types - parser mode just validates types. */
#define __CC_MAP_INIT(K, V, arena) __cc_map_generic_init((void*)(arena))

/* Parser-mode method stubs - just need to type-check, not actually run */
static inline int __cc_map_generic_insert(__CCMapGeneric *m, ...) { 
    (void)m; 
    return 0; 
}
static inline int __cc_map_generic_put(__CCMapGeneric *m, ...) { 
    (void)m; 
    return 0; 
}
static inline __CCOptionalGeneric __cc_map_generic_get(__CCMapGeneric *m, ...) { 
    (void)m; 
    __CCOptionalGeneric result = {0};
    return result; 
}
static inline void* __cc_map_generic_get_ptr(__CCMapGeneric *m, ...) { 
    (void)m; 
    return NULL; 
}
static inline int __cc_map_generic_remove(__CCMapGeneric *m, ...) { 
    (void)m; 
    return 0; 
}
static inline int __cc_map_generic_del(__CCMapGeneric *m, ...) { 
    (void)m; 
    return 0; 
}
static inline size_t __cc_map_generic_len(const __CCMapGeneric *m) { 
    return m ? m->count : 0; 
}
static inline void __cc_map_generic_clear(__CCMapGeneric *m) { 
    (void)m; 
}
static inline void __cc_map_generic_destroy(__CCMapGeneric *m) { 
    (void)m; 
}

/* Parser-mode: common Map types are aliases to __CCMapGeneric */
typedef __CCMapGeneric Map_int_int;
typedef __CCMapGeneric Map_int_voidptr;
typedef __CCMapGeneric Map_int_charptr;
typedef __CCMapGeneric Map_uint64_t_int;
typedef __CCMapGeneric Map_uint64_t_voidptr;

/* Parser-mode: function aliases for common Map types.
   Maps Map_K_V_method to generic stubs so direct function calls compile. */
#define Map_int_int_init(a)       __cc_map_generic_init((void*)(a))
#define Map_int_int_insert(m, k, v) __cc_map_generic_insert((m), (k), (v))
#define Map_int_int_put(m, k, v, r) __cc_map_generic_put((m), (k), (v), (r))
#define Map_int_int_get(m, k)     __cc_map_generic_get((m), (k))
#define Map_int_int_get_ptr(m, k) __cc_map_generic_get_ptr((m), (k))
#define Map_int_int_remove(m, k)  __cc_map_generic_remove((m), (k))
#define Map_int_int_del(m, k)     __cc_map_generic_del((m), (k))
#define Map_int_int_len(m)        __cc_map_generic_len((m))
#define Map_int_int_clear(m)      __cc_map_generic_clear((m))
#define Map_int_int_destroy(m)    __cc_map_generic_destroy((m))

#define Map_uint64_t_int_init(a)       __cc_map_generic_init((void*)(a))
#define Map_uint64_t_int_insert(m, k, v) __cc_map_generic_insert((m), (k), (v))
#define Map_uint64_t_int_get(m, k)     __cc_map_generic_get((m), (k))
#define Map_uint64_t_int_len(m)        __cc_map_generic_len((m))

#else /* !CC_PARSER_MODE - real compilation */

/* In real compilation, __CC_MAP expands to the actual type name.
   The codegen pass ensures CC_MAP_DECL_ARENA is emitted for each type. */
#define __CC_MAP(K, V) Map_##K##_##V

/* In real mode, init calls the generated type-specific function */
#define __CC_MAP_INIT(K, V, arena) Map_##K##_##V##_init((arena))

#endif /* CC_PARSER_MODE */

/*
 * Arena-backed allocator hooks for khashl.
 * - Kmalloc/Kcalloc: allocate from arena
 * - Krealloc: allocate new + copy (old stays in arena until reset)
 * - Kfree: no-op (arena bulk-frees on reset)
 */
#define Kmalloc(km, type, cnt) \
    ((type*)cc_arena_alloc((CCArena*)(km), (cnt) * sizeof(type), _Alignof(type)))

#define Kcalloc(km, type, cnt) \
    ((type*)({ \
        void *__p = cc_arena_alloc((CCArena*)(km), (cnt) * sizeof(type), _Alignof(type)); \
        if (__p) memset(__p, 0, (cnt) * sizeof(type)); \
        __p; \
    }))

#define Krealloc(km, type, ptr, cnt) \
    ((type*)({ \
        size_t __sz = (cnt) * sizeof(type); \
        type *__new = (type*)cc_arena_alloc((CCArena*)(km), __sz, _Alignof(type)); \
        if (__new && (ptr)) memcpy(__new, (ptr), __sz); \
        __new; \
    }))

#define Kfree(km, ptr) ((void)0)  /* no-op: arena manages memory */

/* Now include khashl with our allocator hooks */
#include <ccc/vendor/khashl.h>

/*
 * Hash function helpers
 */
static inline khint_t cc_kh_hash_i32(int x) { return kh_hash_uint32((khint_t)x); }
static inline int cc_kh_eq_i32(int a, int b) { return a == b; }

static inline khint_t cc_kh_hash_u64(uint64_t x) { return kh_hash_uint64(x); }
static inline int cc_kh_eq_u64(uint64_t a, uint64_t b) { return a == b; }

/* Slice hashing (FNV-1a) */
static inline khint_t cc_kh_hash_slice(CCSlice s) {
    khint_t h = 2166136261U;
    const unsigned char *p = (const unsigned char*)s.ptr;
    for (size_t i = 0; i < s.len; ++i)
        h ^= p[i], h *= 16777619;
    return h;
}
static inline int cc_kh_eq_slice(CCSlice a, CCSlice b) {
    return a.len == b.len && (a.ptr == b.ptr || (a.ptr && b.ptr && memcmp(a.ptr, b.ptr, a.len) == 0));
}

/*
 * CC_MAP_DECL_ARENA_FULL(K, V, Name, OptV, HASH_FN, EQ_FN)
 * 
 * Declares an arena-backed hash map with optional-returning get.
 * OptV is the optional type for V (e.g., CCOptional_int for int).
 * 
 * API:
 * - Name_init(arena) -> Name*
 * - Name_destroy(h)
 * - Name_insert(h, key, val) -> 0 on success, -1 on failure
 * - Name_get(h, key) -> OptV (None if not found)
 * - Name_get_ptr(h, key) -> V* (mutable access, NULL if not found)
 * - Name_remove(h, key) -> bool (true if existed)
 * - Name_len(h) -> size
 * - Name_clear(h)
 * 
 * HASH_FN: khint_t fn(K key)
 * EQ_FN:   int fn(K a, K b)  (returns non-zero if equal)
 */
#define CC_MAP_DECL_ARENA_FULL(K, V, Name, OptV, HASH_FN, EQ_FN)               \
    KHASHL_MAP_INIT(KH_LOCAL, Name##__kh, Name##__kh, K, V, HASH_FN, EQ_FN)    \
                                                                               \
    typedef Name##__kh Name;                                                   \
                                                                               \
    static inline Name* Name##_init(CCArena *arena) {                          \
        return Name##__kh_init2((void*)arena);                                 \
    }                                                                          \
                                                                               \
    static inline void Name##_destroy(Name *h) {                               \
        Name##__kh_destroy(h);                                                 \
    }                                                                          \
                                                                               \
    /* Insert or update: returns 0 on success, -1 on failure */                \
    static inline int Name##_insert(Name *h, K key, V val) {                   \
        if (!h) return -1;                                                     \
        int absent = 0;                                                        \
        khint_t k = Name##__kh_put(h, key, &absent);                           \
        if (absent < 0) return -1;                                             \
        kh_val(h, k) = val;                                                    \
        return 0;                                                              \
    }                                                                          \
                                                                               \
    /* Legacy put with absent flag */                                          \
    static inline int Name##_put(Name *h, K key, V val, int *ret) {            \
        if (!h) { if (ret) *ret = -1; return -1; }                             \
        int absent = 0;                                                        \
        khint_t k = Name##__kh_put(h, key, &absent);                           \
        if (absent < 0) { if (ret) *ret = -1; return -1; }                     \
        kh_val(h, k) = val;                                                    \
        if (ret) *ret = absent;                                                \
        return (int)k;                                                         \
    }                                                                          \
                                                                               \
    /* Get: returns optional (None if not found) */                            \
    static inline OptV Name##_get(const Name *h, K key) {                      \
        OptV result = {0};                                                     \
        if (!h) return result;                                                 \
        khint_t k = Name##__kh_get(h, key);                                    \
        if (k == kh_end(h)) return result;                                     \
        result.has = 1;                                                        \
        CC_OPT_SET_VALUE(result, kh_val(h, k));                                \
        return result;                                                         \
    }                                                                          \
                                                                               \
    /* Mutable pointer access: returns pointer or NULL */                      \
    static inline V* Name##_get_ptr(Name *h, K key) {                          \
        if (!h) return NULL;                                                   \
        khint_t k = Name##__kh_get(h, key);                                    \
        if (k == kh_end(h)) return NULL;                                       \
        return &kh_val(h, k);                                                  \
    }                                                                          \
                                                                               \
    /* Remove: returns true if key existed */                                  \
    static inline bool Name##_remove(Name *h, K key) {                         \
        if (!h) return false;                                                  \
        khint_t k = Name##__kh_get(h, key);                                    \
        if (k == kh_end(h)) return false;                                      \
        Name##__kh_del(h, k);                                                  \
        return true;                                                           \
    }                                                                          \
                                                                               \
    /* Legacy del alias */                                                     \
    static inline bool Name##_del(Name *h, K key) {                            \
        return Name##_remove(h, key);                                          \
    }                                                                          \
                                                                               \
    static inline size_t Name##_len(const Name *h) {                           \
        return h ? kh_size(h) : 0;                                             \
    }                                                                          \
                                                                               \
    static inline void Name##_clear(Name *h) {                                 \
        if (h) Name##__kh_clear(h);                                            \
    }

/*
 * CC_MAP_DECL_ARENA(K, V, Name, HASH_FN, EQ_FN)
 * 
 * Convenience macro for simple value types where OptV = CCOptional_##V.
 * For complex value types (pointers, structs), use CC_MAP_DECL_ARENA_FULL.
 */
#define CC_MAP_DECL_ARENA(K, V, Name, HASH_FN, EQ_FN) \
    CC_MAP_DECL_ARENA_FULL(K, V, Name, CCOptional_##V, HASH_FN, EQ_FN)

/* Iteration helper: iterates over all (key, val) pairs */
#define CC_MAP_FOREACH(h, k_var, v_var)                                        \
    for (khint_t __i = 0; (h) && __i != kh_end(h); ++__i)                      \
        if (kh_exist((h), __i) &&                                              \
            ((k_var) = kh_key((h), __i), (v_var) = kh_val((h), __i), 1))

/* Convenience: common key types (simple value types only) */
#define CC_MAP_DECL_INT(V, Name)    CC_MAP_DECL_ARENA(int, V, Name, cc_kh_hash_i32, cc_kh_eq_i32)
#define CC_MAP_DECL_U64(V, Name)    CC_MAP_DECL_ARENA(uint64_t, V, Name, cc_kh_hash_u64, cc_kh_eq_u64)
#define CC_MAP_DECL_SLICE(V, Name)  CC_MAP_DECL_ARENA(CCSlice, V, Name, cc_kh_hash_slice, cc_kh_eq_slice)

/* Full versions with explicit optional type */
#define CC_MAP_DECL_INT_FULL(V, Name, OptV)    CC_MAP_DECL_ARENA_FULL(int, V, Name, OptV, cc_kh_hash_i32, cc_kh_eq_i32)
#define CC_MAP_DECL_U64_FULL(V, Name, OptV)    CC_MAP_DECL_ARENA_FULL(uint64_t, V, Name, OptV, cc_kh_hash_u64, cc_kh_eq_u64)
#define CC_MAP_DECL_SLICE_FULL(V, Name, OptV)  CC_MAP_DECL_ARENA_FULL(CCSlice, V, Name, OptV, cc_kh_hash_slice, cc_kh_eq_slice)

/* Legacy alias for compatibility */
#define Map(K, V, Name, HASH_FN, EQ_FN) CC_MAP_DECL_ARENA(K, V, Name, HASH_FN, EQ_FN)

#endif /* CC_STD_MAP_H */

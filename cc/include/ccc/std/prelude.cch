/*
 * Concurrent-C stdlib prelude.
 *
 * Includes all stdlib headers. All types use the CC prefix (CCFile, CCArena, etc.)
 * to avoid namespace collisions - this is idiomatic C style.
 */
#ifndef CC_STD_PRELUDE_H
#define CC_STD_PRELUDE_H

#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

#include <ccc/cc_arena.cch>
#include <ccc/cc_slice.cch>
#include <ccc/cc_result.cch>
#include <ccc/cc_channel.cch>
#include <ccc/cc_exec.cch>
#include "string.cch"
#include "io.cch"
#include "vec.cch"
#include "map.cch"
#include "dir.cch"
#include "process.cch"
#include "async_io.cch"
#include "future.cch"

static inline size_t kilobytes(size_t n) { return n * 1024; }
static inline size_t megabytes(size_t n) { return n * 1024 * 1024; }

// Allocate a growable arena with heap-backed storage of given initial size.
// block_max = 0 means unbounded growth (default for @arena).
// The returned arena owns its memory; cc_arena_free() will free it.
static inline CCArena cc_arena_heap(size_t bytes) {
    CCArena a = {0};
    void* buf = malloc(bytes);
    if (buf && cc_arena_init(&a, buf, bytes) != 0) {
        free(buf);
        a.base = NULL;
    } else if (buf) {
        a._flags |= CC_ARENA_FLAG_HEAP_OWNED;  // mark as heap-owned
        a.block_max = 0;  // growable (unbounded) by default
    }
    return a;
}

// Allocate a growable arena with an explicit block budget.
// budget = 0: unbounded, 1: fixed (no growth), N: at most N blocks.
static inline CCArena cc_arena_heap_budget(size_t bytes, uint16_t budget) {
    CCArena a = cc_arena_heap(bytes);
    a.block_max = budget;
    return a;
}

// Free arena and all grown extents. Frees heap-backed buffers; no-op for user-backed.
// This is the unified cleanup function for all arena types.
static inline void cc_arena_free(CCArena* a) {
    if (!a) return;

    // Free all extent structs and their buffers in the growth chain
    CCArena *cur = a->prev;
    while (cur) {
        CCArena *next = cur->prev;
        if (cur->base) free(cur->base);
        free(cur);  // free the extent struct itself
        cur = next;
    }
    a->prev = NULL;

    // Free the root's buffer if heap-owned
    if (a->base && (a->_flags & CC_ARENA_FLAG_HEAP_OWNED)) {
        free(a->base);
    }
    a->base = NULL;
    a->capacity = 0;
    a->offset = 0;
    a->_flags = 0;
    a->block_idx = 0;
}

// Legacy alias - use cc_arena_heap instead
static inline CCArena cc_heap_arena(size_t bytes) {
    return cc_arena_heap(bytes);
}

// Legacy alias - use cc_arena_free instead
static inline void cc_heap_arena_free(CCArena* a) {
    cc_arena_free(a);
}

// Detach and return the arena's memory (including all growth extents),
// leaving the source arena empty.
// Use this to transfer ownership out of an @arena block.
// After detach, the source arena is empty and its cleanup becomes a no-op.
// The returned arena inherits the ownership flag and growth chain.
static inline CCArena cc_arena_detach(CCArena* a) {
    CCArena taken = {0};
    if (a && a->base) {
        taken = *a;
        a->base = NULL;
        a->capacity = 0;
        a->offset = 0;
        a->_flags = 0;
        a->block_idx = 0;
        a->block_max = 0;
        a->prev = NULL;
    }
    return taken;
}

#endif // CC_STD_PRELUDE_H


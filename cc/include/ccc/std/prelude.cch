/*
 * Concurrent-C stdlib prelude.
 *
 * Includes all stdlib headers. All types use the CC prefix (CCFile, CCArena, etc.)
 * to avoid namespace collisions - this is idiomatic C style.
 */
#ifndef CC_STD_PRELUDE_H
#define CC_STD_PRELUDE_H

#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

#include <ccc/cc_arena.cch>
#include <ccc/cc_slice.cch>
#include <ccc/cc_result.cch>
#include <ccc/cc_channel.cch>
#include <ccc/cc_exec.cch>
#include "string.cch"
#include "io.cch"
#include "vec.cch"
#include "map.cch"
#include "dir.cch"
#include "process.cch"
#include "async_io.cch"
#include "future.cch"

static inline size_t kilobytes(size_t n) { return n * 1024; }
static inline size_t megabytes(size_t n) { return n * 1024 * 1024; }

// Allocate an arena with heap-backed storage of given size.
// The returned arena owns its memory; cc_arena_free() will free it.
static inline CCArena cc_arena_heap(size_t bytes) {
    CCArena a = {0};
    void* buf = malloc(bytes);
    if (buf && cc_arena_init(&a, buf, bytes) != 0) {
        free(buf);
        a.base = NULL;
    } else if (buf) {
        a._flags |= CC_ARENA_FLAG_HEAP_OWNED;  // mark as heap-owned
    }
    return a;
}

// Free arena if heap-backed; no-op for user-backed arenas.
// This is the unified cleanup function for all arena types.
static inline void cc_arena_free(CCArena* a) {
    if (!a || !a->base) return;
    if (a->_flags & CC_ARENA_FLAG_HEAP_OWNED) {
        free(a->base);
    }
    a->base = NULL;
    a->capacity = 0;
    a->offset = 0;
    a->_flags = 0;
}

// Legacy alias - use cc_arena_heap instead
static inline CCArena cc_heap_arena(size_t bytes) {
    return cc_arena_heap(bytes);
}

// Legacy alias - use cc_arena_free instead
static inline void cc_heap_arena_free(CCArena* a) {
    cc_arena_free(a);
}

// Detach and return the arena's memory, leaving the source arena empty.
// Use this to transfer ownership out of an @arena block.
// After detach, the source arena is empty and its cleanup becomes a no-op.
// The returned arena inherits the ownership flag.
static inline CCArena cc_arena_detach(CCArena* a) {
    CCArena taken = {0};
    if (a && a->base) {
        taken = *a;
        a->base = NULL;
        a->capacity = 0;
        a->offset = 0;
        a->_flags = 0;
    }
    return taken;
}

#endif // CC_STD_PRELUDE_H


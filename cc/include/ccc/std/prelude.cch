/*
 * Concurrent-C stdlib prelude.
 *
 * Includes the stdlib headers and, if CC_ENABLE_SHORT_NAMES is defined before
 * inclusion, provides short aliases. By default only prefixed names (CC*)
 * are visible to avoid collisions.
 */
#ifndef CC_STD_PRELUDE_H
#define CC_STD_PRELUDE_H

#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

#include <ccc/cc_arena.cch>
#include <ccc/cc_slice.cch>
#include <ccc/cc_result.cch>
#include <ccc/cc_channel.cch>
#include <ccc/cc_exec.cch>
#include "string.cch"
#include "io.cch"
#include "vec.cch"
#include "map.cch"
#include "dir.cch"
#include "process.cch"
#include "async_io.cch"
#include "future.cch"

#ifdef CC_ENABLE_SHORT_NAMES
/* Core types */
typedef CCArena Arena;
typedef CCString String;
typedef CCFile File;
typedef CCSlice Slice;

/* Error types */
typedef CCIoError IoError;
typedef CCIoErrorKind IoErrorKind;
typedef CCError Error;
typedef CCErrorKind ErrorKind;

/* IoError kind constants (IoError::PermissionDenied style in spec) */
#define IoError_PermissionDenied  CC_IO_PERMISSION_DENIED
#define IoError_FileNotFound      CC_IO_FILE_NOT_FOUND
#define IoError_InvalidArgument   CC_IO_INVALID_ARGUMENT
#define IoError_Interrupted       CC_IO_INTERRUPTED
#define IoError_OutOfMemory       CC_IO_OUT_OF_MEMORY
#define IoError_Busy              CC_IO_BUSY
#define IoError_ConnectionClosed  CC_IO_CONNECTION_CLOSED
#define IoError_Other             CC_IO_OTHER

/* IoError constructors (for cc_err() usage) */
#define io_error(kind)         ((CCIoError){(kind), 0})
#define io_error_os(kind, os)  ((CCIoError){(kind), (os)})

/* Generic Error kind constants */
#define Error_None          CC_ERR_NONE
#define Error_Io            CC_ERR_IO
#define Error_Parse         CC_ERR_PARSE
#define Error_Timeout       CC_ERR_TIMEOUT
#define Error_Cancelled     CC_ERR_CANCELLED
#define Error_InvalidArg    CC_ERR_INVALID_ARG
#define Error_OutOfMemory   CC_ERR_OUT_OF_MEMORY
#define Error_NotFound      CC_ERR_NOT_FOUND
#define Error_Permission    CC_ERR_PERMISSION
#define Error_AlreadyExists CC_ERR_ALREADY_EXISTS
#define Error_WouldBlock    CC_ERR_WOULD_BLOCK
#define Error_Closed        CC_ERR_CLOSED
#define Error_Overflow      CC_ERR_OVERFLOW
#define Error_Underflow     CC_ERR_UNDERFLOW

/* Collection macros */
#define ChanPtr(T, Name) CC_DECL_TYPED_CHAN_PTR(T, Name)
#define ChanVal(T, Name) CC_DECL_TYPED_CHAN_VAL(T, Name)
#define Chan(T, Name) CC_DECL_TYPED_CHAN_PTR(T, Name)
#define Vec(T, Name) CC_VEC_DECL_ARENA(T, Name)
#define Map(K, V, Name, HASH_FN, EQ_FN) CC_MAP_DECL_ARENA(K, V, Name, HASH_FN, EQ_FN)
#endif

static inline size_t kilobytes(size_t n) { return n * 1024; }
static inline size_t megabytes(size_t n) { return n * 1024 * 1024; }

// Allocate an arena with heap-backed storage of given size.
static inline CCArena cc_heap_arena(size_t bytes) {
    CCArena a = {0};
    void* buf = malloc(bytes);
    if (buf && cc_arena_init(&a, buf, bytes) != 0) {
        free(buf);
        a.base = NULL;
    }
    return a;
}

// Free backing storage allocated by cc_heap_arena().
static inline void cc_heap_arena_free(CCArena* a) {
    if (!a || !a->base) return;
    free(a->base);
    a->base = NULL;
    a->capacity = 0;
    a->offset = 0;
}

// Detach and return the arena's memory, leaving the source arena empty.
// Use this to transfer ownership out of an @arena block.
// After detach, the source arena is empty and its cleanup becomes a no-op.
static inline CCArena cc_arena_detach(CCArena* a) {
    CCArena taken = {0};
    if (a && a->base) {
        taken = *a;
        a->base = NULL;
        a->capacity = 0;
        a->offset = 0;
    }
    return taken;
}

#ifdef CC_ENABLE_SHORT_NAMES
static inline CCArena arena_detach(CCArena* a) { return cc_arena_detach(a); }
#endif

#endif // CC_STD_PRELUDE_H


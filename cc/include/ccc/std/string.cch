/*
 * Header-only string and slice helpers for Concurrent-C stdlib.
 */
#ifndef CC_STD_STRING_H
#define CC_STD_STRING_H

#include <ccc/cc_compat.cch>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <limits.h>
#include <alloca.h>
#include <stdint.h>
#include <math.h>

#include <ccc/cc_runtime.cch>
#include <ccc/std/vec.cch>

/* In parser mode, Vec_char is already typedef'd to __CCVecGeneric in vec.cch.
   Only emit the real declaration in non-parser (codegen) mode. */
#ifndef CC_PARSER_MODE
CC_VEC_DECL_ARENA(char, Vec_char)
#endif

typedef Vec_char CCString;

// Forward declare string type for helpers that return CCString later.
// ------------------------- Parse error enums ------------------------------
typedef enum {
    CC_I64_PARSE_INVALID_CHAR = 1,
    CC_I64_PARSE_OVERFLOW,
    CC_I64_PARSE_UNDERFLOW,
} CC_I64ParseError;

typedef enum {
    CC_U64_PARSE_INVALID_CHAR = 1,
    CC_U64_PARSE_OVERFLOW,
} CC_U64ParseError;

typedef enum {
    CC_F64_PARSE_INVALID_CHAR = 1,
    CC_F64_PARSE_OVERFLOW,
} CC_F64ParseError;

typedef enum {
    CC_BOOL_PARSE_INVALID_VALUE = 1,
} CC_BoolParseError;

CC_DECL_RESULT_SPEC(CCResult_int64_t_CC_I64ParseError, int64_t, CC_I64ParseError)
CC_DECL_RESULT_SPEC(CCResult_uint64_t_CC_U64ParseError, uint64_t, CC_U64ParseError)
CC_DECL_RESULT_SPEC(CCResult_double_CC_F64ParseError, double, CC_F64ParseError)
CC_DECL_RESULT_SPEC(CCResult_bool_CC_BoolParseError, bool, CC_BoolParseError)

/* Legacy aliases for type names */
typedef CCResult_int64_t_CC_I64ParseError CCResultI64Parse;
typedef CCResult_uint64_t_CC_U64ParseError CCResultU64Parse;
typedef CCResult_double_CC_F64ParseError CCResultF64Parse;
typedef CCResult_bool_CC_BoolParseError CCResultBoolParse;

/* Legacy aliases for constructors */
#define cc_ok_CCResultI64Parse cc_ok_CCResult_int64_t_CC_I64ParseError
#define cc_err_CCResultI64Parse cc_err_CCResult_int64_t_CC_I64ParseError
#define cc_ok_CCResultU64Parse cc_ok_CCResult_uint64_t_CC_U64ParseError
#define cc_err_CCResultU64Parse cc_err_CCResult_uint64_t_CC_U64ParseError
#define cc_ok_CCResultF64Parse cc_ok_CCResult_double_CC_F64ParseError
#define cc_err_CCResultF64Parse cc_err_CCResult_double_CC_F64ParseError
#define cc_ok_CCResultBoolParse cc_ok_CCResult_bool_CC_BoolParseError
#define cc_err_CCResultBoolParse cc_err_CCResult_bool_CC_BoolParseError

// ------------------------- Slice helpers ----------------------------------

typedef struct {
    CCSlice *items;
    size_t len;
} CCSliceArray;

/*
 * Forward declarations for UFCS methods.
 * TCC parser mode needs these to avoid "cannot convert int to struct" errors
 * when it encounters UFCS calls like s.trim() before the UFCS pass rewrites them.
 * Using old-style function declarations (no params) to accept any arguments.
 */
#ifdef CC_PARSER_MODE
/* These dummy declarations tell TCC the return types for UFCS method names */
static CCSlice trim();
static CCSlice trim_left();
static CCSlice trim_right();
static CCSlice sub();
static char at();
static bool starts_with();
static bool ends_with();
/* len, is_empty, eq already return int/bool which matches TCC's implicit decl */
#endif

static inline bool cc_slice_is_ascii(CCSlice s) {
    const unsigned char *p = (const unsigned char *)s.ptr;
    for (size_t i = 0; i < s.len; ++i) {
        if (p[i] > 0x7F) return false;
    }
    return true;
}

static inline bool cc_slice_get(CCSlice s, size_t idx, char *out) {
    if (idx >= s.len || !s.ptr) return false;
    if (out) *out = ((char *)s.ptr)[idx];
    return true;
}

// Use cc_slice_sub from cc_slice.cch

static inline CCSlice cc_slice_clone(CCArena *arena, CCSlice s) {
    if (!arena || s.len == 0) return s.len == 0 ? cc_slice_empty() : s;
    void *buf = cc_arena_alloc(arena, s.len, sizeof(char));
    if (!buf) return cc_slice_empty();
    if (s.ptr && s.len) memcpy(buf, s.ptr, s.len);
    return cc_slice_from_parts(buf, s.len, CC_SLICE_ID_UNTRACKED, s.len);
}

static inline char *cc_slice_c_str(CCArena *arena, CCSlice s) {
    if (!arena) return NULL;
    char *buf = (char *)cc_arena_alloc(arena, s.len + 1, sizeof(char));
    if (!buf) return NULL;
    if (s.ptr && s.len) memcpy(buf, s.ptr, s.len);
    buf[s.len] = '\0';
    return buf;
}

static inline size_t cc_slice_index_of(CCSlice s, CCSlice needle, bool *found) {
    if (needle.len == 0 || needle.len > s.len) { if (found) *found = false; return 0; }
    const uint8_t *hay = (const uint8_t *)s.ptr;
    for (size_t i = 0; i + needle.len <= s.len; ++i) {
        if (memcmp(hay + i, needle.ptr, needle.len) == 0) {
            if (found) *found = true; return i;
        }
    }
    if (found) *found = false; return 0;
}

static inline size_t cc_slice_last_index_of(CCSlice s, CCSlice needle, bool *found) {
    if (needle.len == 0 || needle.len > s.len) { if (found) *found = false; return 0; }
    const uint8_t *hay = (const uint8_t *)s.ptr;
    for (size_t i = s.len - needle.len + 1; i-- > 0;) {
        if (memcmp(hay + i, needle.ptr, needle.len) == 0) {
            if (found) *found = true; return i;
        }
        if (i == 0) break;
    }
    if (found) *found = false; return 0;
}

static inline size_t cc_slice_count(CCSlice s, CCSlice needle) {
    bool found = false;
    size_t idx = 0, cnt = 0;
    while (idx < s.len) {
        size_t pos = cc_slice_index_of(cc_slice_sub(s, idx, s.len), needle, &found);
        if (!found) break;
        cnt++;
        idx += pos + (needle.len ? needle.len : 1);
        if (needle.len == 0) break;
    }
    return cnt;
}

static inline size_t cc__trim_left_idx(CCSlice s) {
    size_t i = 0;
    const unsigned char *p = (const unsigned char *)s.ptr;
    while (i < s.len && isspace(p[i])) i++;
    return i;
}

static inline size_t cc__trim_right_idx(CCSlice s) {
    if (s.len == 0) return 0;
    const unsigned char *p = (const unsigned char *)s.ptr;
    size_t i = s.len;
    while (i > 0 && isspace(p[i-1])) i--;
    return i;
}

static inline bool cc__in_set(char c, CCSlice set) {
    const char *p = (const char *)set.ptr;
    for (size_t i = 0; i < set.len; ++i) {
        if (p[i] == c) return true;
    }
    return false;
}

static inline CCSlice cc_slice_trim_set(CCSlice s, CCSlice chars) {
    size_t start = 0, end = s.len;
    const char *p = (const char *)s.ptr;
    while (start < end && cc__in_set(p[start], chars)) start++;
    while (end > start && cc__in_set(p[end-1], chars)) end--;
    return cc_slice_sub(s, start, end);
}

static inline CCSliceArray cc_slice_split_all(CCArena *arena, CCSlice s, CCSlice delim) {
    CCSliceArray arr = {0};
    if (!arena) return arr;
    if (delim.len == 0) {
        arr.len = 1;
        arr.items = (CCSlice *)cc_arena_alloc(arena, sizeof(CCSlice), sizeof(void*));
        if (arr.items) arr.items[0] = s;
        return arr;
    }
    size_t parts = 1 + cc_slice_count(s, delim);
    arr.items = (CCSlice *)cc_arena_alloc(arena, parts * sizeof(CCSlice), sizeof(void*));
    if (!arr.items) return arr;
    size_t idx = 0; size_t out = 0;
    while (idx <= s.len && out < parts) {
        bool found = false;
        size_t pos = cc_slice_index_of(cc_slice_sub(s, idx, s.len), delim, &found);
        if (!found) {
            arr.items[out++] = cc_slice_sub(s, idx, s.len);
            break;
        }
        arr.items[out++] = cc_slice_sub(s, idx, idx + pos);
        idx += pos + delim.len;
    }
    arr.len = out;
    return arr;
}

// ------------------------- String builder ---------------------------------

CCString cc_string_new(CCArena *arena);
CCString cc_string_from_slice(CCArena *arena, CCSlice slice);
CCString* cc_string_push(CCString *str, CCSlice data);
CCString* cc_string_clear(CCString *str);
CCSlice cc_string_as_slice(const CCString *str);
const char *cc_string_cstr(CCString *str);

static inline CCString* cc_string_push_char(CCString *str, char c) {
    CCSlice s = cc_slice_from_buffer(&c, 1);
    return cc_string_push(str, s);
}
static inline CCString* cc_string_push_int(CCString *str, int64_t v) {
    char buf[32];
    int n = snprintf(buf, sizeof(buf), "%lld", (long long)v);
    if (n < 0) return NULL;
    return cc_string_push(str, cc_slice_from_buffer(buf, (size_t)n));
}
static inline CCString* cc_string_push_uint(CCString *str, uint64_t v) {
    char buf[32];
    int n = snprintf(buf, sizeof(buf), "%llu", (unsigned long long)v);
    if (n < 0) return NULL;
    return cc_string_push(str, cc_slice_from_buffer(buf, (size_t)n));
}
static inline CCString* cc_string_push_float(CCString *str, double v) {
    char buf[64];
    int n = snprintf(buf, sizeof(buf), "%g", v);
    if (n < 0) return NULL;
    return cc_string_push(str, cc_slice_from_buffer(buf, (size_t)n));
}

// Convenience wrappers matching CC surface API (no explicit arena argument).
static inline CCString string_new(CCArena *arena) { return cc_string_new(arena); }
static inline CCString* string_append(CCString *str, const char *cstr) {
    if (!cstr) return str;
    CCSlice s = cc_slice_from_buffer((void *)cstr, strlen(cstr));
    return cc_string_push(str, s);
}
static inline CCSlice string_as_slice(const CCString *str) { return cc_string_as_slice(str); }

// ------------------------- Parse helpers ----------------------------------

static inline CCResultI64Parse cc_slice_parse_i64(CCSlice s, int base) {
    if (!s.ptr || s.len == 0) return cc_err_CCResultI64Parse(CC_I64_PARSE_INVALID_CHAR);
    char *end = NULL;
    char *buf = (char *)alloca(s.len + 1);
    memcpy(buf, s.ptr, s.len); buf[s.len] = '\0';
    errno = 0;
    long long v = strtoll(buf, &end, base);
    if (end == buf) return cc_err_CCResultI64Parse(CC_I64_PARSE_INVALID_CHAR);
    if ((v == LLONG_MAX || v == LLONG_MIN) && errno == ERANGE) {
        return cc_err_CCResultI64Parse(v == LLONG_MAX ? CC_I64_PARSE_OVERFLOW : CC_I64_PARSE_UNDERFLOW);
    }
    return cc_ok_CCResultI64Parse((int64_t)v);
}

static inline CCResultU64Parse cc_slice_parse_u64(CCSlice s, int base) {
    if (!s.ptr || s.len == 0) return cc_err_CCResultU64Parse(CC_U64_PARSE_INVALID_CHAR);
    char *end = NULL;
    char *buf = (char *)alloca(s.len + 1);
    memcpy(buf, s.ptr, s.len); buf[s.len] = '\0';
    errno = 0;
    unsigned long long v = strtoull(buf, &end, base);
    if (end == buf) return cc_err_CCResultU64Parse(CC_U64_PARSE_INVALID_CHAR);
    if (v == ULLONG_MAX && errno == ERANGE) {
        return cc_err_CCResultU64Parse(CC_U64_PARSE_OVERFLOW);
    }
    return cc_ok_CCResultU64Parse((uint64_t)v);
}

static inline CCResultF64Parse cc_slice_parse_f64(CCSlice s) {
    if (!s.ptr || s.len == 0) return cc_err_CCResultF64Parse(CC_F64_PARSE_INVALID_CHAR);
    char *end = NULL;
    char *buf = (char *)alloca(s.len + 1);
    memcpy(buf, s.ptr, s.len); buf[s.len] = '\0';
    errno = 0;
    double v = strtod(buf, &end);
    if (end == buf) return cc_err_CCResultF64Parse(CC_F64_PARSE_INVALID_CHAR);
    if ((v == HUGE_VAL || v == -HUGE_VAL) && errno == ERANGE) {
        return cc_err_CCResultF64Parse(CC_F64_PARSE_OVERFLOW);
    }
    return cc_ok_CCResultF64Parse(v);
}

static inline CCResultBoolParse cc_slice_parse_bool(CCSlice s) {
    static const char *true_lit = "true";
    static const char *false_lit = "false";
    if (s.len == 4 && memcmp(s.ptr, true_lit, 4) == 0) {
        return cc_ok_CCResultBoolParse(true);
    }
    if (s.len == 5 && memcmp(s.ptr, false_lit, 5) == 0) {
        return cc_ok_CCResultBoolParse(false);
    }
    return cc_err_CCResultBoolParse(CC_BOOL_PARSE_INVALID_VALUE);
}

// ------------------------- Hash helpers ------------------------------------

static inline uint64_t cc_fnv1a64(const void *data, size_t len) {
    const uint8_t *p = (const uint8_t *)data;
    uint64_t hash = 14695981039346656037ULL;
    for (size_t i = 0; i < len; ++i) {
        hash ^= p[i];
        hash *= 1099511628211ULL;
    }
    return hash;
}

static inline uint64_t cc_slice_hash64(CCSlice s) {
    if (!s.ptr || s.len == 0) return 0xcbf29ce484222325ULL;
    return cc_fnv1a64(s.ptr, s.len);
}

static inline bool cc__slice_eq(CCSlice a, CCSlice b) {
    if (a.len != b.len) return false;
    if (a.ptr == b.ptr) return true;
    if (!a.ptr || !b.ptr) return false;
    return memcmp(a.ptr, b.ptr, a.len) == 0;
}

/*
 * UFCS-compatible slice methods.
 * These allow: s.len(), s.trim(), s.at(i), etc.
 * UFCS transforms s.method() to CCSlice_method(&s).
 */
static inline size_t CCSlice_len(CCSlice* s) { return s ? s->len : 0; }
static inline CCSlice CCSlice_trim(CCSlice* s) {
    if (!s) return cc_slice_empty();
    size_t start = cc__trim_left_idx(*s);
    CCSlice sub = cc_slice_sub(*s, start, s->len);
    size_t end = cc__trim_right_idx(sub);
    return cc_slice_sub(sub, 0, end);
}
static inline CCSlice CCSlice_trim_left(CCSlice* s) {
    return s ? cc_slice_sub(*s, cc__trim_left_idx(*s), s->len) : cc_slice_empty();
}
static inline CCSlice CCSlice_trim_right(CCSlice* s) {
    if (!s) return cc_slice_empty();
    size_t end = cc__trim_right_idx(*s);
    return cc_slice_sub(*s, 0, end);
}
static inline bool CCSlice_is_empty(CCSlice* s) { return !s || s->len == 0; }
static inline char CCSlice_at(CCSlice* s, size_t idx) { 
    if (!s || idx >= s->len || !s->ptr) return 0;
    return ((char*)s->ptr)[idx];
}
static inline CCSlice CCSlice_sub(CCSlice* s, size_t start, size_t end) {
    return s ? cc_slice_sub(*s, start, end) : cc_slice_empty();
}
static inline bool CCSlice_starts_with(CCSlice* s, CCSlice prefix) {
    return s && s->len >= prefix.len && memcmp(s->ptr, prefix.ptr, prefix.len) == 0;
}
static inline bool CCSlice_ends_with(CCSlice* s, CCSlice suffix) {
    return s && s->len >= suffix.len &&
        memcmp((uint8_t *)s->ptr + (s->len - suffix.len), suffix.ptr, suffix.len) == 0;
}
static inline bool CCSlice_eq(CCSlice* s, CCSlice other) {
    return s && cc__slice_eq(*s, other);
}

#endif // CC_STD_STRING_H

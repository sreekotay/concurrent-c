/*
 * Arena-backed dynamic vector for Concurrent-C stdlib.
 * 
 * Design:
 * - 2x growth factor (optimal for arena allocation - no memory reuse benefit from 1.5x)
 * - Initial capacity of 8 (skips 2â†’4 dance for common cases)
 * - Growth allocates in arena; old buffers reclaimed on arena reset
 * - Fails gracefully when arena exhausted
 *
 * Optional heap-backed variant provided via CC_VEC_DECL_HEAP for tools/tests.
 *
 * Spec-compliant API:
 * - Name_get(v, i) returns T? (optional, None if out of bounds)
 * - Name_get_ptr(v, i) returns T* (mutable access, NULL if out of bounds)
 * - Name_pop(v) returns T? (optional, None if empty)
 */
#ifndef CC_STD_VEC_H
#define CC_STD_VEC_H

#include <stddef.h>
#include <string.h>
#include <ccc/cc_runtime.cch>
#include <ccc/cc_optional.cch>

/* Default initial capacity - skip tiny allocations */
#ifndef CC_VEC_INITIAL_CAP
#define CC_VEC_INITIAL_CAP 8
#endif

/*
 * CC_VEC_DECL_ARENA_FULL(T, Name, OptT)
 * 
 * Full arena-backed vector with optional-returning methods.
 * OptT is the optional type for T (e.g., CCOptional_int for int).
 * 
 * API:
 * - Name_init(arena, initial_cap) -> Name
 * - Name_push(v, value) -> 0 on success, -1 on failure
 * - Name_pop(v) -> OptT (None if empty)
 * - Name_get(v, i) -> OptT (None if out of bounds)
 * - Name_get_ptr(v, i) -> T* (mutable access, NULL if out of bounds)
 * - Name_at_grow(v, i) -> T* (auto-extends if needed)
 * - Name_push_ptr(v) -> T* (push slot, returns pointer)
 * - Name_len(v), Name_cap(v)
 * - Name_begin(v), Name_end(v)
 * - Name_clear(v)
 */
#define CC_VEC_DECL_ARENA_FULL(T, Name, OptT)                                     \
    typedef struct {                                                              \
        size_t len;                                                               \
        size_t cap;                                                               \
        T *data;                                                                  \
        CCArena *arena;                                                           \
    } Name;                                                                       \
                                                                                  \
    static inline Name Name##_init(CCArena *arena, size_t initial_cap) {          \
        Name v = {0, 0, NULL, arena};                                             \
        if (!arena) return v;                                                     \
        size_t cap = initial_cap > 0 ? initial_cap : CC_VEC_INITIAL_CAP;          \
        v.data = (T *)cc_arena_alloc(arena, cap * sizeof(T), _Alignof(T));        \
        if (!v.data) { v.cap = 0; return v; }                                     \
        v.cap = cap;                                                              \
        return v;                                                                 \
    }                                                                             \
                                                                                  \
    static inline int Name##_reserve(Name *v, size_t need) {                      \
        if (!v || !v->arena) return -1;                                           \
        if (need <= v->cap) return 0;                                             \
        size_t new_cap = v->cap ? v->cap : CC_VEC_INITIAL_CAP;                    \
        while (new_cap < need) new_cap <<= 1;                                     \
        T *new_data = (T *)cc_arena_alloc(v->arena, new_cap * sizeof(T), _Alignof(T));\
        if (!new_data) return -1;                                                 \
        if (v->data && v->len) memcpy(new_data, v->data, v->len * sizeof(T));     \
        v->data = new_data;                                                       \
        v->cap = new_cap;                                                         \
        return 0;                                                                 \
    }                                                                             \
                                                                                  \
    static inline int Name##_push(Name *v, T value) {                             \
        if (!v) return -1;                                                        \
        if (v->len == v->cap) {                                                   \
            if (Name##_reserve(v, v->cap ? v->cap << 1 : CC_VEC_INITIAL_CAP) != 0)\
                return -1;                                                        \
        }                                                                         \
        v->data[v->len++] = value;                                                \
        return 0;                                                                 \
    }                                                                             \
                                                                                  \
    /* Push and return pointer to new slot (kvec's kv_pushp equivalent) */        \
    static inline T* Name##_push_ptr(Name *v) {                                   \
        if (!v) return NULL;                                                      \
        if (v->len == v->cap) {                                                   \
            if (Name##_reserve(v, v->cap ? v->cap << 1 : CC_VEC_INITIAL_CAP) != 0)\
                return NULL;                                                      \
        }                                                                         \
        return &v->data[v->len++];                                                \
    }                                                                             \
                                                                                  \
    /* Pop: returns optional (None if empty) */                                   \
    static inline OptT Name##_pop(Name *v) {                                      \
        OptT result = {0};                                                        \
        if (!v || v->len == 0) return result;                                     \
        v->len--;                                                                 \
        result.has = 1;                                                           \
        result.u.value = v->data[v->len];                                         \
        return result;                                                            \
    }                                                                             \
                                                                                  \
    /* Bounds-safe get: returns optional (None if out of bounds) */               \
    static inline OptT Name##_get(Name *v, size_t i) {                            \
        OptT result = {0};                                                        \
        if (!v || i >= v->len) return result;                                     \
        result.has = 1;                                                           \
        result.u.value = v->data[i];                                              \
        return result;                                                            \
    }                                                                             \
                                                                                  \
    /* Mutable pointer access: returns pointer or NULL */                         \
    static inline T* Name##_get_ptr(Name *v, size_t i) {                          \
        if (!v || i >= v->len) return NULL;                                       \
        return &v->data[i];                                                       \
    }                                                                             \
                                                                                  \
    /* Auto-extending indexing (kvec's kv_a equivalent) */                        \
    static inline T* Name##_at_grow(Name *v, size_t i) {                          \
        if (!v) return NULL;                                                      \
        if (i >= v->cap) {                                                        \
            size_t new_cap = v->cap ? v->cap : CC_VEC_INITIAL_CAP;                \
            while (new_cap <= i) new_cap <<= 1;                                   \
            if (Name##_reserve(v, new_cap) != 0) return NULL;                     \
        }                                                                         \
        if (i >= v->len) v->len = i + 1;                                          \
        return &v->data[i];                                                       \
    }                                                                             \
                                                                                  \
    static inline void Name##_clear(Name *v) {                                    \
        if (v) v->len = 0;                                                        \
    }                                                                             \
                                                                                  \
    static inline size_t Name##_len(const Name *v) { return v ? v->len : 0; }     \
    static inline size_t Name##_cap(const Name *v) { return v ? v->cap : 0; }     \
    static inline T *Name##_begin(Name *v) { return v ? v->data : NULL; }         \
    static inline T *Name##_end(Name *v) { return v ? v->data + v->len : NULL; }  \
    static inline T *Name##_data(Name *v) { return v ? v->data : NULL; }

/*
 * CC_VEC_DECL_ARENA(T, Name)
 * 
 * Convenience macro for simple types where OptT = CCOptional_##T.
 * For complex types (pointers, structs), use CC_VEC_DECL_ARENA_FULL.
 */
#define CC_VEC_DECL_ARENA(T, Name) CC_VEC_DECL_ARENA_FULL(T, Name, CCOptional_##T)

/* Iteration helper */
#define CC_VEC_FOREACH(vptr, idx_var, item_var)                                   \
    for (size_t idx_var = 0; (vptr) && idx_var < (vptr)->len && (((item_var) = (vptr)->data[idx_var]), 1); ++idx_var)

/*
 * CC_VEC_DECL_HEAP_FULL(T, Name, OptT)
 * 
 * Heap-backed vector (tool/test-only; not arena-scoped) with optional returns.
 */
#define CC_VEC_DECL_HEAP_FULL(T, Name, OptT)                                      \
    typedef struct { size_t len, cap; T *data; } Name;                            \
    static inline Name Name##_init(void) { Name v = {0,0,NULL}; return v; }       \
    static inline void Name##_free(Name *v) {                                     \
        if (v && v->data) free(v->data);                                          \
        if (v) { v->data = NULL; v->len = v->cap = 0; }                           \
    }                                                                             \
    static inline int Name##_reserve(Name *v, size_t need) {                      \
        if (!v) return -1;                                                        \
        if (need <= v->cap) return 0;                                             \
        size_t new_cap = v->cap ? v->cap : CC_VEC_INITIAL_CAP;                    \
        while (new_cap < need) new_cap <<= 1;                                     \
        void *p = realloc(v->data, new_cap * sizeof(T));                          \
        if (!p) return -1;                                                        \
        v->data = (T *)p; v->cap = new_cap; return 0;                             \
    }                                                                             \
    static inline int Name##_push(Name *v, T value) {                             \
        if (!v) return -1;                                                        \
        if (v->len == v->cap) {                                                   \
            if (Name##_reserve(v, v->cap ? v->cap << 1 : CC_VEC_INITIAL_CAP) != 0)\
                return -1;                                                        \
        }                                                                         \
        v->data[v->len++] = value;                                                \
        return 0;                                                                 \
    }                                                                             \
    static inline T* Name##_push_ptr(Name *v) {                                   \
        if (!v) return NULL;                                                      \
        if (v->len == v->cap) {                                                   \
            if (Name##_reserve(v, v->cap ? v->cap << 1 : CC_VEC_INITIAL_CAP) != 0)\
                return NULL;                                                      \
        }                                                                         \
        return &v->data[v->len++];                                                \
    }                                                                             \
    static inline OptT Name##_pop(Name *v) {                                      \
        OptT result = {0};                                                        \
        if (!v || v->len == 0) return result;                                     \
        v->len--;                                                                 \
        result.has = 1;                                                           \
        result.u.value = v->data[v->len];                                         \
        return result;                                                            \
    }                                                                             \
    static inline OptT Name##_get(Name *v, size_t i) {                            \
        OptT result = {0};                                                        \
        if (!v || i >= v->len) return result;                                     \
        result.has = 1;                                                           \
        result.u.value = v->data[i];                                              \
        return result;                                                            \
    }                                                                             \
    static inline T* Name##_get_ptr(Name *v, size_t i) {                          \
        if (!v || i >= v->len) return NULL;                                       \
        return &v->data[i];                                                       \
    }                                                                             \
    static inline T* Name##_at_grow(Name *v, size_t i) {                          \
        if (!v) return NULL;                                                      \
        if (i >= v->cap) {                                                        \
            size_t new_cap = v->cap ? v->cap : CC_VEC_INITIAL_CAP;                \
            while (new_cap <= i) new_cap <<= 1;                                   \
            if (Name##_reserve(v, new_cap) != 0) return NULL;                     \
        }                                                                         \
        if (i >= v->len) v->len = i + 1;                                          \
        return &v->data[i];                                                       \
    }                                                                             \
    static inline void Name##_clear(Name *v) { if (v) v->len = 0; }               \
    static inline size_t Name##_len(const Name *v) { return v ? v->len : 0; }     \
    static inline size_t Name##_cap(const Name *v) { return v ? v->cap : 0; }     \
    static inline T *Name##_begin(Name *v) { return v ? v->data : NULL; }         \
    static inline T *Name##_end(Name *v) { return v ? v->data + v->len : NULL; }  \
    static inline T *Name##_data(Name *v) { return v ? v->data : NULL; }

#define CC_VEC_DECL_HEAP(T, Name) CC_VEC_DECL_HEAP_FULL(T, Name, CCOptional_##T)

/* Legacy alias for compatibility */
#define Vec(T, Name) CC_VEC_DECL_ARENA(T, Name)

#endif /* CC_STD_VEC_H */

/*
 * Arena-backed dynamic vector for Concurrent-C stdlib.
 * 
 * Design:
 * - 2x growth factor (optimal for arena allocation - no memory reuse benefit from 1.5x)
 * - Initial capacity of 8 (skips 2â†’4 dance for common cases)
 * - Growth allocates in arena; old buffers reclaimed on arena reset
 * - Fails gracefully when arena exhausted
 *
 * Optional heap-backed variant provided via CC_VEC_DECL_HEAP for tools/tests.
 *
 * Spec-compliant API:
 * - Name_get(v, i) returns T? (optional, None if out of bounds)
 * - Name_get_ptr(v, i) returns T* (mutable access, NULL if out of bounds)
 * - Name_pop(v) returns T? (optional, None if empty)
 */
#ifndef CC_STD_VEC_H
#define CC_STD_VEC_H

#include <stddef.h>
#include <string.h>
#include <ccc/cc_runtime.cch>
#include <ccc/cc_optional.cch>  /* Must be before parser mode block for __CCOptionalGeneric */

/* Default initial capacity - skip tiny allocations */
#ifndef CC_VEC_INITIAL_CAP
#define CC_VEC_INITIAL_CAP 8
#endif

/*
 * TCC PARSER MODE: Vec types use a generic placeholder during parsing.
 *
 * The CC preprocessor rewrites Vec<T> to __CC_VEC(T_mangled).
 * In parser mode, this macro expands to __CCVecGeneric.
 * In codegen, it's rewritten to Vec_T with proper declarations emitted.
 */
#ifdef CC_PARSER_MODE

/* Generic Vec placeholder struct for parser mode - any element type.
   Field names match real Vec layout so field access compiles.
   Guard allows cccn parse stubs to predefine this. */
#ifndef __CC_VEC_GENERIC_DEFINED
#define __CC_VEC_GENERIC_DEFINED
typedef struct __CCVecGeneric {
    size_t len;
    size_t cap;
    void *data;
    void *arena;  /* CCArena* */
} __CCVecGeneric;
#endif

/* THE KEY MACRO: In parser mode, all Vec types resolve to generic.
   Usage: __CC_VEC(int) expands to __CCVecGeneric
   Codegen rewrites this to Vec_int */
#ifndef __CC_VEC
#define __CC_VEC(T) __CCVecGeneric
#endif

/* Generic constructor - parser mode doesn't actually run,
   so just return a zeroed struct for type checking. */
static inline __CCVecGeneric __cc_vec_generic_init(void *arena) {
    __CCVecGeneric v = {0, 0, NULL, arena};
    return v;
}

/* Macro-based init that accepts any type - parser mode just validates types. */
#define __CC_VEC_INIT(T, arena) __cc_vec_generic_init((void*)(arena))

/* Parser-mode method stubs - just need to type-check, not actually run.
   get() and pop() return __CCOptionalGeneric to match real Vec_T_get/pop signatures. */
static inline int __cc_vec_generic_push(__CCVecGeneric *v, ...) { 
    (void)v; 
    return 0; 
}
static inline __CCOptionalGeneric __cc_vec_generic_get(__CCVecGeneric *v, size_t i) { 
    (void)v; (void)i; 
    __CCOptionalGeneric result = {0};
    return result; 
}
static inline void* __cc_vec_generic_get_ptr(__CCVecGeneric *v, size_t i) { 
    (void)v; (void)i; 
    return NULL; 
}
static inline __CCOptionalGeneric __cc_vec_generic_pop(__CCVecGeneric *v) { 
    (void)v; 
    __CCOptionalGeneric result = {0};
    return result; 
}
static inline void* __cc_vec_generic_at_grow(__CCVecGeneric *v, size_t i) { 
    (void)v; (void)i; 
    return NULL; 
}
static inline void* __cc_vec_generic_push_ptr(__CCVecGeneric *v) { 
    (void)v; 
    return NULL; 
}
static inline int __cc_vec_generic_reserve(__CCVecGeneric *v, size_t n) { 
    (void)v; (void)n; 
    return 0; 
}
static inline void __cc_vec_generic_clear(__CCVecGeneric *v) { 
    (void)v; 
}
static inline size_t __cc_vec_generic_len(const __CCVecGeneric *v) { 
    return v ? v->len : 0; 
}
static inline size_t __cc_vec_generic_cap(const __CCVecGeneric *v) { 
    return v ? v->cap : 0; 
}
static inline void* __cc_vec_generic_begin(__CCVecGeneric *v) { 
    return v ? v->data : NULL; 
}
static inline void* __cc_vec_generic_end(__CCVecGeneric *v) { 
    return v ? (char*)v->data + v->len : NULL; 
}
static inline void* __cc_vec_generic_data(__CCVecGeneric *v) { 
    return v ? v->data : NULL; 
}

/* Parser-mode: common Vec types are aliases to __CCVecGeneric */
typedef __CCVecGeneric Vec_int;
typedef __CCVecGeneric Vec_char;
typedef __CCVecGeneric Vec_size_t;
typedef __CCVecGeneric Vec_float;
typedef __CCVecGeneric Vec_double;
typedef __CCVecGeneric Vec_voidptr;
typedef __CCVecGeneric Vec_charptr;
typedef __CCVecGeneric Vec_intptr;

/* Parser-mode: function aliases for common Vec types.
   Maps Vec_T_method to generic stubs so direct function calls compile.
   Uses macros since we can't do function aliasing in C. */
#define Vec_int_init(a, c)     __cc_vec_generic_init((void*)(a))
#define Vec_int_push(v, x)     __cc_vec_generic_push((v), (x))
#define Vec_int_pop(v)         __cc_vec_generic_pop((v))
#define Vec_int_get(v, i)      __cc_vec_generic_get((v), (i))
#define Vec_int_get_ptr(v, i)  __cc_vec_generic_get_ptr((v), (i))
#define Vec_int_at_grow(v, i)  __cc_vec_generic_at_grow((v), (i))
#define Vec_int_push_ptr(v)    __cc_vec_generic_push_ptr((v))
#define Vec_int_reserve(v, n)  __cc_vec_generic_reserve((v), (n))
#define Vec_int_clear(v)       __cc_vec_generic_clear((v))
#define Vec_int_len(v)         __cc_vec_generic_len((v))
#define Vec_int_cap(v)         __cc_vec_generic_cap((v))
#define Vec_int_begin(v)       __cc_vec_generic_begin((v))
#define Vec_int_end(v)         __cc_vec_generic_end((v))
#define Vec_int_data(v)        __cc_vec_generic_data((v))

#define Vec_char_init(a, c)    __cc_vec_generic_init((void*)(a))
#define Vec_char_push(v, x)    __cc_vec_generic_push((v), (x))
#define Vec_char_pop(v)        __cc_vec_generic_pop((v))
#define Vec_char_get(v, i)     __cc_vec_generic_get((v), (i))
#define Vec_char_get_ptr(v, i) __cc_vec_generic_get_ptr((v), (i))
#define Vec_char_len(v)        __cc_vec_generic_len((v))
#define Vec_char_data(v)       __cc_vec_generic_data((v))

#define Vec_size_t_init(a, c)  __cc_vec_generic_init((void*)(a))
#define Vec_size_t_push(v, x)  __cc_vec_generic_push((v), (x))
#define Vec_size_t_get(v, i)   __cc_vec_generic_get((v), (i))
#define Vec_size_t_len(v)      __cc_vec_generic_len((v))

#else /* !CC_PARSER_MODE - real compilation */

/* In real compilation, __CC_VEC expands to the actual type name.
   The codegen pass ensures CC_VEC_DECL_ARENA is emitted for each type. */
#define __CC_VEC(T) Vec_##T

/* In real mode, init calls the generated type-specific function */
#define __CC_VEC_INIT(T, arena) Vec_##T##_init((arena), CC_VEC_INITIAL_CAP)

#endif /* CC_PARSER_MODE */

/*
 * CC_VEC_DECLARE_GUARDED(T, Name)
 *
 * Helper macro that wraps CC_VEC_DECL_ARENA with a guard to prevent
 * duplicate declarations. Uses __CC_VEC_##Name##_DECLARED as the guard.
 */
#define CC_VEC_DECLARE_GUARDED(T, Name) \
    CC_VEC_DECLARE_GUARDED_FULL(T, Name, CCOptional_##T)

#define CC_VEC_DECLARE_GUARDED_FULL(T, Name, OptT) \
    CC_VEC_DECL_ARENA_FULL(T, Name, OptT)

/*
 * CC_VEC_DECL_ARENA_FULL(T, Name, OptT)
 * 
 * Full arena-backed vector with optional-returning methods.
 * OptT is the optional type for T (e.g., CCOptional_int for int).
 * 
 * API:
 * - Name_init(arena, initial_cap) -> Name
 * - Name_push(v, value) -> 0 on success, -1 on failure
 * - Name_pop(v) -> OptT (None if empty)
 * - Name_get(v, i) -> OptT (None if out of bounds)
 * - Name_get_ptr(v, i) -> T* (mutable access, NULL if out of bounds)
 * - Name_at_grow(v, i) -> T* (auto-extends if needed)
 * - Name_push_ptr(v) -> T* (push slot, returns pointer)
 * - Name_len(v), Name_cap(v)
 * - Name_begin(v), Name_end(v)
 * - Name_clear(v)
 */
#define CC_VEC_DECL_ARENA_FULL(T, Name, OptT)                                     \
    typedef struct {                                                              \
        size_t len;                                                               \
        size_t cap;                                                               \
        T *data;                                                                  \
        CCArena *arena;                                                           \
    } Name;                                                                       \
                                                                                  \
    static inline Name Name##_init(CCArena *arena, size_t initial_cap) {          \
        Name v = {0, 0, NULL, arena};                                             \
        if (!arena) return v;                                                     \
        size_t cap = initial_cap > 0 ? initial_cap : CC_VEC_INITIAL_CAP;          \
        v.data = (T *)cc_arena_alloc(arena, cap * sizeof(T), _Alignof(T));        \
        if (!v.data) { v.cap = 0; return v; }                                     \
        v.cap = cap;                                                              \
        return v;                                                                 \
    }                                                                             \
                                                                                  \
    static inline int Name##_reserve(Name *v, size_t need) {                      \
        if (!v || !v->arena) return -1;                                           \
        if (need <= v->cap) return 0;                                             \
        size_t new_cap = v->cap ? v->cap : CC_VEC_INITIAL_CAP;                    \
        while (new_cap < need) new_cap <<= 1;                                     \
        T *new_data = (T *)cc_arena_alloc(v->arena, new_cap * sizeof(T), _Alignof(T));\
        if (!new_data) return -1;                                                 \
        if (v->data && v->len) memcpy(new_data, v->data, v->len * sizeof(T));     \
        v->data = new_data;                                                       \
        v->cap = new_cap;                                                         \
        return 0;                                                                 \
    }                                                                             \
                                                                                  \
    static inline int Name##_push(Name *v, T value) {                             \
        if (!v) return -1;                                                        \
        if (v->len == v->cap) {                                                   \
            if (Name##_reserve(v, v->cap ? v->cap << 1 : CC_VEC_INITIAL_CAP) != 0)\
                return -1;                                                        \
        }                                                                         \
        v->data[v->len++] = value;                                                \
        return 0;                                                                 \
    }                                                                             \
                                                                                  \
    /* Push and return pointer to new slot (kvec's kv_pushp equivalent) */        \
    static inline T* Name##_push_ptr(Name *v) {                                   \
        if (!v) return NULL;                                                      \
        if (v->len == v->cap) {                                                   \
            if (Name##_reserve(v, v->cap ? v->cap << 1 : CC_VEC_INITIAL_CAP) != 0)\
                return NULL;                                                      \
        }                                                                         \
        return &v->data[v->len++];                                                \
    }                                                                             \
                                                                                  \
    /* Pop: returns optional (None if empty) */                                   \
    static inline OptT Name##_pop(Name *v) {                                      \
        OptT result = {0};                                                        \
        if (!v || v->len == 0) return result;                                     \
        v->len--;                                                                 \
        result.has = 1;                                                           \
        CC_OPT_SET_VALUE(result, v->data[v->len]);                                \
        return result;                                                            \
    }                                                                             \
                                                                                  \
    /* Bounds-safe get: returns optional (None if out of bounds) */               \
    static inline OptT Name##_get(Name *v, size_t i) {                            \
        OptT result = {0};                                                        \
        if (!v || i >= v->len) return result;                                     \
        result.has = 1;                                                           \
        CC_OPT_SET_VALUE(result, v->data[i]);                                     \
        return result;                                                            \
    }                                                                             \
                                                                                  \
    /* Mutable pointer access: returns pointer or NULL */                         \
    static inline T* Name##_get_ptr(Name *v, size_t i) {                          \
        if (!v || i >= v->len) return NULL;                                       \
        return &v->data[i];                                                       \
    }                                                                             \
                                                                                  \
    /* Auto-extending indexing (kvec's kv_a equivalent) */                        \
    static inline T* Name##_at_grow(Name *v, size_t i) {                          \
        if (!v) return NULL;                                                      \
        if (i >= v->cap) {                                                        \
            size_t new_cap = v->cap ? v->cap : CC_VEC_INITIAL_CAP;                \
            while (new_cap <= i) new_cap <<= 1;                                   \
            if (Name##_reserve(v, new_cap) != 0) return NULL;                     \
        }                                                                         \
        if (i >= v->len) v->len = i + 1;                                          \
        return &v->data[i];                                                       \
    }                                                                             \
                                                                                  \
    static inline void Name##_clear(Name *v) {                                    \
        if (v) v->len = 0;                                                        \
    }                                                                             \
                                                                                  \
    static inline size_t Name##_len(const Name *v) { return v ? v->len : 0; }     \
    static inline size_t Name##_cap(const Name *v) { return v ? v->cap : 0; }     \
    static inline T *Name##_begin(Name *v) { return v ? v->data : NULL; }         \
    static inline T *Name##_end(Name *v) { return v ? v->data + v->len : NULL; }  \
    static inline T *Name##_data(Name *v) { return v ? v->data : NULL; }

/*
 * CC_VEC_DECL_ARENA(T, Name)
 * 
 * Convenience macro for simple types where OptT = CCOptional_##T.
 * For complex types (pointers, structs), use CC_VEC_DECL_ARENA_FULL.
 */
#define CC_VEC_DECL_ARENA(T, Name) CC_VEC_DECL_ARENA_FULL(T, Name, CCOptional_##T)

/* Iteration helper */
#define CC_VEC_FOREACH(vptr, idx_var, item_var)                                   \
    for (size_t idx_var = 0; (vptr) && idx_var < (vptr)->len && (((item_var) = (vptr)->data[idx_var]), 1); ++idx_var)

/*
 * CC_VEC_DECL_HEAP_FULL(T, Name, OptT)
 * 
 * Heap-backed vector (tool/test-only; not arena-scoped) with optional returns.
 */
#define CC_VEC_DECL_HEAP_FULL(T, Name, OptT)                                      \
    typedef struct { size_t len, cap; T *data; } Name;                            \
    static inline Name Name##_init(void) { Name v = {0,0,NULL}; return v; }       \
    static inline void Name##_free(Name *v) {                                     \
        if (v && v->data) free(v->data);                                          \
        if (v) { v->data = NULL; v->len = v->cap = 0; }                           \
    }                                                                             \
    static inline int Name##_reserve(Name *v, size_t need) {                      \
        if (!v) return -1;                                                        \
        if (need <= v->cap) return 0;                                             \
        size_t new_cap = v->cap ? v->cap : CC_VEC_INITIAL_CAP;                    \
        while (new_cap < need) new_cap <<= 1;                                     \
        void *p = realloc(v->data, new_cap * sizeof(T));                          \
        if (!p) return -1;                                                        \
        v->data = (T *)p; v->cap = new_cap; return 0;                             \
    }                                                                             \
    static inline int Name##_push(Name *v, T value) {                             \
        if (!v) return -1;                                                        \
        if (v->len == v->cap) {                                                   \
            if (Name##_reserve(v, v->cap ? v->cap << 1 : CC_VEC_INITIAL_CAP) != 0)\
                return -1;                                                        \
        }                                                                         \
        v->data[v->len++] = value;                                                \
        return 0;                                                                 \
    }                                                                             \
    static inline T* Name##_push_ptr(Name *v) {                                   \
        if (!v) return NULL;                                                      \
        if (v->len == v->cap) {                                                   \
            if (Name##_reserve(v, v->cap ? v->cap << 1 : CC_VEC_INITIAL_CAP) != 0)\
                return NULL;                                                      \
        }                                                                         \
        return &v->data[v->len++];                                                \
    }                                                                             \
    static inline OptT Name##_pop(Name *v) {                                      \
        OptT result = {0};                                                        \
        if (!v || v->len == 0) return result;                                     \
        v->len--;                                                                 \
        result.has = 1;                                                           \
        CC_OPT_SET_VALUE(result, v->data[v->len]);                                \
        return result;                                                            \
    }                                                                             \
    static inline OptT Name##_get(Name *v, size_t i) {                            \
        OptT result = {0};                                                        \
        if (!v || i >= v->len) return result;                                     \
        result.has = 1;                                                           \
        CC_OPT_SET_VALUE(result, v->data[i]);                                     \
        return result;                                                            \
    }                                                                             \
    static inline T* Name##_get_ptr(Name *v, size_t i) {                          \
        if (!v || i >= v->len) return NULL;                                       \
        return &v->data[i];                                                       \
    }                                                                             \
    static inline T* Name##_at_grow(Name *v, size_t i) {                          \
        if (!v) return NULL;                                                      \
        if (i >= v->cap) {                                                        \
            size_t new_cap = v->cap ? v->cap : CC_VEC_INITIAL_CAP;                \
            while (new_cap <= i) new_cap <<= 1;                                   \
            if (Name##_reserve(v, new_cap) != 0) return NULL;                     \
        }                                                                         \
        if (i >= v->len) v->len = i + 1;                                          \
        return &v->data[i];                                                       \
    }                                                                             \
    static inline void Name##_clear(Name *v) { if (v) v->len = 0; }               \
    static inline size_t Name##_len(const Name *v) { return v ? v->len : 0; }     \
    static inline size_t Name##_cap(const Name *v) { return v ? v->cap : 0; }     \
    static inline T *Name##_begin(Name *v) { return v ? v->data : NULL; }         \
    static inline T *Name##_end(Name *v) { return v ? v->data + v->len : NULL; }  \
    static inline T *Name##_data(Name *v) { return v ? v->data : NULL; }

#define CC_VEC_DECL_HEAP(T, Name) CC_VEC_DECL_HEAP_FULL(T, Name, CCOptional_##T)

/* Legacy alias for compatibility */
#define Vec(T, Name) CC_VEC_DECL_ARENA(T, Name)

#endif /* CC_STD_VEC_H */

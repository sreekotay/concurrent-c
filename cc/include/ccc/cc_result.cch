/*
 * Generic Result helpers for generated C.
 *
 * TYPE MACROS (defined in cc_optional.cch):
 *   CCRes(T, E)        - CCResult_T_E
 *   CCResPtr(T, E)     - CCResult_Tptr_E
 *
 * IDIOMATIC USAGE:
 *   CCRes(CCSlice, CCIoError) res = cc_file_read(...);
 *   if (cc_is_err(res)) {
 *       CCIoError err = cc_unwrap_err(res);
 *       handle_error(err);
 *       return;
 *   }
 *   CCSlice data = cc_unwrap(res);
 *
 * HELPERS:
 *   cc_is_ok(res)      - true if success
 *   cc_is_err(res)     - true if error
 *   cc_unwrap(res)     - get value (aborts if error)
 *   cc_unwrap_err(res) - get error (aborts if ok)
 *
 * AVOID: Direct field access like res.u.value or res.u.error
 *
 * Layout: struct { bool ok; union { T value; E error; } u; }
 */
#ifndef CC_RESULT_H
#define CC_RESULT_H

#ifndef __has_include
#define __has_include(x) 0
#endif
#if __has_include(<stdbool.h>)
#include <stdbool.h>
#else
#ifndef __bool_true_false_are_defined
typedef int bool;
#define true 1
#define false 0
#define __bool_true_false_are_defined 1
#endif
#endif

/* Common error type - a simple tagged enum with message */
typedef enum {
    CC_ERR_NONE = 0,
    CC_ERR_IO,
    CC_ERR_PARSE,
    CC_ERR_TIMEOUT,
    CC_ERR_CANCELLED,
    CC_ERR_INVALID_ARG,
    CC_ERR_OUT_OF_MEMORY,
    CC_ERR_NOT_FOUND,
    CC_ERR_PERMISSION,
    CC_ERR_ALREADY_EXISTS,
    CC_ERR_WOULD_BLOCK,
    CC_ERR_CLOSED,
    CC_ERR_OVERFLOW,
    CC_ERR_UNDERFLOW,
    CC_ERR_USER = 1000  /* User-defined errors start here */
} CCErrorKind;

typedef struct CCError {
    CCErrorKind kind;
    const char* message;  /* May be NULL */
} CCError;

/* Helper to construct errors */
static inline CCError cc_error(CCErrorKind kind, const char* msg) {
    CCError e = { kind, msg };
    return e;
}

/*
 * LEGACY LAYOUT: CC_DECL_RESULT
 * Used by existing runtime code (std/io.cch, etc.)
 * Access pattern: r.is_err, r.ok, r.err
 */
#define CC_DECL_RESULT(name, OkType, ErrType)                                       \
    typedef struct {                                                                \
        bool is_err;                                                                \
        union {                                                                     \
            OkType ok;                                                              \
            ErrType err;                                                            \
        };                                                                          \
    } name;                                                                         \
    static inline name cc_ok_##name(OkType value) {                                 \
        name r;                                                                     \
        r.is_err = false;                                                           \
        r.ok = value;                                                               \
        return r;                                                                   \
    }                                                                               \
    static inline name cc_err_##name(ErrType error) {                               \
        name r;                                                                     \
        r.is_err = true;                                                            \
        r.err = error;                                                              \
        return r;                                                                   \
    }

/*
 * Result type layout:
 *   r.ok       - true if success
 *   r.u.value  - the success value (when ok is true)
 *   r.u.error  - the error value (when ok is false)
 *
 * Uses named union 'u' for TCC compatibility.
 *
 * UFCS methods (via Type_method pattern):
 *   r.unwrap()    - returns value or aborts if error
 *   r.is_ok()     - returns true if success
 *   r.is_err()    - returns true if error
 *   r.unwrap_or(default) - returns value or default if error
 */
#include <stdio.h>
#include <stdlib.h>

#define CC_DECL_RESULT_SPEC(name, OkType, ErrType)                                  \
    typedef struct name {                                                           \
        bool ok;                                                                    \
        union { OkType value; ErrType error; } u;                                   \
    } name;                                                                         \
    static inline name cc_ok_##name(OkType v) {                                     \
        name r;                                                                     \
        r.ok = true;                                                                \
        r.u.value = v;                                                              \
        return r;                                                                   \
    }                                                                               \
    static inline name cc_err_##name(ErrType e) {                                   \
        name r;                                                                     \
        r.ok = false;                                                               \
        r.u.error = e;                                                              \
        return r;                                                                   \
    }                                                                               \
    /* UFCS method: r.unwrap() -> name##_unwrap(r) */                               \
    static inline OkType name##_unwrap(name r) {                                    \
        if (!r.ok) {                                                                \
            fprintf(stderr, "CC: unwrap failed on %s at %s:%d\n",                   \
                    #name, __FILE__, __LINE__);                                     \
            abort();                                                                \
        }                                                                           \
        return r.u.value;                                                           \
    }                                                                               \
    /* UFCS method: r.is_ok() -> name##_is_ok(r) */                                 \
    static inline bool name##_is_ok(name r) { return r.ok; }                        \
    /* UFCS method: r.is_err() -> name##_is_err(r) */                               \
    static inline bool name##_is_err(name r) { return !r.ok; }                      \
    /* UFCS method: r.unwrap_or(default) -> name##_unwrap_or(r, default) */         \
    static inline OkType name##_unwrap_or(name r, OkType def) {                     \
        return r.ok ? r.u.value : def;                                              \
    }

/* Generic cc_ok / cc_err macros for results */
#define cc_ok_into(result_var, val) do {          \
    (result_var).ok = true;                       \
    (result_var).u.value = (val);                 \
} while(0)

#define cc_err_into(result_var, err) do {         \
    (result_var).ok = false;                      \
    (result_var).u.error = (err);                 \
} while(0)

/* Common result types - defined in non-parser mode only.
   Parser mode uses typedefs to __CCResultGeneric (defined later in this file). */
#ifndef CC_PARSER_MODE
CC_DECL_RESULT_SPEC(CCResult_int_CCError, int, CCError)
CC_DECL_RESULT_SPEC(CCResult_bool_CCError, bool, CCError)
CC_DECL_RESULT_SPEC(CCResult_size_t_CCError, size_t, CCError)
CC_DECL_RESULT_SPEC(CCResult_voidptr_CCError, void*, CCError)
CC_DECL_RESULT_SPEC(CCResult_charptr_CCError, char*, CCError)

/* Void result (for functions that return only success/error) */
typedef struct CCResult_void_CCError {
    bool ok;
    union { char _dummy; CCError error; } u;
} CCResult_void_CCError;
static inline CCResult_void_CCError cc_ok_CCResult_void_CCError(void) {
    CCResult_void_CCError r;
    r.ok = true;
    return r;
}
static inline CCResult_void_CCError cc_err_CCResult_void_CCError(CCError e) {
    CCResult_void_CCError r;
    r.ok = false;
    r.u.error = e;
    return r;
}
/* UFCS methods for void result */
static inline void CCResult_void_CCError_unwrap(CCResult_void_CCError r) {
    if (!r.ok) {
        fprintf(stderr, "CC: unwrap failed on CCResult_void_CCError at %s:%d\n",
                __FILE__, __LINE__);
        abort();
    }
}
static inline bool CCResult_void_CCError_is_ok(CCResult_void_CCError r) { return r.ok; }
static inline bool CCResult_void_CCError_is_err(CCResult_void_CCError r) { return !r.ok; }
#endif

/* cc_try macro: unwrap T!>(E) or return error.
   Must be used in a function that returns the same result type.
   This is a GCC statement expression and works with clang/gcc. */
#ifndef CC_PARSER_MODE
#define cc_try(expr) __extension__ ({                \
    __typeof__(expr) __cc_try_r = (expr);            \
    if (!__cc_try_r.ok) return __cc_try_r;           \
    __cc_try_r.u.value;                              \
})
#endif

/*
 * TCC PARSER MODE: Result types use a generic placeholder during parsing.
 * 
 * The CC preprocessor rewrites T!>(E) to __CC_RESULT(T_mangled, E_mangled).
 * In parser mode, this macro expands to __CCResultGeneric.
 * In codegen, it's rewritten to CCResult_T_E with proper declarations.
 */
#ifdef CC_PARSER_MODE

/* Generic error struct for parser mode - has common fields so code compiles */
typedef struct __CCGenericError {
    int kind;
    int os_errno;
    int os_code;
    const char* message;
    char __pad[48];
} __CCGenericError;


/* Generic result placeholder struct - used for ALL result types during parsing.
   Field names match the real CC_DECL_RESULT_SPEC layout so user code compiles.
   Uses named union 'u' matching the real struct layout. */
typedef struct __CCResultGeneric {
    bool ok;
    union {
        intptr_t value;             /* intptr_t holds both ints and pointers */
        __CCGenericError error;     /* has .kind, .os_errno, .message */
    } u;
} __CCResultGeneric;

/* In parser mode, result type declarations use generic placeholder helpers. */
#undef CC_DECL_RESULT_SPEC
#define CC_DECL_RESULT_SPEC(name, OkType, ErrType)                     \
    typedef __CCResultGeneric name;                                    \
    static inline name cc_ok_##name(OkType v) {                        \
        (void)v;                                                       \
        return __cc_result_generic_ok();                               \
    }                                                                  \
    static inline name cc_err_##name(ErrType e) {                      \
        (void)e;                                                       \
        return __cc_result_generic_err();                              \
    }

/* THE KEY MACRO: In parser mode, all result types resolve to generic.
   Usage: __CC_RESULT(int, CCIoError) expands to __CCResultGeneric
   Codegen rewrites this to CCResult_int_CCIoError */
#define __CC_RESULT(T, E) __CCResultGeneric

/* Generic ok/err constructors - parser mode doesn't actually run,
   so these just return a zeroed struct for type checking. */
static inline __CCResultGeneric __cc_result_generic_ok(void) {
    __CCResultGeneric r = {0};
    r.ok = 1;
    return r;
}
static inline __CCResultGeneric __cc_result_generic_err(void) {
    __CCResultGeneric r = {0};
    r.ok = 0;
    return r;
}

/* Generic UFCS methods for parser mode - code compiles but doesn't run.
   These handle r.unwrap(), r.is_ok(), r.is_err(), r.unwrap_or(default) via UFCS. */
static inline intptr_t __CCResultGeneric_unwrap(__CCResultGeneric r) {
    (void)r;
    return 0;
}
static inline bool __CCResultGeneric_is_ok(__CCResultGeneric r) {
    return r.ok;
}
static inline bool __CCResultGeneric_is_err(__CCResultGeneric r) {
    return !r.ok;
}
static inline intptr_t __CCResultGeneric_unwrap_or(__CCResultGeneric r, intptr_t def) {
    (void)r; (void)def;
    return 0;
}

/* Macro-based ok/err that accept any type - parser mode just validates types.
   The value/error is unused but the expression is type-checked. */
#define __CC_RESULT_OK(T, E, v) ((void)(v), __cc_result_generic_ok())
#define __CC_RESULT_ERR(T, E, e) ((void)(e), __cc_result_generic_err())

/* Dummy cc_try for TCC parsing - just returns 0 as placeholder */
#define cc_try(expr) ((void)(expr), 0)

/*
 * Simplified result constructors for parser mode.
 * cc_ok(value) and cc_err(error) are inferred from context.
 * The compiler rewrites them to typed versions based on enclosing function.
 *
 * cc_err supports two forms (handled by compiler rewrite):
 *   cc_err(error_value)      - use error value directly
 *   cc_err(KIND, "message")  - shorthand, compiler wraps in cc_error()
 */
#define cc_ok(v) ((void)(v), __cc_result_generic_ok())
#define cc_err(...) ((void)0, __cc_result_generic_err())

/* Parser-mode: common result types are aliases to __CCResultGeneric */
typedef __CCResultGeneric CCResult_int_CCError;
typedef __CCResultGeneric CCResult_bool_CCError;
typedef __CCResultGeneric CCResult_size_t_CCError;
typedef __CCResultGeneric CCResult_voidptr_CCError;
typedef __CCResultGeneric CCResult_charptr_CCError;
typedef __CCResultGeneric CCResult_void_CCError;
#define cc_ok_CCResult_int_CCError(v) __cc_result_generic_ok()
#define cc_err_CCResult_int_CCError(e) __cc_result_generic_err()
#define cc_ok_CCResult_bool_CCError(v) __cc_result_generic_ok()
#define cc_err_CCResult_bool_CCError(e) __cc_result_generic_err()
#define cc_ok_CCResult_void_CCError() __cc_result_generic_ok()
#define cc_err_CCResult_void_CCError(e) __cc_result_generic_err()

#else /* !CC_PARSER_MODE - real compilation */

/* In real compilation, __CC_RESULT expands to the actual type name.
   The codegen pass ensures CC_DECL_RESULT_SPEC is emitted for each type. */
#define __CC_RESULT(T, E) CCResult_##T##_##E

/* Real ok/err constructors use the generated type-specific functions.
   These are placeholder definitions - the compiler rewrites cc_ok(v)/cc_err(e)
   to cc_ok_CCResult_T_E(v) based on the enclosing function's return type. */
#define __CC_RESULT_OK(T, E, v) cc_ok_CCResult_##T##_##E(v)
#define __CC_RESULT_ERR(T, E, e) cc_err_CCResult_##T##_##E(e)

#endif /* CC_PARSER_MODE */

/*
 * Result constructors - simplified API.
 *
 * cc_ok(value)  - Return success, type inferred from function return type
 * cc_err(error) - Return error, type inferred from function return type
 *
 * The compiler automatically rewrites these based on the enclosing function's
 * return type. For example, in a function returning int!>(CCIoError):
 *   cc_ok(42)  -> cc_ok_CCResult_int_CCIoError(42)
 *   cc_err(e)  -> cc_err_CCResult_int_CCIoError(e)
 *
 * Example:
 *   int!>(CCError) read_value(void) {
 *       if (success) return cc_ok(42);
 *       return cc_err(cc_error(CC_ERR_NOT_FOUND, "not found"));
 *   }
 */

/*
 * Result value accessors - for extracting values from results.
 *
 * cc_is_ok(res)        - Check if result is ok (same as res.ok)
 * cc_is_err(res)       - Check if result is error
 * cc_unwrap(res)       - Get value, abort if error (for primitives)
 * cc_unwrap_as(res, T) - Get value cast to type T (for struct values)
 * cc_unwrap_err(res)   - Get error value
 *
 * The _as variants are needed when the value is a struct and you want
 * to access its fields:
 *
 *   MyData!MyError res = get_data();
 *   if (cc_is_ok(res)) {
 *       MyData d = cc_unwrap_as(res, MyData);
 *       use(d.x, d.y);
 *   }
 *
 * Or use the if @try pattern:
 *   if @try (MyData d = res) {
 *       use(d.x, d.y);
 *   }
 */
#define cc_is_ok(res) ((res).ok)
#define cc_is_err(res) (!(res).ok)

/* cc_unwrap - get value from result, abort if error.
   For struct values, use cc_unwrap_as(res, Type) to cast to correct type.
   For struct errors, use cc_unwrap_err_as(res, Type). */
#ifdef CC_PARSER_MODE
#define cc_unwrap(res) ((res).u.value)
#define cc_unwrap_as(res, T) (*(T*)(void*)&(res).u.value)
#define cc_unwrap_err(res) ((res).u.error)
#define cc_unwrap_err_as(res, T) (*(T*)(void*)&(res).u.error)
#else
/* Real mode - actual unwrap with abort on error */
#define cc_unwrap(res) ({ \
    __typeof__(res) __r = (res); \
    if (!__r.ok) { \
        fprintf(stderr, "cc_unwrap called on error result\n"); \
        abort(); \
    } \
    __r.u.value; \
})
#define cc_unwrap_as(res, T) ({ \
    __typeof__(res) __r = (res); \
    if (!__r.ok) { \
        fprintf(stderr, "cc_unwrap_as called on error result\n"); \
        abort(); \
    } \
    *(T*)(void*)&__r.u.value; \
})
#define cc_unwrap_err(res) ({ \
    __typeof__(res) __r = (res); \
    if (__r.ok) { \
        fprintf(stderr, "cc_unwrap_err called on ok result\n"); \
        abort(); \
    } \
    __r.u.error; \
})
#define cc_unwrap_err_as(res, T) ({ \
    __typeof__(res) __r = (res); \
    if (__r.ok) { \
        fprintf(stderr, "cc_unwrap_err_as called on ok result\n"); \
        abort(); \
    } \
    *(T*)(void*)&__r.u.error; \
})
#endif

#endif /* CC_RESULT_H */

/*
 * Generic Result helpers for generated C.
 *
 * Two layouts are supported:
 * 
 * 1. Legacy layout (CC_DECL_RESULT): used by existing runtime code
 *    - struct { bool is_err; union { OkType ok; ErrType err; }; }
 *    - Access: r.is_err, r.ok, r.err
 *
 * 2. Spec-aligned layout (CC_DECL_RESULT_SPEC): matches spec ABI
 *    - struct { bool ok; union { T value; E error; } u; }
 *    - Access: r.ok, r.u.value, r.u.error
 *
 * The compiler-lowered T!E syntax uses the spec layout.
 */
#ifndef CC_RESULT_H
#define CC_RESULT_H

#ifndef __has_include
#define __has_include(x) 0
#endif
#if __has_include(<stdbool.h>)
#include <stdbool.h>
#else
#ifndef __bool_true_false_are_defined
typedef int bool;
#define true 1
#define false 0
#define __bool_true_false_are_defined 1
#endif
#endif

/* Common error type - a simple tagged enum with message */
typedef enum {
    CC_ERR_NONE = 0,
    CC_ERR_IO,
    CC_ERR_PARSE,
    CC_ERR_TIMEOUT,
    CC_ERR_CANCELLED,
    CC_ERR_INVALID_ARG,
    CC_ERR_OUT_OF_MEMORY,
    CC_ERR_NOT_FOUND,
    CC_ERR_PERMISSION,
    CC_ERR_ALREADY_EXISTS,
    CC_ERR_WOULD_BLOCK,
    CC_ERR_CLOSED,
    CC_ERR_OVERFLOW,
    CC_ERR_UNDERFLOW,
    CC_ERR_USER = 1000  /* User-defined errors start here */
} CCErrorKind;

typedef struct CCError {
    CCErrorKind kind;
    const char* message;  /* May be NULL */
} CCError;

/* Helper to construct errors */
static inline CCError cc_error(CCErrorKind kind, const char* msg) {
    CCError e = { kind, msg };
    return e;
}

/*
 * LEGACY LAYOUT: CC_DECL_RESULT
 * Used by existing runtime code (std/io.cch, etc.)
 * Access pattern: r.is_err, r.ok, r.err
 */
#define CC_DECL_RESULT(name, OkType, ErrType)                                       \
    typedef struct {                                                                \
        bool is_err;                                                                \
        union {                                                                     \
            OkType ok;                                                              \
            ErrType err;                                                            \
        };                                                                          \
    } name;                                                                         \
    static inline name cc_ok_##name(OkType value) {                                 \
        name r;                                                                     \
        r.is_err = false;                                                           \
        r.ok = value;                                                               \
        return r;                                                                   \
    }                                                                               \
    static inline name cc_err_##name(ErrType error) {                               \
        name r;                                                                     \
        r.is_err = true;                                                            \
        r.err = error;                                                              \
        return r;                                                                   \
    }

/*
 * Result type layout:
 *   r.ok       - true if success
 *   r.u.value  - the success value (when ok is true)
 *   r.u.error  - the error value (when ok is false)
 *
 * Uses named union 'u' for TCC compatibility.
 */
#define CC_DECL_RESULT_SPEC(name, OkType, ErrType)                                  \
    typedef struct name {                                                           \
        bool ok;                                                                    \
        union { OkType value; ErrType error; } u;                                   \
    } name;                                                                         \
    static inline name cc_ok_##name(OkType v) {                                     \
        name r;                                                                     \
        r.ok = true;                                                                \
        r.u.value = v;                                                              \
        return r;                                                                   \
    }                                                                               \
    static inline name cc_err_##name(ErrType e) {                                   \
        name r;                                                                     \
        r.ok = false;                                                               \
        r.u.error = e;                                                              \
        return r;                                                                   \
    }

/* Generic cc_ok / cc_err macros for results */
#define cc_ok_into(result_var, val) do {          \
    (result_var).ok = true;                       \
    (result_var).u.value = (val);                 \
} while(0)

#define cc_err_into(result_var, err) do {         \
    (result_var).ok = false;                      \
    (result_var).u.error = (err);                 \
} while(0)

/* Common result types - defined in non-parser mode only.
   Parser mode uses typedefs to __CCResultGeneric (defined later in this file). */
#ifndef CC_PARSER_MODE
CC_DECL_RESULT_SPEC(CCResult_int_CCError, int, CCError)
CC_DECL_RESULT_SPEC(CCResult_bool_CCError, bool, CCError)
CC_DECL_RESULT_SPEC(CCResult_size_t_CCError, size_t, CCError)
CC_DECL_RESULT_SPEC(CCResult_voidptr_CCError, void*, CCError)
CC_DECL_RESULT_SPEC(CCResult_charptr_CCError, char*, CCError)

/* Void result (for functions that return only success/error) */
typedef struct CCResult_void_CCError {
    bool ok;
    union { char _dummy; CCError error; } u;
} CCResult_void_CCError;
static inline CCResult_void_CCError cc_ok_CCResult_void_CCError(void) {
    CCResult_void_CCError r;
    r.ok = true;
    return r;
}
static inline CCResult_void_CCError cc_err_CCResult_void_CCError(CCError e) {
    CCResult_void_CCError r;
    r.ok = false;
    r.u.error = e;
    return r;
}
#endif

/* cc_try macro: unwrap T!E or return error.
   Must be used in a function that returns the same result type.
   This is a GCC statement expression and works with clang/gcc. */
#ifndef CC_PARSER_MODE
#define cc_try(expr) __extension__ ({                \
    __typeof__(expr) __cc_try_r = (expr);            \
    if (!__cc_try_r.ok) return __cc_try_r;           \
    __cc_try_r.u.value;                              \
})
#endif

/*
 * TCC PARSER MODE: Result types use a generic placeholder during parsing.
 * 
 * The CC preprocessor rewrites T!E to __CC_RESULT(T_mangled, E_mangled).
 * In parser mode, this macro expands to __CCResultGeneric.
 * In codegen, it's rewritten to CCResult_T_E with proper declarations.
 */
#ifdef CC_PARSER_MODE

/* Generic error struct for parser mode - has common fields so code compiles */
typedef struct __CCGenericError {
    int kind;
    int os_errno;
    const char* message;
    char __pad[48];
} __CCGenericError;

/* Generic result placeholder struct - used for ALL result types during parsing.
   Field names match the real CC_DECL_RESULT_SPEC layout so user code compiles.
   Uses named union 'u' matching the real struct layout. */
typedef struct __CCResultGeneric {
    bool ok;
    union {
        intptr_t value;             /* intptr_t holds both ints and pointers */
        __CCGenericError error;     /* has .kind, .os_errno, .message */
    } u;
} __CCResultGeneric;

/* THE KEY MACRO: In parser mode, all result types resolve to generic.
   Usage: __CC_RESULT(int, CCIoError) expands to __CCResultGeneric
   Codegen rewrites this to CCResult_int_CCIoError */
#define __CC_RESULT(T, E) __CCResultGeneric

/* Generic ok/err constructors - parser mode doesn't actually run,
   so these just return a zeroed struct for type checking. */
static inline __CCResultGeneric __cc_result_generic_ok(void) {
    __CCResultGeneric r = {0};
    r.ok = 1;
    return r;
}
static inline __CCResultGeneric __cc_result_generic_err(void) {
    __CCResultGeneric r = {0};
    r.ok = 0;
    return r;
}

/* Macro-based ok/err that accept any type - parser mode just validates types.
   The value/error is unused but the expression is type-checked. */
#define __CC_RESULT_OK(T, E, v) ((void)(v), __cc_result_generic_ok())
#define __CC_RESULT_ERR(T, E, e) ((void)(e), __cc_result_generic_err())

/* Dummy cc_try for TCC parsing - just returns 0 as placeholder */
#define cc_try(expr) ((void)(expr), 0)

/*
 * Simplified result constructors for parser mode.
 * cc_ok(value) and cc_err(error) are inferred from context.
 * The compiler rewrites them to typed versions based on enclosing function.
 */
#define cc_ok(v) ((void)(v), __cc_result_generic_ok())
#define cc_err(e) ((void)(e), __cc_result_generic_err())

/* Parser-mode: common result types are aliases to __CCResultGeneric */
typedef __CCResultGeneric CCResult_int_CCError;
typedef __CCResultGeneric CCResult_bool_CCError;
typedef __CCResultGeneric CCResult_size_t_CCError;
typedef __CCResultGeneric CCResult_voidptr_CCError;
typedef __CCResultGeneric CCResult_charptr_CCError;
typedef __CCResultGeneric CCResult_void_CCError;
#define cc_ok_CCResult_int_CCError(v) __cc_result_generic_ok()
#define cc_err_CCResult_int_CCError(e) __cc_result_generic_err()
#define cc_ok_CCResult_bool_CCError(v) __cc_result_generic_ok()
#define cc_err_CCResult_bool_CCError(e) __cc_result_generic_err()
#define cc_ok_CCResult_void_CCError() __cc_result_generic_ok()
#define cc_err_CCResult_void_CCError(e) __cc_result_generic_err()

#else /* !CC_PARSER_MODE - real compilation */

/* In real compilation, __CC_RESULT expands to the actual type name.
   The codegen pass ensures CC_DECL_RESULT_SPEC is emitted for each type. */
#define __CC_RESULT(T, E) CCResult_##T##_##E

/* Real ok/err constructors use the generated type-specific functions.
   These are placeholder definitions - the compiler rewrites cc_ok(v)/cc_err(e)
   to cc_ok_CCResult_T_E(v) based on the enclosing function's return type. */
#define __CC_RESULT_OK(T, E, v) cc_ok_CCResult_##T##_##E(v)
#define __CC_RESULT_ERR(T, E, e) cc_err_CCResult_##T##_##E(e)

#endif /* CC_PARSER_MODE */

/*
 * Result constructors - simplified API.
 *
 * cc_ok(value)  - Return success, type inferred from function return type
 * cc_err(error) - Return error, type inferred from function return type
 *
 * The compiler automatically rewrites these based on the enclosing function's
 * return type. For example, in a function returning int!CCIoError:
 *   cc_ok(42)  -> cc_ok_CCResult_int_CCIoError(42)
 *   cc_err(e)  -> cc_err_CCResult_int_CCIoError(e)
 *
 * Example:
 *   int!CCError read_value(void) {
 *       if (success) return cc_ok(42);
 *       return cc_err(cc_error(CC_ERR_NOT_FOUND, "not found"));
 *   }
 */

#endif /* CC_RESULT_H */

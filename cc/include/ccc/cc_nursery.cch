/*
 * Structured concurrency nursery (minimal stub).
 * Tracks spawned tasks and joins them at close. Cancellation is cooperative
 * via a shared flag; spawned functions should poll cc_nursery_is_cancelled().
 */
#ifndef CC_NURSERY_H
#define CC_NURSERY_H

#include <ccc/cc_compat.cch>
#include <ccc/cc_sched.cch>
#include <ccc/cc_closure.cch>
#include <ccc/cc_chan_handle.cch>

typedef struct CCChan CCChan;

typedef struct CCNursery CCNursery;

// Create a nursery. Returns NULL on allocation failure.
CCNursery* cc_nursery_create(void);

// Cancel all tasks (sets flag; tasks must poll cooperatively).
void cc_nursery_cancel(CCNursery* n);

// Set an absolute deadline for the nursery (CLOCK_REALTIME). Zeroed timespec clears.
void cc_nursery_set_deadline(CCNursery* n, struct timespec abs_deadline);

// Get the deadline as timespec; returns NULL if none.
const struct timespec* cc_nursery_deadline(const CCNursery* n, struct timespec* out);

// Convert nursery deadline/cancel state into a CCDeadline helper.
CCDeadline cc_nursery_as_deadline(const CCNursery* n);

// Register a channel to be auto-closed when the nursery is waited/freed.
int cc_nursery_add_closing_chan(CCNursery* n, CCChan* ch);
// Preferred: register a send-only handle to be auto-closed (spec-level capability).
int cc_nursery_add_closing_tx(CCNursery* n, CCChanTx tx);

// Check cancellation flag.
bool cc_nursery_is_cancelled(const CCNursery* n);

// Spawn a task owned by the nursery. Returns 0 on success.
int cc_nursery_spawn(CCNursery* n, void* (*fn)(void*), void* arg);
// Spawn a CCClosure0 (env freed via drop, if provided). Returns 0 on success.
int cc_nursery_spawn_closure0(CCNursery* n, CCClosure0 c);

// Wait for all tasks to finish. Returns first join error if any.
int cc_nursery_wait(CCNursery* n);

// Destroy nursery and free task handles (tasks must be finished).
void cc_nursery_free(CCNursery* n);

#endif // CC_NURSERY_H



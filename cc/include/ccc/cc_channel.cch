/*
 * Generic channel with blocking send/recv.
 * Backed by mutex/condvar; capacity fixed at creation.
 *
 * Typing helpers:
 *  - CC_DECL_TYPED_CHAN_PTR(T, Name): sends/receives pointers to T.
 *  - CC_DECL_TYPED_CHAN_VAL(T, Name): sends/receives T by value (copied).
 */
#ifndef CC_CHANNEL_H
#define CC_CHANNEL_H

#include <stddef.h>
#ifndef __has_include
#define __has_include(x) 0
#endif
#if __has_include(<stdbool.h>)
#include <stdbool.h>
#else
#ifndef __bool_true_false_are_defined
typedef int bool;
#define true 1
#define false 0
#define __bool_true_false_are_defined 1
#endif
#endif
#include <time.h>

#include <ccc/cc_sched.cch>
#include <ccc/cc_slice.cch>
#include <ccc/cc_nursery.cch>
#include <ccc/cc_exec.cch>
#include <ccc/cc_chan_handle.cch>
#include <ccc/cc_result.cch>
#include <ccc/cc_io.cch>

typedef struct CCAsyncHandle CCAsyncHandle;
#include <ccc/std/future.cch>

typedef struct CCChan CCChan;

/*
 * Unified I/O pattern for channels: bool !>(CCIoError)
 * Channels use CCIoError (same as files, network) for unified error handling.
 * - Ok(true)  = operation succeeded, got/sent data
 * - Ok(false) = channel closed gracefully (EOF)
 * - Err(e)    = actual error
 */

/*
 * Convert errno-style return to bool !>(CCIoError).
 * 0 → Ok(true), EPIPE → Ok(false), other → Err(e)
 */
static inline CCResult_bool_CCIoError cc_chan_result_from_errno(int err) {
    if (err == 0) {
        return cc_ok_CCResult_bool_CCIoError(true);
    } else if (err == EPIPE) {
        return cc_ok_CCResult_bool_CCIoError(false);
    } else {
        return cc_err_CCResult_bool_CCIoError(cc_io_from_errno(err));
    }
}

/*
 * Unified I/O helper for bool !>(CCIoError) results.
 * 
 * cc_io_avail(res) - true only if result is success AND value is true
 *                    Use for: while (cc_io_avail(chan_recv(rx, &item))) { ... }
 *                    Breaks on both error AND graceful close/EOF.
 */
static inline bool cc_io_avail(CCResult_bool_CCIoError res) {
    return res.ok && res.u.value;
}

typedef enum {
    CC_CHAN_MODE_BLOCK = 0,   // block when full/empty (default)
    CC_CHAN_MODE_DROP_NEW,    // drop new send (return EAGAIN) when full
    CC_CHAN_MODE_DROP_OLD     // drop oldest and enqueue new when full
} CCChanMode;

typedef enum {
    CC_CHAN_TOPO_DEFAULT = 0, // N:N - any senders, any receivers
    CC_CHAN_TOPO_1_1 = 1,     // 1:1 - single producer, single consumer
    CC_CHAN_TOPO_1_N = 2,     // 1:N - broadcast: one sender, many receivers
    CC_CHAN_TOPO_N_1 = 3,     // N:1 - many senders, one receiver
    CC_CHAN_TOPO_N_N = 4      // N:N - explicit (same as default)
} CCChanTopology;

// Create a channel with the given capacity (>=1). Returns NULL on failure.
// allow_send_take enables zero-copy pointer payloads via send_take API.
// Note: send_take is pointer-only (elem_size must be sizeof(void*)); by-value payloads are not eligible.
CCChan* cc_chan_create(size_t capacity);
CCChan* cc_chan_create_mode(size_t capacity, CCChanMode mode);
CCChan* cc_chan_create_mode_take(size_t capacity, CCChanMode mode, bool allow_send_take);

// Create a channel and return a directional handle pair (tx/rx).
// elem_size==0 means "leave uninitialized" (caller will call cc_chan_init_elem).
int cc_chan_pair_create(size_t capacity,
                        CCChanMode mode,
                        bool allow_send_take,
                        size_t elem_size,
                        CCChanTx* out_tx,
                        CCChanRx* out_rx);

// Extended pair creation with explicit sync/async flag.
// is_sync: true = sync channel (blocks OS thread), false = async channel (cooperative).
int cc_chan_pair_create_ex(size_t capacity,
                           CCChanMode mode,
                           bool allow_send_take,
                           size_t elem_size,
                           bool is_sync,
                           CCChanTx* out_tx,
                           CCChanRx* out_rx);

// Full pair creation with all options including topology.
// topology: one of CC_CHAN_TOPO_* values.
int cc_chan_pair_create_full(size_t capacity,
                             CCChanMode mode,
                             bool allow_send_take,
                             size_t elem_size,
                             bool is_sync,
                             int topology,
                             CCChanTx* out_tx,
                             CCChanRx* out_rx);

// Same as cc_chan_pair_create_full but returns CCChan* for assignment.
// Returns NULL on error. Used by channel_pair() language construct.
CCChan* cc_chan_pair_create_returning(size_t capacity,
                                      CCChanMode mode,
                                      bool allow_send_take,
                                      size_t elem_size,
                                      bool is_sync,
                                      int topology,
                                      CCChanTx* out_tx,
                                      CCChanRx* out_rx);

// Create a sync channel directly (blocking mode).
CCChan* cc_chan_create_sync(size_t capacity, CCChanMode mode, bool allow_send_take);

// Create an owned channel (resource pool) with lifecycle callbacks.
// - on_create: CCClosure0 called when recv on empty pool, returns created item (cast to void*)
// - on_destroy: CCClosure1 called for each item on channel free, arg0 is item pointer
// - on_reset: CCClosure1 called on item when returned via send, arg0 is item pointer (may have fn=NULL)
// Returns NULL on error. Owned channels are implicitly sync and bidirectional.
CCChan* cc_chan_create_owned(size_t capacity,
                             size_t elem_size,
                             CCClosure0 on_create,
                             CCClosure1 on_destroy,
                             CCClosure1 on_reset);

// Convenience alias for cc_chan_create_owned.
CCChan* cc_chan_create_owned_pool(size_t capacity,
                                  size_t elem_size,
                                  CCClosure0 on_create,
                                  CCClosure1 on_destroy,
                                  CCClosure1 on_reset);

// Close the channel: unblocks waiters. Further sends fail with EPIPE.
void cc_chan_close(CCChan* ch);

// Close channel with error code - recv() will return this error instead of EPIPE.
// Use for downstream error propagation in pipelines (producer -> consumer).
void cc_chan_close_err(CCChan* ch, int err);

// Close rx side with error - send() will return this error.
// Enables upstream error propagation in pipelines (consumer -> producer).
// Does not set the channel closed flag, only signals senders.
void cc_chan_rx_close_err(CCChan* ch, int err);

// Free channel resources. Safe to call on NULL. Undefined if called while
// other threads are still using the channel.
void cc_chan_free(CCChan* ch);

// Blocking send/recv. Returns 0 on success or an errno-style error.
int cc_chan_send(CCChan* ch, const void* value, size_t value_size);
int cc_chan_recv(CCChan* ch, void* out_value, size_t value_size);

// Batched send/recv: sends or receives `count` elements from/to contiguous buffers.
// Returns 0 on success or errno-style error.

// Non-blocking: return EAGAIN if would block.
int cc_chan_try_send(CCChan* ch, const void* value, size_t value_size);
int cc_chan_try_recv(CCChan* ch, void* out_value, size_t value_size);

// Timed send/recv honoring an absolute deadline.
int cc_chan_timed_send(CCChan* ch, const void* value, size_t value_size, const struct timespec* abs_deadline);
int cc_chan_timed_recv(CCChan* ch, void* out_value, size_t value_size, const struct timespec* abs_deadline);

// CCDeadline-aware helpers.
int cc_chan_deadline_send(CCChan* ch, const void* value, size_t value_size, const CCDeadline* deadline);
int cc_chan_deadline_recv(CCChan* ch, void* out_value, size_t value_size, const CCDeadline* deadline);

// Zero-copy pointer transfer (send_take). Valid only when elem_size == sizeof(void*) and channel was created with allow_send_take=true.
int cc_chan_send_take(CCChan* ch, void* ptr);
int cc_chan_try_send_take(CCChan* ch, void* ptr);
int cc_chan_timed_send_take(CCChan* ch, void* ptr, const struct timespec* abs_deadline);
int cc_chan_deadline_send_take(CCChan* ch, void* ptr, const CCDeadline* deadline);

// Slice-aware transfer with eligibility checks (unique + transferable + not subslice).
// Stores the slice descriptor in-channel (structure copy); ownership of the backing
// allocation is transferred on success. Fails with EINVAL if eligibility fails.
// Note: CCSliceUnique documents that caller is transferring ownership.
int cc_chan_send_take_slice(CCChan* ch, const CCSliceUnique* slice);
int cc_chan_try_send_take_slice(CCChan* ch, const CCSliceUnique* slice);
int cc_chan_timed_send_take_slice(CCChan* ch, const CCSliceUnique* slice, const struct timespec* abs_deadline);
int cc_chan_deadline_send_take_slice(CCChan* ch, const CCSliceUnique* slice, const CCDeadline* deadline);

// Nursery-aware helpers: use nursery deadline/cancel state.
int cc_chan_nursery_send(CCChan* ch, CCNursery* n, const void* value, size_t value_size);
int cc_chan_nursery_recv(CCChan* ch, CCNursery* n, void* out_value, size_t value_size);
int cc_chan_nursery_send_take(CCChan* ch, CCNursery* n, void* ptr);
int cc_chan_nursery_send_take_slice(CCChan* ch, CCNursery* n, const CCSliceUnique* slice);

// Async send/recv using executor; completion signaled on done channel.
typedef enum {
    CC_CHAN_ASYNC_PENDING = 0,
    CC_CHAN_ASYNC_OK = 1,
    CC_CHAN_ASYNC_ERR = 2,
    CC_CHAN_ASYNC_TIMEOUT = 3,
    CC_CHAN_ASYNC_CANCELLED = 4
} CCChanAsyncStatus;

typedef struct {
    CCAsyncHandle handle;
    CCChanAsyncStatus status;
} CCChanAsync;

int cc_chan_send_async(CCExec* ex, CCChan* ch, const void* value, size_t value_size, CCChanAsync* out, const CCDeadline* deadline);
int cc_chan_recv_async(CCExec* ex, CCChan* ch, void* out_value, size_t value_size, CCChanAsync* out, const CCDeadline* deadline);

// Poll-based channel tasks returning CCTaskIntptr (cooperative async).
// Result is errno (0=success). Caller must ensure value/out_value outlives the task.
#if !defined(CC_PARSER_MODE)
#include <ccc/std/task.cch>
CCTaskIntptr cc_chan_send_task(CCChan* ch, const void* value, size_t value_size);
CCTaskIntptr cc_chan_recv_task(CCChan* ch, void* out_value, size_t value_size);
#endif

// Non-blocking multi-case match helper: tries each case once, returns index of ready case.
typedef struct {
    CCChan* ch;
    const void* send_buf; // for send
    void* recv_buf;       // for recv
    size_t elem_size;
    bool is_send;
} CCChanMatchCase;

int cc_chan_match_try(CCChanMatchCase* cases, size_t n, size_t* ready_index);
int cc_chan_match_deadline(CCChanMatchCase* cases, size_t n, size_t* ready_index, const CCDeadline* deadline);

// Blocking select-style match over multiple channels with deadline support.
// Returns 0 on success (ready_index set), ETIMEDOUT on timeout, EPIPE if a closed channel is encountered with no ready cases.
int cc_chan_match_select(CCChanMatchCase* cases, size_t n, size_t* ready_index, const CCDeadline* deadline);

// Async select over channels. Submits to executor; sets *ready_index on completion and signals via CCAsyncHandle done channel (err code).
int cc_chan_match_select_async(CCExec* ex, CCChanMatchCase* cases, size_t n, size_t* ready_index, CCAsyncHandle* h, const CCDeadline* deadline);

// Future-based async select for ergonomic awaiting.
int cc_chan_match_select_future(CCExec* ex, CCChanMatchCase* cases, size_t n, size_t* ready_index, CCFuture* f, const CCDeadline* deadline);

// Typed-size initialization helper (eagerly sets elem_size and allocates buffer).
int cc_chan_init_elem(CCChan* ch, size_t elem_size);

// Convenience macros to build match cases.
#define CC_CHAN_MATCH_SEND_CASE(CH, BUF, TYPE) (CCChanMatchCase){ .ch = (CH), .send_buf = (BUF), .recv_buf = NULL, .elem_size = sizeof(TYPE), .is_send = true }
#define CC_CHAN_MATCH_RECV_CASE(CH, BUF, TYPE) (CCChanMatchCase){ .ch = (CH), .send_buf = NULL, .recv_buf = (BUF), .elem_size = sizeof(TYPE), .is_send = false }

// Typed wrapper macros: value and pointer variants with bool helpers for spec parity.
#define CC_DECL_TYPED_CHAN_VAL(T, Name)                                                \
    typedef struct { CCChan* raw; } Name;                                              \
    static inline Name Name##_create(size_t cap) { Name c = { cc_chan_create(cap) }; if (c.raw) cc_chan_init_elem(c.raw, sizeof(T)); return c; } \
    static inline void Name##_close(Name* c) { if (c && c->raw) cc_chan_close(c->raw); } \
    static inline void Name##_free(Name* c) { if (c && c->raw) cc_chan_free(c->raw); } \
    static inline int Name##_send(Name* c, T v) { return cc_chan_send(c ? c->raw : NULL, &v, sizeof(T)); } \
    static inline int Name##_recv(Name* c, T* out_v) { return cc_chan_recv(c ? c->raw : NULL, out_v, sizeof(T)); } \
    static inline bool Name##_try_send(Name* c, T v) { return cc_chan_try_send(c ? c->raw : NULL, &v, sizeof(T)) == 0; } \
    static inline bool Name##_try_recv(Name* c, T* out_v) { return cc_chan_try_recv(c ? c->raw : NULL, out_v, sizeof(T)) == 0; }

#define CC_DECL_TYPED_CHAN_PTR(T, Name)                                                \
    typedef struct { CCChan* raw; } Name;                                              \
    static inline Name Name##_create(size_t cap) { Name c = { cc_chan_create_mode_take(cap, CC_CHAN_MODE_BLOCK, true) }; if (c.raw) cc_chan_init_elem(c.raw, sizeof(void*)); return c; } \
    static inline void Name##_close(Name* c) { if (c && c->raw) cc_chan_close(c->raw); } \
    static inline void Name##_free(Name* c) { if (c && c->raw) cc_chan_free(c->raw); } \
    static inline int Name##_send(Name* c, T* ptr) { return cc_chan_send_take(c ? c->raw : NULL, ptr); } \
    static inline int Name##_recv(Name* c, T** out_ptr) { return cc_chan_recv(c ? c->raw : NULL, out_ptr, sizeof(void*)); } \
    static inline bool Name##_try_send(Name* c, T* ptr) { return cc_chan_try_send_take(c ? c->raw : NULL, ptr) == 0; } \
    static inline bool Name##_try_recv(Name* c, T** out_ptr) { return cc_chan_try_recv(c ? c->raw : NULL, out_ptr, sizeof(void*)) == 0; }

#endif // CC_CHANNEL_H



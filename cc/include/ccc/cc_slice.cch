/*
 * Slice ABI and helpers.
 *
 * Layout matches the codegen contract: {ptr,len,id,alen} (32 bytes on 64-bit).
 * - ptr  : data pointer
 * - len  : logical length of the view
 * - id   : provenance/uniqueness token (0 if not tracked)
 * - alen : available length from ptr to the end of the original allocation
 *
 * This header is intentionally small and header-only so it can be used both by
 * the runtime and generated C without additional linkage.
 */
#ifndef CC_SLICE_H
#define CC_SLICE_H

#ifndef __has_include
#define __has_include(x) 0
#endif
#if __has_include(<stdbool.h>)
#include <stdbool.h>
#else
/* Fallback for TCC environments without stdbool. */
#ifndef __bool_true_false_are_defined
typedef int bool;
#define true 1
#define false 0
#define __bool_true_false_are_defined 1
#endif
#endif
#include <stddef.h>
#include <stdint.h>

#ifndef CC_SLICE_ID_NONE
#define CC_SLICE_ID_NONE 0ULL
#endif

// Slice id bit layout (matches spec):
// Bits 0â€“60 : allocation id (non-zero for tracked allocations)
// Bit 61    : is_transferable
// Bit 62    : is_subslice
// Bit 63    : is_unique (has destructor, move-only)
#define CC_SLICE_ID_ALLOC_MASK 0x1FFFFFFFFFFFFFFFULL
#define CC_SLICE_ID_TRANSFERABLE (1ULL << 61)
#define CC_SLICE_ID_SUBSLICE     (1ULL << 62)
#define CC_SLICE_ID_UNIQUE       (1ULL << 63)

typedef struct {
    void *ptr;
    size_t len;
    uint64_t id;   // allocation id | flags
    size_t alen;
} CCSlice;

/* Surface type sugar:
   - `T[:]`  lowers to `CCSlice`
   - `T[:!]` lowers to `CCSliceUnique` (still ABI-identical to CCSlice) */
typedef CCSlice CCSliceUnique;

static inline CCSlice cc_slice_empty(void) {
    CCSlice s = {0};
    return s;
}

static inline uint64_t cc_slice_make_id(uint64_t alloc_id, bool unique, bool transferable, bool is_sub) {
    uint64_t id = (alloc_id & CC_SLICE_ID_ALLOC_MASK);
    if (unique) id |= CC_SLICE_ID_UNIQUE;
    if (transferable) id |= CC_SLICE_ID_TRANSFERABLE;
    if (is_sub) id |= CC_SLICE_ID_SUBSLICE;
    return id;
}

static inline uint64_t cc_slice_clear_flags(uint64_t id, uint64_t flags) {
    return id & ~flags;
}

static inline bool cc_slice_is_unique_id(uint64_t id) { return (id & CC_SLICE_ID_UNIQUE) != 0; }
static inline bool cc_slice_is_transferable_id(uint64_t id) { return (id & CC_SLICE_ID_TRANSFERABLE) != 0; }
static inline bool cc_slice_is_subslice_id(uint64_t id) { return (id & CC_SLICE_ID_SUBSLICE) != 0; }
static inline bool cc_slice_is_unique(CCSlice s) { return cc_slice_is_unique_id(s.id); }
static inline bool cc_slice_is_transferable(CCSlice s) { return cc_slice_is_transferable_id(s.id); }
static inline bool cc_slice_is_subslice(CCSlice s) { return cc_slice_is_subslice_id(s.id); }

static inline CCSlice cc_slice_from_buffer(void *ptr, size_t len) {
    // Default: untracked/static slice (id=0), non-unique, non-transferable, full-range.
    CCSlice s = {ptr, len, CC_SLICE_ID_NONE, len};
    return s;
}

static inline CCSlice cc_slice_from_parts(void *ptr,
                                          size_t len,
                                          uint64_t id,
                                          size_t available_len) {
    CCSlice s = {ptr, len, id, available_len};
    return s;
}

static inline bool cc_slice_is_empty(CCSlice s) {
    return s.len == 0;
}

static inline size_t cc_slice_capacity(CCSlice s) {
    return s.alen ? s.alen : s.len;
}

static inline CCSlice cc_slice_sub(CCSlice s, size_t start, size_t end) {
    if (start > end || end > s.len) {
        return cc_slice_empty();
    }
    uint8_t *base = (uint8_t *)s.ptr;
    uint64_t id = cc_slice_clear_flags(s.id, CC_SLICE_ID_UNIQUE);
    // Preserve transferability; set subslice flag when not covering the full allocation.
    bool covers_full_alloc = (start == 0) && (end == s.len) && (s.alen == 0 || s.len == s.alen);
    if (covers_full_alloc) {
        id = cc_slice_clear_flags(id, CC_SLICE_ID_SUBSLICE);
    } else {
        id |= CC_SLICE_ID_SUBSLICE;
    }
    CCSlice sub = {
        .ptr = base ? (void *)(base + start) : NULL,
        .len = end - start,
        .id = id,
        // Preserve allocation length (not view length).
        .alen = s.alen ? s.alen : s.len,
    };
    return sub;
}

/* Typed accessors for common uses (UFCS: s.str(), s.bytes()) */
static inline const char* cc_slice_str(CCSlice* s) {
    return (const char*)s->ptr;
}

static inline const uint8_t* cc_slice_bytes(CCSlice* s) {
    return (const uint8_t*)s->ptr;
}

/* cc_slice_len is defined in std/string.cch - use pass-by-value version there */

#endif // CC_SLICE_H



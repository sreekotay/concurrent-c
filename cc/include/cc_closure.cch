/*
 * CC closure ABI (early, minimal).
 *
 * This is the foundation for:
 * - `() => { ... }` closures (capture-by-copy)
 * - passing closures into runtimes (nursery spawn, blocking executor, etc.)
 *
 * NOTE: For now we only standardize a 0-arg closure returning void* (like pthread).
 * Higher-arity + typed closures will layer on top as compiler support grows.
 */
#ifndef CC_CLOSURE_H
#define CC_CLOSURE_H

#include <stddef.h>

/* Forward declaration to avoid include cycles (`cc_nursery.cch` may include runtime types). */
typedef struct CCNursery CCNursery;

#if defined(CC_PARSER_MODE)
/* TCC parse-to-stub-AST runs after preprocessing. For CC syntax like `() => {}`,
   we intentionally use a dummy type so the C parser doesn't reject otherwise-valid CC code.
   The real ABI type is used for the final emitted C compilation. */
typedef int CCClosure0;
#define CCClosure1 CCClosure0
#define CCClosure2 CCClosure0
#else
typedef struct {
    void* (*fn)(void* env);
    void* env;
    void (*drop)(void* env); /* optional; can be NULL */
} CCClosure0;

typedef struct {
    void* (*fn)(void* env, void* arg0);
    void* env;
    void (*drop)(void* env); /* optional; can be NULL */
} CCClosure1;

typedef struct {
    void* (*fn)(void* env, void* arg0, void* arg1);
    void* env;
    void (*drop)(void* env); /* optional; can be NULL */
} CCClosure2;
#endif

/* Run a closure on a blocking OS thread and wait for completion.
   Early stub: implemented via pthread spawn + join. */
int cc_run_blocking_closure0(CCClosure0 c);

/* Invoke a 1-arg closure. */
void* cc_closure1_call(CCClosure1 c, void* arg0);
/* Invoke a 2-arg closure. */
void* cc_closure2_call(CCClosure2 c, void* arg0, void* arg1);

/* Spawn arity-1/2 closures in a nursery (bridge for `spawn(c, arg...)`). */
int cc_nursery_spawn_closure1(CCNursery* n, CCClosure1 c, void* arg0);
int cc_nursery_spawn_closure2(CCNursery* n, CCClosure2 c, void* arg0, void* arg1);

static inline CCClosure0 cc_closure0_make(void* (*fn)(void*), void* env, void (*drop)(void*)) {
#if defined(CC_PARSER_MODE)
    (void)fn; (void)env; (void)drop;
    return 0;
#else
    CCClosure0 c;
    c.fn = fn;
    c.env = env;
    c.drop = drop;
    return c;
#endif
}

static inline CCClosure1 cc_closure1_make(void* (*fn)(void*, void*), void* env, void (*drop)(void*)) {
#if defined(CC_PARSER_MODE)
    (void)fn; (void)env; (void)drop;
    return 0;
#else
    CCClosure1 c;
    c.fn = fn;
    c.env = env;
    c.drop = drop;
    return c;
#endif
}

static inline CCClosure2 cc_closure2_make(void* (*fn)(void*, void*, void*), void* env, void (*drop)(void*)) {
#if defined(CC_PARSER_MODE)
    (void)fn; (void)env; (void)drop;
    return 0;
#else
    CCClosure2 c;
    c.fn = fn;
    c.env = env;
    c.drop = drop;
    return c;
#endif
}

#endif /* CC_CLOSURE_H */


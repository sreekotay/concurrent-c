/*
 * Generic Result helpers for generated C.
 *
 * Two layouts are supported:
 * 
 * 1. Legacy layout (CC_DECL_RESULT): used by existing runtime code
 *    - struct { bool is_err; union { OkType ok; ErrType err; }; }
 *    - Access: r.is_err, r.ok, r.err
 *
 * 2. Spec-aligned layout (CC_DECL_RESULT_SPEC): matches spec ABI
 *    - struct { bool ok; union { T value; E error; } u; }
 *    - Access: r.ok, r.u.value, r.u.error
 *
 * The compiler-lowered T!E syntax uses the spec layout.
 */
#ifndef CC_RESULT_H
#define CC_RESULT_H

#ifndef __has_include
#define __has_include(x) 0
#endif
#if __has_include(<stdbool.h>)
#include <stdbool.h>
#else
#ifndef __bool_true_false_are_defined
typedef int bool;
#define true 1
#define false 0
#define __bool_true_false_are_defined 1
#endif
#endif

/* Common error type - a simple tagged enum with message */
typedef enum {
    CC_ERR_NONE = 0,
    CC_ERR_IO,
    CC_ERR_PARSE,
    CC_ERR_TIMEOUT,
    CC_ERR_CANCELLED,
    CC_ERR_INVALID_ARG,
    CC_ERR_OUT_OF_MEMORY,
    CC_ERR_NOT_FOUND,
    CC_ERR_PERMISSION,
    CC_ERR_ALREADY_EXISTS,
    CC_ERR_WOULD_BLOCK,
    CC_ERR_CLOSED,
    CC_ERR_OVERFLOW,
    CC_ERR_UNDERFLOW,
    CC_ERR_USER = 1000  /* User-defined errors start here */
} CCErrorKind;

typedef struct CCError {
    CCErrorKind kind;
    const char* message;  /* May be NULL */
} CCError;

/* Helper to construct errors */
static inline CCError cc_error(CCErrorKind kind, const char* msg) {
    CCError e = { kind, msg };
    return e;
}

/*
 * LEGACY LAYOUT: CC_DECL_RESULT
 * Used by existing runtime code (std/io.cch, etc.)
 * Access pattern: r.is_err, r.ok, r.err
 */
#define CC_DECL_RESULT(name, OkType, ErrType)                                       \
    typedef struct {                                                                \
        bool is_err;                                                                \
        union {                                                                     \
            OkType ok;                                                              \
            ErrType err;                                                            \
        };                                                                          \
    } name;                                                                         \
    static inline name cc_ok_##name(OkType value) {                                 \
        name r;                                                                     \
        r.is_err = false;                                                           \
        r.ok = value;                                                               \
        return r;                                                                   \
    }                                                                               \
    static inline name cc_err_##name(ErrType error) {                               \
        name r;                                                                     \
        r.is_err = true;                                                            \
        r.err = error;                                                              \
        return r;                                                                   \
    }

/*
 * SPEC-ALIGNED LAYOUT: CC_DECL_RESULT_SPEC
 * Used by compiler-lowered T!E syntax
 * Access pattern: r.ok, r.u.value, r.u.error
 * Matches spec: struct { bool ok; union { T value; E error; } u; }
 */
#define CC_DECL_RESULT_SPEC(name, OkType, ErrType)                                  \
    typedef struct name {                                                           \
        bool ok;                                                                    \
        union { OkType value; ErrType error; } u;                                   \
    } name;                                                                         \
    static inline name cc_ok_##name(OkType v) {                                     \
        name r;                                                                     \
        r.ok = true;                                                                \
        r.u.value = v;                                                              \
        return r;                                                                   \
    }                                                                               \
    static inline name cc_err_##name(ErrType e) {                                   \
        name r;                                                                     \
        r.ok = false;                                                               \
        r.u.error = e;                                                              \
        return r;                                                                   \
    }

/* Generic cc_ok / cc_err macros for spec-aligned results */
#define cc_ok_into(result_var, val) do {          \
    (result_var).ok = true;                       \
    (result_var).u.value = (val);                 \
} while(0)

#define cc_err_into(result_var, err) do {         \
    (result_var).ok = false;                      \
    (result_var).u.error = (err);                 \
} while(0)

/* Common spec-aligned result types - pre-declared for convenience */
CC_DECL_RESULT_SPEC(CCResult_int_CCError, int, CCError)
CC_DECL_RESULT_SPEC(CCResult_bool_CCError, bool, CCError)
CC_DECL_RESULT_SPEC(CCResult_size_t_CCError, size_t, CCError)
CC_DECL_RESULT_SPEC(CCResult_voidptr_CCError, void*, CCError)
CC_DECL_RESULT_SPEC(CCResult_charptr_CCError, char*, CCError)

/* Void result (for functions that return only success/error) */
typedef struct CCResult_void_CCError {
    bool ok;
    union { char _dummy; CCError error; } u;
} CCResult_void_CCError;
static inline CCResult_void_CCError cc_ok_CCResult_void_CCError(void) {
    CCResult_void_CCError r;
    r.ok = true;
    return r;
}
static inline CCResult_void_CCError cc_err_CCResult_void_CCError(CCError e) {
    CCResult_void_CCError r;
    r.ok = false;
    r.u.error = e;
    return r;
}

/* cc_try macro: unwrap T!E or return error.
   Must be used in a function that returns the same result type.
   This is a GCC statement expression and works with clang/gcc. */
#ifndef CC_PARSER_MODE
#define cc_try(expr) __extension__ ({                \
    __typeof__(expr) __cc_try_r = (expr);            \
    if (!__cc_try_r.ok) return __cc_try_r;           \
    __cc_try_r.u.value;                              \
})
#endif

/*
 * TCC PARSER MODE: Any unknown CCResult_*_* type is treated as a generic placeholder.
 * TCC uses this during parsing; the codegen pass emits proper type definitions.
 */
#ifdef CC_PARSER_MODE
/* Generic result placeholder struct - used for all unknown CCResult_T_E types */
typedef struct __CCResultGeneric {
    bool ok;
    union { long long value; long long error; } u;
} __CCResultGeneric;

/* Common user-defined result type patterns - map to generic during parsing */
typedef __CCResultGeneric CCResult_int_ParseError;
typedef __CCResultGeneric CCResult_int_MyError;
typedef __CCResultGeneric CCResult_int_Error;
typedef __CCResultGeneric CCResult_bool_ParseError;

/* Dummy ok/err constructors for any result type during parsing */
static inline __CCResultGeneric __cc_result_generic_ok(long long v) {
    __CCResultGeneric r;
    r.ok = 1;
    r.u.value = v;
    return r;
}
static inline __CCResultGeneric __cc_result_generic_err(long long e) {
    __CCResultGeneric r;
    r.ok = 0;
    r.u.error = e;
    return r;
}
#define cc_ok_CCResult_int_ParseError(v) __cc_result_generic_ok((long long)(v))
#define cc_err_CCResult_int_ParseError(e) __cc_result_generic_err(0)
#define cc_ok_CCResult_int_MyError(v) __cc_result_generic_ok((long long)(v))
#define cc_err_CCResult_int_MyError(e) __cc_result_generic_err(0)
#define cc_ok_CCResult_int_Error(v) __cc_result_generic_ok((long long)(v))
#define cc_err_CCResult_int_Error(e) __cc_result_generic_err(0)

/* Dummy cc_try for TCC parsing - just returns the expression */
#define cc_try(expr) ((expr).u.value)
#endif /* CC_PARSER_MODE */

#endif /* CC_RESULT_H */

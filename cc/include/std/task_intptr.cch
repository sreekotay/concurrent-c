/*
 * Minimal Task<intptr_t> facade built on the existing CCFuture/CCAsyncHandle.
 *
 * This is an incremental bridge: it provides an awaitable-ish handle type and
 * a sync `block_on` entrypoint, without implementing full @async state machines yet.
 */
#ifndef CC_STD_TASK_INTPTR_H
#define CC_STD_TASK_INTPTR_H

#include <stdint.h>
#include "future.cch"

#if defined(CC_PARSER_MODE)
/* Parse-only dummy type: TCC doesn't like assigning/returning structs during stub-AST parsing. */
typedef int CCTaskIntptr;
typedef CCFutureStatus (*cc_task_intptr_poll_fn)(void* frame, intptr_t* out_val, int* out_err);

/* Parse-only stubs: avoid type errors from using @async before lowering rewrites kick in.
   In particular, allow `cc_block_on_intptr(f())` where `f` is still seen as `void` by TCC. */
#define cc_run_blocking_task_intptr(c) (0)
#define cc_task_intptr_make_poll(poll, frame, drop) (0)
#define cc_block_on_intptr(t) (0)
#define cc_block_on(T, task_expr) ((T)0)
#define cc_await(T, task_expr) ((T)0)
static inline CCFutureStatus cc_task_intptr_poll(CCTaskIntptr* t, intptr_t* out_val, int* out_err) {
    (void)t;
    if (out_val) *out_val = 0;
    if (out_err) *out_err = 0;
    return CC_FUTURE_READY;
}
static inline void cc_task_intptr_free(CCTaskIntptr* t) { (void)t; }
#else
typedef enum {
    CC_TASK_INTPTR_KIND_INVALID = 0,
    CC_TASK_INTPTR_KIND_FUTURE = 1,
    CC_TASK_INTPTR_KIND_POLL = 2,
} CCTaskIntptrKind;

typedef CCFutureStatus (*cc_task_intptr_poll_fn)(void* frame, intptr_t* out_val, int* out_err);

typedef struct {
    CCFuture fut;
    void* heap; /* owned by runtime; freed by cc_task_intptr_free or block_on */
} CCTaskIntptrFuture;

typedef struct {
    cc_task_intptr_poll_fn poll;
    void* frame;
    void (*drop)(void* frame);
} CCTaskIntptrPoll;

typedef struct {
    CCTaskIntptrKind kind;
    CCTaskIntptrFuture future;
    CCTaskIntptrPoll poll;
} CCTaskIntptr;
#endif /* CC_PARSER_MODE */

#if !defined(CC_PARSER_MODE)
/* Start a blocking closure on the runtime executor thread pool.
   The closure must return a value encoded as (void*)(intptr_t)result or a pointer cast.
   On failure returns an invalid task with fut.handle.done == NULL. */
CCTaskIntptr cc_run_blocking_task_intptr(CCClosure0 c);

/* Construct a task backed by a poll-based state machine. */
CCTaskIntptr cc_task_intptr_make_poll(cc_task_intptr_poll_fn poll, void* frame, void (*drop)(void* frame));

/* Block current OS thread until task completes and return result. Frees task resources. */
intptr_t cc_block_on_intptr(CCTaskIntptr t);

/* Best-effort non-blocking poll. Returns CC_FUTURE_PENDING/READY/etc; if READY, stores result. */
CCFutureStatus cc_task_intptr_poll(CCTaskIntptr* t, intptr_t* out_val, int* out_err);

/* Free task resources without waiting (unsafe if still running). */
void cc_task_intptr_free(CCTaskIntptr* t);
#endif /* !CC_PARSER_MODE */

#if !defined(CC_PARSER_MODE)
/* Typed convenience wrapper: `T` is the desired result type (e.g. `int`, `intptr_t`, `void*`). */
#define cc_block_on(T, task_expr) ((T)(intptr_t)cc_block_on_intptr((task_expr)))
/* Temporary ergonomic alias until we have first-class `await` lowering for all expressions. */
#define cc_await(T, task_expr) cc_block_on(T, (task_expr))
#endif

#endif /* CC_STD_TASK_INTPTR_H */


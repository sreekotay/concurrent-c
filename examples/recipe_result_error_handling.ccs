/*
 * Recipe: Error Handling with Result Types (T!>(E))
 *
 * Demonstrates:
 *   - Declaring functions that return T!>(E) (Result types)
 *   - Using try to propagate errors
 *   - Helper macros: cc_is_ok(), cc_is_err(), cc_unwrap(), cc_unwrap_err()
 *
 * Key insight: Result types make error handling explicit and composable.
 * Use `try` for early propagation, helper macros for manual checks.
 *
 * See spec ยง2.2 for complete Result type documentation.
 */
#include <ccc/std/prelude.cch>

/* Simulated I/O operation that can fail. */
int !>(CCError) read_config_value(const char* key) {
    if (!key || key[0] == '\0') {
        return cc_err(CC_ERR_INVALID_ARG, "empty key");
    }
    if (strcmp(key, "timeout") == 0) {
        return cc_ok(30);
    }
    if (strcmp(key, "max_retries") == 0) {
        return cc_ok(3);
    }
    return cc_err(CC_ERR_NOT_FOUND, "key not found");
}

/* Function that uses try to propagate errors. */
int !>(CCError) get_total_wait_time(void) {
    int timeout = try read_config_value("timeout");
    int retries = try read_config_value("max_retries");
    return cc_ok(timeout * retries);
}

/* Function that handles errors locally using helper macros. */
int get_timeout_with_default(int default_val) {
    int !>(CCError) result = read_config_value("timeout");
    if (cc_is_ok(result)) {
        return cc_unwrap(result);
    }
    /* Error case: log and return default */
    printf("warning: %s, using default %d\n", cc_unwrap_err(result).message, default_val);
    return default_val;
}

int main(void) {
    /* Test 1: Successful try propagation */
    int !>(CCError) total = get_total_wait_time();
    if (cc_is_err(total)) {
        printf("FAIL: expected ok, got error: %s\n", cc_unwrap_err(total).message);
        return 1;
    }
    printf("total wait time: %d seconds\n", cc_unwrap(total));
    
    /* Test 2: Error propagation via try */
    int !>(CCError) missing = read_config_value("unknown_key");
    if (cc_is_ok(missing)) {
        printf("FAIL: expected error for unknown key\n");
        return 1;
    }
    printf("expected error: %s\n", cc_unwrap_err(missing).message);
    
    /* Test 3: Manual error handling with default */
    int timeout = get_timeout_with_default(60);
    printf("timeout (with default fallback): %d\n", timeout);
    
    /* Test 4: Invalid argument error */
    int !>(CCError) invalid = read_config_value("");
    if (cc_is_ok(invalid)) {
        printf("FAIL: expected error for empty key\n");
        return 1;
    }
    printf("expected error: %s\n", cc_unwrap_err(invalid).message);
    
    printf("\nAll error handling tests passed!\n");
    return 0;
}

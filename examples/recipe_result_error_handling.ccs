/*
 * Recipe: Error Handling with Result Types (T!E)
 *
 * Demonstrates:
 *   - Declaring functions that return T!E (Result types)
 *   - Using try to propagate errors
 *   - Manual error checking with .ok and .u.value/.u.error
 *
 * Key insight: Result types make error handling explicit and composable.
 * Use `try` for early propagation, manual checks for recovery.
 */
#include "std/prelude.cch"

/* Simulated I/O operation that can fail. */
int!CCError read_config_value(const char* key) {
    if (!key || key[0] == '\0') {
        return cc_err_CCResult_int_CCError(cc_error(CC_ERR_INVALID_ARG, "empty key"));
    }
    if (strcmp(key, "timeout") == 0) {
        return cc_ok_CCResult_int_CCError(30);
    }
    if (strcmp(key, "max_retries") == 0) {
        return cc_ok_CCResult_int_CCError(3);
    }
    return cc_err_CCResult_int_CCError(cc_error(CC_ERR_NOT_FOUND, "key not found"));
}

/* Function that uses try to propagate errors. */
int!CCError get_total_wait_time(void) {
    int timeout = try read_config_value("timeout");
    int retries = try read_config_value("max_retries");
    return cc_ok_CCResult_int_CCError(timeout * retries);
}

/* Function that handles errors locally. */
int get_timeout_with_default(int default_val) {
    int!CCError result = read_config_value("timeout");
    if (result.ok) {
        return result.u.value;
    }
    /* Error case: log and return default */
    printf("warning: %s, using default %d\n", result.u.error.message, default_val);
    return default_val;
}

int main(void) {
    /* Test 1: Successful try propagation */
    int!CCError total = get_total_wait_time();
    if (!total.ok) {
        printf("FAIL: expected ok, got error: %s\n", total.u.error.message);
        return 1;
    }
    printf("total wait time: %d seconds\n", total.u.value);
    
    /* Test 2: Error propagation via try */
    int!CCError missing = read_config_value("unknown_key");
    if (missing.ok) {
        printf("FAIL: expected error for unknown key\n");
        return 1;
    }
    printf("expected error: %s\n", missing.u.error.message);
    
    /* Test 3: Manual error handling with default */
    int timeout = get_timeout_with_default(60);
    printf("timeout (with default fallback): %d\n", timeout);
    
    /* Test 4: Invalid argument error */
    int!CCError invalid = read_config_value("");
    if (invalid.ok) {
        printf("FAIL: expected error for empty key\n");
        return 1;
    }
    printf("expected error: %s\n", invalid.u.error.message);
    
    printf("\nAll error handling tests passed!\n");
    return 0;
}

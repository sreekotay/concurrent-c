/*
 * Recipe: Worker Pool
 *
 * Demonstrates:
 *   - N workers consuming from shared job queue
 *   - closing() signals "no more jobs" when feeder done
 *   - Workers report results via separate channel (no shared counter)
 *
 * Key insight: Workers live in outer nursery, jobs fed via inner nursery.
 * Use channels for coordination, not shared mutable state.
 *
 * Note: Uses globals for channel handles (closure capture limitation).
 */
#include "cc_nursery.cch"
#include "cc_runtime.cch"
#include <stdio.h>

#define NUM_WORKERS 3
#define NUM_JOBS 9

/* Global handles (workaround for closure capture limitation) */
int[~4 >] g_jobs_tx;
int[~4 <] g_jobs_rx;
int[~16 >] g_done_tx;  /* capacity >= NUM_JOBS to avoid deadlock */
int[~16 <] g_done_rx;

int main(void) {
    channel_pair(&g_jobs_tx, &g_jobs_rx);
    channel_pair(&g_done_tx, &g_done_rx);

    @nursery {
        /* Workers: pull jobs, send completion to done channel. */
        for (int w = 0; w < NUM_WORKERS; w++) {
            spawn(() => {
                int job;
                while (chan_recv(g_jobs_rx, &job) == 0) {
                    printf("worker: processed job %d\n", job);
                    chan_send(g_done_tx, job);  /* report done */
                }
            });
        }

        /* Feeder: sends all jobs, then inner nursery closes jobs channel. */
        @nursery closing(g_jobs_tx) {
            spawn(() => {
                for (int j = 1; j <= NUM_JOBS; j++) {
                    chan_send(g_jobs_tx, j);
                }
                printf("feeder: sent %d jobs\n", NUM_JOBS);
            });
        }
        /* jobs closed â†’ workers drain and exit. */
    }

    /* Count completed jobs by draining done channel. */
    chan_close(g_done_tx);
    int jobs_done = 0;
    int v;
    while (chan_recv(g_done_rx, &v) == 0) {
        jobs_done++;
    }

    chan_free(g_jobs_tx);
    chan_free(g_done_tx);
    printf("done, jobs_done = %d\n", jobs_done);
    return (jobs_done == NUM_JOBS) ? 0 : 1;
}

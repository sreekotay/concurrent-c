/*
 * Recipe: Capture Semantics
 *
 * Demonstrates:
 *   - Implicit value capture (default behavior)
 *   - Closures capture by value — original variable unaffected
 *   - Reference capture [&x] for read-only sharing
 *   - Why mutation of shared references requires safety mechanisms
 *
 * See spec §9.5 for full capture rules.
 */
#include <ccc/cc_runtime.cch>
#include <stdio.h>

int main(void) {
    int snapshot = 42;
    int counter = 0;

    printf("=== Value Capture (default) ===\n");
    printf("before: snapshot = %d\n", snapshot);
    
    /*
     * Value capture: closure gets a COPY of the variable.
     * The copy is immutable within the closure.
     * Original variable is unaffected by closure execution.
     */
    @nursery {
        /* Implicit value capture of 'snapshot' */
        spawn(() => {
            printf("task A sees snapshot = %d\n", snapshot);
            /* snapshot++; would be ERROR: cannot modify value-captured variable */
        });

        spawn(() => {
            printf("task B sees snapshot = %d\n", snapshot);
        });
    }
    
    printf("after: snapshot still = %d (unchanged by tasks)\n\n", snapshot);

    printf("=== Reference Capture (read-only) ===\n");
    /*
     * Reference capture [&x]: closure sees the SAME variable.
     * Read-only access is always safe.
     */
    counter = 100;
    printf("before: counter = %d\n", counter);
    
    @nursery {
        spawn(() => [&counter] {
            printf("task C reads counter = %d (via reference)\n", counter);
        });
    }
    
    printf("after: counter = %d\n\n", counter);

    printf("=== Why Mutation Requires Safety ===\n");
    /*
     * Mutation with reference capture is NOT allowed by default:
     *
     *   spawn(() => [&counter] { counter++; });
     *   // error: mutation of shared reference 'counter' in spawned task
     *   // help: use Atomic<int>, Mutex<int>, or @unsafe [&counter]
     *
     * This prevents accidental data races. Safe alternatives:
     *   1. @atomic int counter;         — hardware atomic ops
     *   2. Mutex<int> counter;          — lock-based safety
     *   3. @unsafe () => [&counter]     — opt-out (you own the race)
     *   4. Channels                     — message passing instead of sharing
     *   5. Result array                 — each task owns its slot
     */
    printf("See recipe_fanout_capture.ccs for the result-array pattern.\n");
    printf("See recipe_channel_pipeline.ccs for the channel pattern.\n");

    return 0;
}

/*
 * Test: Deadlock Detection DEMO
 *
 * NOTE: This is a DEMONSTRATION test that intentionally deadlocks.
 * It is EXPECTED to fail/abort in stress test runs (exit code 124).
 *
 * This test creates a deadlock pattern that is automatically detected
 * by the fiber scheduler's integrated deadlock detection.
 *
 * The pattern: cc_block_on inside spawn with channel ops that wait on each other.
 * 
 * Expected behavior:
 * - By default: detects deadlock and aborts with exit code 124
 * - With CC_DEADLOCK_ABORT=0: prints warning but continues (hangs forever)
 */
#include <ccc/cc_runtime.cch>
#include <ccc/std/task_intptr.cch>
#include <stdio.h>

@async int producer(CCChanTx tx) {
    printf("Producer: about to send...\n");
    int val = 42;
    intptr_t rc = await tx.send(val);
    printf("Producer: sent! rc=%ld\n", (long)rc);
    return 1;
}

@async int consumer(CCChanRx rx) {
    printf("Consumer: about to recv...\n");
    int v = 0;
    intptr_t rc = await rx.recv(&v);
    printf("Consumer: received %d, rc=%ld\n", v, (long)rc);
    return v;
}

int main(void) {
    printf("Deadlock Detection Test\n");
    printf("========================\n");
    printf("This test creates an intentional deadlock.\n");
    printf("Set CC_DEADLOCK_DETECT=0 to disable detection.\n\n");
    
    int[~ >] tx;  /* Unbuffered channel - requires rendezvous */
    int[~ <] rx;
    CCChan* ch = channel_pair(&tx, &rx);
    
    /* THIS IS THE BAD PATTERN */
    /* cc_block_on inside spawn blocks the spawn's thread,
       and with no receiver, the send will deadlock */
    
    @nursery {
        /* Producer spawn - blocks on cc_block_on waiting for send (no receiver exists) */
        spawn(() => {
            int r = cc_block_on(int, producer(tx));  /* Blocks this thread! */
            (void)r;
        });
    }
    
    /* Never reached - deadlock above */
    printf("Completed!\n");
    cc_chan_free(ch);
    return 0;
}

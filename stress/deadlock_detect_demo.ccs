/*
 * Test: Deadlock Detection
 *
 * This test intentionally creates a deadlock pattern that should be detected
 * by the runtime deadlock watchdog (enabled by default).
 *
 * The pattern: cc_block_on inside spawn with channel ops that wait on each other.
 * 
 * Expected behavior:
 * - By default: prints deadlock warning after ~3 seconds
 * - With CC_DEADLOCK_DETECT=0: hangs forever
 */
#include "cc_runtime.cch"
#include "std/task_intptr.cch"
#include <stdio.h>

@async int producer(CCChanTx tx) {
    printf("Producer: about to send...\n");
    int val = 42;
    intptr_t rc = await tx.send(val);
    printf("Producer: sent! rc=%ld\n", (long)rc);
    return 1;
}

@async int consumer(CCChanRx rx) {
    printf("Consumer: about to recv...\n");
    int v = 0;
    intptr_t rc = await rx.recv(&v);
    printf("Consumer: received %d, rc=%ld\n", v, (long)rc);
    return v;
}

int main(void) {
    printf("Deadlock Detection Test\n");
    printf("========================\n");
    printf("This test creates an intentional deadlock.\n");
    printf("Set CC_DEADLOCK_DETECT=0 to disable detection.\n\n");
    
    int[~ >] tx;  /* Unbuffered channel - requires rendezvous */
    int[~ <] rx;
    CCChan* ch = channel_pair(&tx, &rx);
    
    /* THIS IS THE BAD PATTERN */
    /* cc_block_on inside spawn blocks the spawn's thread,
       and with no receiver, the send will deadlock */
    
    @nursery {
        /* Producer spawn - blocks on cc_block_on waiting for send (no receiver exists) */
        spawn(() => {
            int r = cc_block_on(int, producer(tx));  /* Blocks this thread! */
            (void)r;
        });
    }
    
    /* Never reached - deadlock above */
    printf("Completed!\n");
    cc_chan_free(ch);
    return 0;
}

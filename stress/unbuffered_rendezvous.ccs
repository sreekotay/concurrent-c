/*
 * Stress Test: Unbuffered Rendezvous
 *
 * Tests unbuffered (rendezvous) channels under heavy concurrent load.
 * Each send must synchronize with a receive.
 */
#include "cc_runtime.cch"
#include "cc_atomic.cch"
#include "std/task_intptr.cch"
#include <stdio.h>

#define NUM_PAIRS 50
#define MSGS_PER_PAIR 100

cc_atomic_int g_total_sent = 0;
cc_atomic_int g_total_received = 0;
cc_atomic_int g_checksum_sent = 0;
cc_atomic_int g_checksum_received = 0;

@async int recv_task(int[~ <] rx) {
    int val = 0;
    for (int i = 0; i < MSGS_PER_PAIR; i++) {
        intptr_t rc = await rx.recv(&val);
        if (rc == 0) {
            cc_atomic_fetch_add(&g_total_received, 1);
            cc_atomic_fetch_add(&g_checksum_received, val);
        } else {
            return -1;
        }
    }
    return 0;
}

@async int send_task(int[~ >] tx, int sender_id) {
    for (int i = 0; i < MSGS_PER_PAIR; i++) {
        int val = sender_id * 1000 + i;
        intptr_t rc = await tx.send(val);
        if (rc != 0) {
            return -1;
        }
        cc_atomic_fetch_add(&g_total_sent, 1);
        cc_atomic_fetch_add(&g_checksum_sent, val);
    }
    return 0;
}

/* Global unbuffered channel for many-to-many test */
int[~ >] g_tx;  /* Unbuffered */
int[~ <] g_rx;
CCChan* g_ch;

int main(void) {
    printf("unbuffered_rendezvous: %d pairs x %d msgs\n", NUM_PAIRS, MSGS_PER_PAIR);

    g_ch = channel_pair(&g_tx, &g_rx);

    CCTaskIntptr tasks[NUM_PAIRS * 2];
    intptr_t results[NUM_PAIRS * 2];
    int task_count = 0;

    /* Receivers */
    for (int r = 0; r < NUM_PAIRS; r++) {
        tasks[task_count++] = recv_task(g_rx);
    }
    /* Senders */
    for (int s = 0; s < NUM_PAIRS; s++) {
        tasks[task_count++] = send_task(g_tx, s);
    }

    int err = cc_block_all(task_count, tasks, results);
    if (err != 0) {
        printf("ERROR: cc_block_all failed with err=%d\n", err);
        cc_chan_free(g_ch);
        return 1;
    }

    chan_close(g_tx);
    cc_chan_free(g_ch);

    int sent = cc_atomic_load(&g_total_sent);
    int received = cc_atomic_load(&g_total_received);
    int chk_sent = cc_atomic_load(&g_checksum_sent);
    int chk_recv = cc_atomic_load(&g_checksum_received);
    int expected = NUM_PAIRS * MSGS_PER_PAIR;

    printf("unbuffered_rendezvous: sent=%d, received=%d (expected=%d)\n",
           sent, received, expected);
    printf("unbuffered_rendezvous: checksum sent=%d, received=%d\n",
           chk_sent, chk_recv);

    if (sent != expected) {
        printf("ERROR: sent count mismatch\n");
        return 1;
    }
    if (received != expected) {
        printf("ERROR: received count mismatch\n");
        return 2;
    }
    if (chk_sent != chk_recv) {
        printf("ERROR: checksum mismatch (data corruption)\n");
        return 3;
    }

    printf("unbuffered_rendezvous: PASS\n");
    return 0;
}

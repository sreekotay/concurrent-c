/*
 * Stress Test: Fan-out / Fan-in
 *
 * Single producer fans out to multiple workers,
 * workers fan results back to single collector.
 * Classic scatter-gather pattern under load.
 */
#include <ccc/cc_runtime.cch>
#include <ccc/cc_atomic.cch>
#include <stdio.h>

/* Reduced numbers for stress test reliability */
static const int NUM_WORKERS = 2;
static const int NUM_ITEMS = 20;

cc_atomic_int g_collected = 0;
cc_atomic_i64 g_sum = 0;

int main(void) {
    printf("fanout_fanin: %d workers, %d items\n", NUM_WORKERS, NUM_ITEMS);

    /* Use unbuffered channels to avoid fiber wake issues with buffered channels */
    int[~ >] work_tx;
    int[~ <] work_rx;
    int[~ >] done_tx;
    int[~ <] done_rx;
    CCChan* work_ch = channel_pair(&work_tx, &work_rx);
    CCChan* done_ch = channel_pair(&done_tx, &done_rx);

    @nursery {
        /* Collector: must run in parallel with workers for unbuffered channels */
        spawn(() => {
            int v;
            while (cc_io_avail(chan_recv(done_rx, &v))) {
                cc_atomic_fetch_add(&g_sum, (int64_t)v);
                cc_atomic_fetch_add(&g_collected, 1);
            }
        });

        /* Workers: receive, process, send result */
        @nursery closing(done_tx) {
            for (int w = 0; w < NUM_WORKERS; w++) {
                spawn(() => {
                    int v;
                    while (cc_io_avail(chan_recv(work_rx, &v))) {
                        /* "Process" by squaring */
                        int result = v * v;
                        (void)chan_send(done_tx, result);
                    }
                });
            }

            /* Producer: fan out work items */
            @nursery closing(work_tx) {
                spawn(() => {
                    for (int i = 0; i < NUM_ITEMS; i++) {
                        (void)chan_send(work_tx, i);
                    }
                });
            }
        }
    }

    cc_chan_free(work_ch);
    cc_chan_free(done_ch);

    /* Expected sum of squares: 0^2 + 1^2 + ... + (NUM_ITEMS-1)^2 */
    /* = (n-1)*n*(2n-1)/6 where n=NUM_ITEMS */
    long long n = NUM_ITEMS;
    long long expected = (n - 1) * n * (2 * n - 1) / 6;

    int collected = cc_atomic_load(&g_collected);
    long long sum = cc_atomic_load(&g_sum);
    printf("fanout_fanin: collected %d, sum %lld (expected %lld)\n",
           collected, sum, expected);
    return (collected == NUM_ITEMS && sum == expected) ? 0 : 1;
}

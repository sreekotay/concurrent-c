/*
 * Stress Test: Channel Flood
 *
 * Many producers flooding messages to a single consumer.
 * Tests channel backpressure and throughput under contention.
 */
#include "cc_runtime.cch"
#include <stdio.h>

#define NUM_PRODUCERS 10
#define MSGS_PER_PRODUCER 1000
#define CHAN_CAPACITY 16

int g_received = 0;

int main(void) {
    int[~CHAN_CAPACITY >] tx;
    int[~CHAN_CAPACITY <] rx;
    CCChan* ch = channel_pair(&tx, &rx);

    printf("channel_flood: %d producers x %d msgs = %d total\n",
           NUM_PRODUCERS, MSGS_PER_PRODUCER, NUM_PRODUCERS * MSGS_PER_PRODUCER);

    @nursery {
        /* Consumer: count all received messages */
        spawn(() => {
            int v;
            while (chan_recv(rx, &v) == 0) {
                g_received++;
            }
        });

        /* Producers */
        @nursery closing(tx) {
            for (int p = 0; p < NUM_PRODUCERS; p++) {
                spawn(() => {
                    for (int i = 0; i < MSGS_PER_PRODUCER; i++) {
                        chan_send(tx, i);
                    }
                });
            }
        }
    }

    cc_chan_free(ch);

    int expected = NUM_PRODUCERS * MSGS_PER_PRODUCER;
    printf("channel_flood: received %d/%d\n", g_received, expected);
    return (g_received == expected) ? 0 : 1;
}

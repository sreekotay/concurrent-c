/*
 * Stress Test: Channel Flood
 *
 * Many producers flooding messages to a single consumer.
 * Tests channel backpressure and throughput under contention.
 */
#include <ccc/cc_runtime.cch>
#include <ccc/cc_atomic.cch>
#include <stdio.h>

cc_atomic_int g_received = 0;

int main(void) {
    int num_producers = 4;
    int msgs_per = 25;
    int total_msgs = num_producers * msgs_per;
    
    /* Use unbuffered channel */
    int[~ >] tx;
    int[~ <] rx;
    CCChan* ch = channel_pair(&tx, &rx);

    printf("channel_flood: %d producers x %d msgs = %d total\n",
           num_producers, msgs_per, total_msgs);

    @nursery {
        /* Consumer */
        spawn(() => {
            int v;
            while (cc_io_avail(chan_recv(rx, &v))) {
                cc_atomic_fetch_add(&g_received, 1);
            }
        });

        /* Producers */
        @nursery closing(tx) {
            for (int p = 0; p < num_producers; p++) {
                int n = msgs_per;  /* Capture local copy */
                spawn(() => [n] {
                    for (int i = 0; i < n; i++) {
                        (void)chan_send(tx, i);
                    }
                });
            }
        }
    }

    cc_chan_free(ch);

    int recv_count = cc_atomic_load(&g_received);
    printf("channel_flood: received %d/%d\n", recv_count, total_msgs);
    return (recv_count == total_msgs) ? 0 : 1;
}

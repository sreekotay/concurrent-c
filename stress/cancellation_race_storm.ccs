/*
 * cancellation_race_storm.ccs - Target Nursery Teardown Edge Cases
 *
 * This test attempts to find "zombie fibers" or crashes by spawning
 * fibers at the exact moment a nursery is being cancelled or exiting.
 * Uses the raw API to avoid @nursery sugar hiding the pointer.
 */

#include <ccc/cc_runtime.cch>
#include <ccc/cc_atomic.cch>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define NUM_SPAWNERS 4
#define SPAWNS_PER_ITER 1000
#define NUM_ITERS 50

cc_atomic_int g_fibers_started = 0;
cc_atomic_int g_fibers_finished = 0;

void short_lived_fiber() {
    cc_atomic_fetch_add(&g_fibers_started, 1);
    // Yield to increase chance of being caught in teardown
    cc_sleep_ms(0);
    cc_atomic_fetch_add(&g_fibers_finished, 1);
}

void spawner_fiber(void* n_ptr) {
    CCNursery* n = (CCNursery*)n_ptr;
    for (int i = 0; i < SPAWNS_PER_ITER; i++) {
        // Hammer the nursery while it's being cancelled!
        (void)cc_nursery_spawn(n, (void* (*)(void*))short_lived_fiber, NULL);
    }
}

int main(void) {
    setvbuf(stdout, NULL, _IONBF, 0);
    
    printf("=================================================================\n");
    printf("CANCELLATION RACE STORM: Hunting for Zombie Fibers\n");
    printf("Spawners: %d | Spawns per iter: %d | Iters: %d\n", NUM_SPAWNERS, SPAWNS_PER_ITER, NUM_ITERS);
    printf("=================================================================\n\n");

    for (int iter = 1; iter <= NUM_ITERS; iter++) {
        cc_atomic_store(&g_fibers_started, 0);
        cc_atomic_store(&g_fibers_finished, 0);

        printf("\rIteration %d/%d...", iter, NUM_ITERS);

        CCNursery* n = cc_nursery_create();
        if (!n) {
            printf("\nFailed to create nursery!\n");
            return 1;
        }

        @nursery {
            // 1. Start spawners that hammer the target nursery
            for (int s = 0; s < NUM_SPAWNERS; s++) {
                spawn(() => [n] { spawner_fiber(n); });
            }

            // 2. Wait just a tiny bit to get the storm going
            cc_sleep_ms(1);

            // 3. Trigger cancellation on the target nursery
            spawn(() => [n] { 
                cc_sleep_ms(2);
                cc_nursery_cancel(n); 
            });
        }

        // 4. Wait for the target nursery to finish and clean up
        cc_nursery_wait(n);
        cc_nursery_free(n);

        //  verification
        int started = cc_atomic_load(&g_fibers_started);
        int finished = cc_atomic_load(&g_fibers_finished);
        
        if (started != finished) {
            printf("\n\n!!! FAILURE DETECTED !!!\n");
            printf("Iteration: %d\n", iter);
            printf("Fibers started:  %d\n", started);
            printf("Fibers finished: %d\n", finished);
            printf("Zombie count:    %d\n", started - finished);
            printf("=================================================================\n");
            return 1;
        }
    }

    printf("\n\nRESULT: PASS - No zombie fibers detected after %d iterations.\n", NUM_ITERS);
    printf("=================================================================\n");

    return 0;
}

/*
 * Stress test: work stealing race
 * 
 * Tests the race between:
 * 1. Owner popping from local queue
 * 2. Other workers stealing from the same queue
 * 
 * Creates a burst of work that will overflow local queues
 * and trigger aggressive work stealing.
 */
#include <ccc/cc_runtime.cch>
#include <stdio.h>
#include <stdlib.h>

#if defined(__SANITIZE_THREAD__) || (defined(__has_feature) && __has_feature(thread_sanitizer))
/* Reduced for TSan: still exercises work stealing race but runs faster */
#define BURST_SIZE 100
#define ITERATIONS 8
#else
#define BURST_SIZE 2000
#define ITERATIONS 200
#endif

cc_atomic_int completed = 0;
cc_atomic_int duplicates = 0;
cc_atomic_int* task_ids = NULL;

void* burst_task(void* arg) {
    int id = (int)(intptr_t)arg;
    
    /* Check for duplicate execution (race detection) - fetch_add returns old value */
    int prev = cc_atomic_fetch_add(&task_ids[id], 1);
    if (prev != 0) {
        cc_atomic_fetch_add(&duplicates, 1);
    }
    
    /* Small amount of work */
    for (volatile int i = 0; i < 50; i++) {}
    
    cc_atomic_fetch_add(&completed, 1);
    return NULL;
}

int main(void) {
    printf("work_stealing_race: burst=%d, iterations=%d\n", BURST_SIZE, ITERATIONS);
    
    /* Allocate task_ids array dynamically */
    task_ids = (cc_atomic_int*)calloc(BURST_SIZE, sizeof(cc_atomic_int));
    if (!task_ids) {
        fprintf(stderr, "FAIL: could not allocate task_ids\n");
        return 1;
    }
    
    for (int iter = 0; iter < ITERATIONS; iter++) {
        cc_atomic_store(&completed, 0);
        cc_atomic_store(&duplicates, 0);
        for (int i = 0; i < BURST_SIZE; i++) {
            cc_atomic_store(&task_ids[i], 0);
        }
        
        /* Spawn burst of tasks - will overflow local queue and go to global */
        CCNursery* n = cc_nursery_create();
        for (int i = 0; i < BURST_SIZE; i++) {
            cc_nursery_spawn(n, burst_task, (void*)(intptr_t)i);
        }
        cc_nursery_wait(n);
        cc_nursery_free(n);
        
        int c = cc_atomic_load(&completed);
        int d = cc_atomic_load(&duplicates);
        
        if (c != BURST_SIZE) {
            fprintf(stderr, "FAIL: iter %d: only %d/%d tasks completed\n", iter, c, BURST_SIZE);
            return 1;
        }
        
        if (d > 0) {
            fprintf(stderr, "FAIL: iter %d: %d duplicate executions (RACE!)\n", iter, d);
            return 1;
        }
        
        /* Progress reporting: show every 20 iterations, or at least once if ITERATIONS < 20 */
        if ((iter + 1) % 20 == 0 || (iter + 1 == ITERATIONS && ITERATIONS < 20)) {
            printf("  completed %d/%d\n", iter + 1, ITERATIONS);
        }
    }
    
    free(task_ids);
    printf("work_stealing_race: PASS\n");
    return 0;
}

diff --git a/cc_ast_record.h b/cc_ast_record.h
index 0118ed29..1d4d9769 100644
--- a/cc_ast_record.h
+++ b/cc_ast_record.h
@@ -114,4 +114,17 @@ static void cc_ast_record_return_start(void) {
     tcc_state->cc_nodes[idx].col_end = tok_col + 6;
 }
 
+/* Record a binary expression. Call BEFORE parsing the RHS.
+ * op_tok is the operator token ('+', '-', '*', etc.) */
+static void cc_ast_record_binary_start(int op_tok) {
+    if (!tcc_state) return;
+    cc_ast_record_start(CC_AST_NODE_BINARY);
+    if (tcc_state->cc_node_stack_top < 0) return;
+    int idx = tcc_state->cc_node_stack[tcc_state->cc_node_stack_top];
+    const char *op = get_tok_str(op_tok, NULL);
+    tcc_state->cc_nodes[idx].aux1 = op_tok;
+    tcc_state->cc_nodes[idx].aux_s1 = op ? tcc_strdup(op) : NULL;
+    tcc_state->cc_nodes[idx].col_start = tok_col;
+}
+
 #endif /* CC_AST_RECORD_H */
diff --git a/libtcc.c b/libtcc.c
index cd640caa..fa63f7dd 100644
--- a/libtcc.c
+++ b/libtcc.c
@@ -100,6 +100,9 @@ PUB_FUNC struct CCASTStubRoot* cc_tcc_parse_to_ast(const char* preprocessed_path
     s->cc_last_member_col = 0;
     s->cc_last_rparen_line = 0;
     s->cc_last_rparen_col = 0;
+    s->cc_typedef_map = NULL;
+    s->cc_typedef_map_count = 0;
+    s->cc_typedef_map_cap = 0;
     s->cc_ufcs_seq_line = 0;
     s->cc_ufcs_seq_count = 0;
     s->cc_call_stack = NULL;
@@ -125,6 +128,20 @@ PUB_FUNC struct CCASTStubRoot* cc_tcc_parse_to_ast(const char* preprocessed_path
         tcc_add_include_path(s, cc_inc_env);
         tcc_add_sysinclude_path(s, cc_inc_env);
     }
+    /* User include paths from --cc-flags -I... (colon-separated). */
+    const char* user_inc_env = getenv("CC_USER_INCLUDE_PATH");
+    if (user_inc_env && user_inc_env[0]) {
+        char* paths = tcc_strdup(user_inc_env);
+        char* p = paths;
+        char* tok;
+        while ((tok = strsep(&p, ":")) != NULL) {
+            if (tok[0]) {
+                tcc_add_include_path(s, tok);
+                tcc_add_sysinclude_path(s, tok);
+            }
+        }
+        tcc_free(paths);
+    }
     tcc_add_include_path(s, ".");
     tcc_add_include_path(s, "include");
     tcc_add_include_path(s, "cc/include");
@@ -217,6 +234,9 @@ PUB_FUNC struct CCASTStubRoot* cc_tcc_parse_string_to_ast(const char* source_cod
     s->cc_last_member_col = 0;
     s->cc_last_rparen_line = 0;
     s->cc_last_rparen_col = 0;
+    s->cc_typedef_map = NULL;
+    s->cc_typedef_map_count = 0;
+    s->cc_typedef_map_cap = 0;
     s->cc_ufcs_seq_line = 0;
     s->cc_ufcs_seq_count = 0;
     s->cc_call_stack = NULL;
@@ -242,6 +262,20 @@ PUB_FUNC struct CCASTStubRoot* cc_tcc_parse_string_to_ast(const char* source_cod
         tcc_add_include_path(s, cc_inc_env);
         tcc_add_sysinclude_path(s, cc_inc_env);
     }
+    /* User include paths from --cc-flags -I... (colon-separated). */
+    const char* user_inc_env = getenv("CC_USER_INCLUDE_PATH");
+    if (user_inc_env && user_inc_env[0]) {
+        char* paths = tcc_strdup(user_inc_env);
+        char* p = paths;
+        char* tok;
+        while ((tok = strsep(&p, ":")) != NULL) {
+            if (tok[0]) {
+                tcc_add_include_path(s, tok);
+                tcc_add_sysinclude_path(s, tok);
+            }
+        }
+        tcc_free(paths);
+    }
     tcc_add_include_path(s, ".");
     tcc_add_include_path(s, "include");
     tcc_add_include_path(s, "cc/include");
@@ -1238,6 +1272,15 @@ LIBTCCAPI void tcc_delete(TCCState *s1)
 #endif
     /* free loaded dlls array */
     dynarray_reset(&s1->loaded_dlls, &s1->nb_loaded_dlls);
+#ifdef CONFIG_CC_EXT
+    /* free typedef mapping table */
+    if (s1->cc_typedef_map) {
+        for (int i = 0; i < s1->cc_typedef_map_count; i++) {
+            tcc_free(s1->cc_typedef_map[i].name);
+        }
+        tcc_free(s1->cc_typedef_map);
+    }
+#endif
     tcc_free(s1);
 #ifdef MEM_DEBUG
     tcc_memcheck(-1);
diff --git a/tcc.h b/tcc.h
index 44c83679..4a3579b4 100644
--- a/tcc.h
+++ b/tcc.h
@@ -474,6 +474,19 @@ enum CCASTStubKind {
     CC_AST_NODE_RETURN    = 15,
     CC_AST_NODE_PARAM     = 16,
     CC_AST_NODE_FUNC      = 17, /* function decl/def: aux_s1=name, aux_s2=return type, aux1=attrs */
+    CC_AST_NODE_BINARY    = 18, /* binary expr: aux1=operator token, aux_s1=operator string */
+    CC_AST_NODE_TRY       = 19, /* try expr: unwrap Result or propagate error */
+    CC_AST_NODE_IF        = 20, /* if statement: children are cond, then, [else] */
+    CC_AST_NODE_FOR       = 21, /* for statement: init, cond, incr, body */
+    CC_AST_NODE_WHILE     = 22, /* while statement: cond, body */
+    CC_AST_NODE_UNARY     = 23, /* unary expr: aux_s1=operator (++, --, !, ~, etc), aux1=1 if postfix */
+    CC_AST_NODE_SIZEOF    = 24, /* sizeof expr: aux_s1=type string (if type), child=expr (if expr) */
+    CC_AST_NODE_STRUCT    = 25, /* struct/union def: aux_s1=name, aux1=VT_STRUCT/VT_UNION, children=fields */
+    CC_AST_NODE_STRUCT_FIELD = 26, /* struct field: aux_s1=name, aux_s2=type */
+    CC_AST_NODE_TYPEDEF   = 27, /* typedef: aux_s1=name, aux_s2=type */
+    CC_AST_NODE_INDEX     = 28, /* array index: children are array, index */
+    CC_AST_NODE_ENUM      = 29, /* enum def: aux_s1=name, children=values */
+    CC_AST_NODE_ENUM_VALUE = 30, /* enum value: aux_s1=name, aux2=value */
 };
 
 struct CCASTStubNode {
@@ -967,9 +980,18 @@ struct TCCState {
     char cc_last_recv_type[128]; /* Receiver type name for UFCS (e.g., "Point", "Vec_int") */
     int cc_last_rparen_line;
     int cc_last_rparen_col;
+    
+    /* Mapping from anonymous struct refs to typedef names */
+    struct {
+        Sym *ref;
+        char *name;
+    } *cc_typedef_map;
+    int cc_typedef_map_count;
+    int cc_typedef_map_cap;
     /* CC UFCS disambiguation: per-line occurrence counter for UFCS calls. */
     int cc_ufcs_seq_line;
     int cc_ufcs_seq_count;
+    int cc_ufcs_active; /* Set during UFCS call argument parsing */
     /* CC call stack: indices of recorded CC_AST_NODE_CALL nodes (for nested span end update). */
     int *cc_call_stack;
     int cc_call_stack_top;
diff --git a/tccgen.c b/tccgen.c
index ee5d51a4..2be163c4 100644
--- a/tccgen.c
+++ b/tccgen.c
@@ -49,6 +49,43 @@ ST_DATA SValue *vtop;
 static SValue _vstack[1 + VSTACK_SIZE];
 #define vstack (_vstack + 1)
 
+#ifdef CONFIG_CC_EXT
+/* Register a typedef name for an anonymous struct reference */
+static void cc_register_typedef_name(Sym *ref, const char *name) {
+    if (!tcc_state || !ref || !name) return;
+    /* Check if already registered */
+    for (int i = 0; i < tcc_state->cc_typedef_map_count; i++) {
+        if (tcc_state->cc_typedef_map[i].ref == ref) {
+            /* Update existing */
+            tcc_free(tcc_state->cc_typedef_map[i].name);
+            tcc_state->cc_typedef_map[i].name = tcc_strdup(name);
+            return;
+        }
+    }
+    /* Add new entry */
+    if (tcc_state->cc_typedef_map_count >= tcc_state->cc_typedef_map_cap) {
+        int new_cap = tcc_state->cc_typedef_map_cap ? tcc_state->cc_typedef_map_cap * 2 : 64;
+        tcc_state->cc_typedef_map = tcc_realloc(tcc_state->cc_typedef_map, 
+            new_cap * sizeof(tcc_state->cc_typedef_map[0]));
+        tcc_state->cc_typedef_map_cap = new_cap;
+    }
+    tcc_state->cc_typedef_map[tcc_state->cc_typedef_map_count].ref = ref;
+    tcc_state->cc_typedef_map[tcc_state->cc_typedef_map_count].name = tcc_strdup(name);
+    tcc_state->cc_typedef_map_count++;
+}
+
+/* Look up typedef name for an anonymous struct reference */
+static const char *cc_lookup_typedef_name(Sym *ref) {
+    if (!tcc_state || !ref) return NULL;
+    for (int i = 0; i < tcc_state->cc_typedef_map_count; i++) {
+        if (tcc_state->cc_typedef_map[i].ref == ref) {
+            return tcc_state->cc_typedef_map[i].name;
+        }
+    }
+    return NULL;
+}
+#endif
+
 ST_DATA int nocode_wanted; /* no code generation wanted */
 #define NODATA_WANTED (nocode_wanted > 0) /* no static data output wanted either */
 #define DATA_ONLY_WANTED 0x80000000 /* ON outside of functions and for static initializers */
@@ -2736,8 +2773,18 @@ static void type_to_str(char *buf, int buf_size,
     tstruct:
         pstrcat(buf, buf_size, tstr);
         v = type->ref->v & ~SYM_STRUCT;
-        if (v >= SYM_FIRST_ANOM)
+        if (v >= SYM_FIRST_ANOM) {
+#ifdef CONFIG_CC_EXT
+            /* Check for typedef name for anonymous type */
+            const char *typedef_name = cc_lookup_typedef_name(type->ref);
+            if (typedef_name) {
+                /* Clear "struct " or "union " prefix - use just the typedef name */
+                buf[0] = '\0';
+                pstrcat(buf, buf_size, typedef_name);
+            } else
+#endif
             pstrcat(buf, buf_size, "<anonymous>");
+        }
         else
             pstrcat(buf, buf_size, get_tok_str(v, NULL));
         break;
@@ -3395,6 +3442,10 @@ error:
         if (ds == ss && ds >= 4)
             goto done;
         if (dbt_bt == VT_PTR || sbt_bt == VT_PTR) {
+#ifdef CONFIG_CC_EXT
+            /* Suppress in CC closure bodies - returns will be lowered with proper casts */
+            if (!(tcc_state && tcc_state->cc_in_closure_body > 0))
+#endif
             tcc_warning("cast between pointer and integer of different size");
             if (sbt_bt == VT_PTR) {
                 /* put integer type to allow logical operations below */
@@ -3618,6 +3669,10 @@ static void verify_assign_cast(CType *dt)
             break;
         /* accept implicit pointer to integer cast with warning */
         if (is_integer_btype(sbt)) {
+#ifdef CONFIG_CC_EXT
+            /* Suppress in CC closure bodies - returns will be lowered with proper casts */
+            if (!(tcc_state && tcc_state->cc_in_closure_body > 0))
+#endif
             tcc_warning("assignment makes pointer from integer without a cast");
             break;
         }
@@ -3686,6 +3741,10 @@ static void verify_assign_cast(CType *dt)
     case VT_INT:
     case VT_LLONG:
         if (sbt == VT_PTR || sbt == VT_FUNC) {
+#ifdef CONFIG_CC_EXT
+            /* Suppress in CC closure bodies - returns will be lowered with proper casts */
+            if (!(tcc_state && tcc_state->cc_in_closure_body > 0))
+#endif
             tcc_warning("assignment makes integer from pointer without a cast");
         } else if (sbt == VT_STRUCT) {
             goto case_VT_STRUCT;
@@ -9677,6 +9736,18 @@ static int decl(int l)
                     /* save typedefed type  */
                     /* XXX: test storage specifiers ? */
 #ifdef CONFIG_CC_EXT
+                    /* If this is a typedef for an anonymous struct/union, register the mapping */
+                    {
+                        CType base_type = type;
+                        base_type.t &= ~VT_TYPEDEF;
+                        if ((base_type.t & VT_BTYPE) == VT_STRUCT && base_type.ref) {
+                            int sv = base_type.ref->v & ~SYM_STRUCT;
+                            if (sv >= SYM_FIRST_ANOM) {
+                                /* Anonymous struct - register typedef name */
+                                cc_register_typedef_name(base_type.ref, get_tok_str(v, NULL));
+                            }
+                        }
+                    }
                     /* Record typedef */
                     cc_ast_record_start(CC_AST_NODE_TYPEDEF);
                     if (tcc_state && tcc_state->cc_nodes && tcc_state->cc_node_stack_top >= 0) {

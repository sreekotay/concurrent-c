diff --git a/tcc.h b/tcc.h
index 11111111..22222222 100644
--- a/tcc.h
+++ b/tcc.h
@@ -1219,6 +1219,7 @@
 #define TOK_DOTS    0xa1 /* three dots */
 #define TOK_TWODOTS 0xa2 /* C++ token ? */
 #define TOK_TWOSHARPS 0xa3 /* ## preprocessing token */
 #define TOK_PLCHLDR 0xa4 /* placeholder token as defined in C99 */
+#define TOK_CC_ARROW 0xa5 /* => (CC closure arrow) */
 #define TOK_PPJOIN  (TOK_TWOSHARPS | SYM_FIELD) /* A '##' in a macro to mean pasting */
 #define TOK_SOTYPE  0xa7 /* alias of '(' for parsing sizeof (type) */

diff --git a/tccpp.c b/tccpp.c
index 33333333..44444444 100644
--- a/tccpp.c
+++ b/tccpp.c
@@ -92,6 +92,7 @@ static const unsigned char tok_two_chars[] =
     '^','=', TOK_A_XOR,
     '|','=', TOK_A_OR,
     '-','>', TOK_ARROW,
+    '=','>', TOK_CC_ARROW,
     '.','.', TOK_TWODOTS,
     '#','#', TOK_TWOSHARPS,
     0
 };
@@ -667,6 +668,8 @@ ST_FUNC const char *get_tok_str(int v, CValue *cv)
     case TOK_DOTS:
         return strcpy(p, "...");
+    case TOK_CC_ARROW:
+        return strcpy(p, "=>");
     case TOK_A_SHL:
         return strcpy(p, "<<=");

@@ -3000,6 +3020,21 @@ static void next_nomacro(void)
     case '-':
         PEEKC(c, p);
         if (c == '-') {
             p++;
             tok = TOK_DEC;
         } else if (c == '=') {
             p++;
             tok = TOK_A_SUB;
         } else if (c == '>') {
             p++;
             tok = TOK_ARROW;
         } else {
             tok = '-';
         }
         break;
+
+    case '=':
+        PEEKC(c, p);
+        if (c == '>') {
+            p++;
+            tok = TOK_CC_ARROW;
+        } else if (c == '=') {
+            p++;
+            tok = TOK_EQ;
+        } else {
+            tok = '=';
+        }
+        break;
 
     PARSE2('!', '!', '=', TOK_NE)
-    PARSE2('=', '=', '=', TOK_EQ)
     PARSE2('*', '*', '=', TOK_A_MUL)
     PARSE2('%', '%', '=', TOK_A_MOD)
     PARSE2('^', '^', '=', TOK_A_XOR)

diff --git a/tccgen.c b/tccgen.c
index 55555555..66666666 100644
--- a/tccgen.c
+++ b/tccgen.c
@@ -5798,9 +5798,11 @@ tok_next:
     case TOK_SOTYPE:
     case '(':
         t = tok;
+        int cc_paren_start_line = file ? file->line_num : 0;
         next();
 #ifdef CONFIG_CC_EXT
         /* CC extension: closure literal `() => { ... }` or `() => expr` */
         if (t == '(' && tok == ')') {
             next(); /* consume ')' */
             if (tok == TOK_CC_ARROW) {
                 cc_ast_record_start(CC_AST_NODE_CLOSURE);
+                if (tcc_state && tcc_state->cc_nodes && tcc_state->cc_node_stack_top >= 0) {
+                    int idx = tcc_state->cc_node_stack[tcc_state->cc_node_stack_top];
+                    tcc_state->cc_nodes[idx].line_start = cc_paren_start_line;
+                    tcc_state->cc_nodes[idx].aux_s1 = tcc_strdup("closure0");
+                }
                 next(); /* consume => */
+                int saved_ncw = nocode_wanted;
+                ++nocode_wanted;
                 if (tok == '{') {
-                    /* old: token-skip body */
+                    block(STMT_COMPOUND);
+                    if (tcc_state && tcc_state->cc_nodes && tcc_state->cc_node_stack_top >= 0) {
+                        int idx = tcc_state->cc_node_stack[tcc_state->cc_node_stack_top];
+                        tcc_state->cc_nodes[idx].aux2 = 1;
+                    }
                 } else {
-                    /* old: token-skip expr */
+                    expr_eq();
+                    vpop();
+                    if (tcc_state && tcc_state->cc_nodes && tcc_state->cc_node_stack_top >= 0) {
+                        int idx = tcc_state->cc_node_stack[tcc_state->cc_node_stack_top];
+                        tcc_state->cc_nodes[idx].aux2 = 2;
+                    }
                 }
+                nocode_wanted = saved_ncw;
                 cc_ast_record_end();
                 vpushi(0);
                 break;
             }
             tcc_error("expected '=>' after '()' for closure");
         }
 #endif

/*
 * Run all examples, stress tests, or perf benchmarks.
 *
 * Usage:
 *   ccc run tools/run_all.ccs -- examples   # run all examples
 *   ccc run tools/run_all.ccs -- stress     # run all stress tests (10s timeout)
 *   ccc run tools/run_all.ccs -- perf       # run all perf benchmarks
 *   ccc run tools/run_all.ccs -- all        # run everything
 *
 * This demonstrates the dir and process stdlib modules.
 */

#include <ccc/std/prelude.cch>
#include <unistd.h>

/* Default timeout for stress tests (seconds) */
#define STRESS_TIMEOUT_SEC 10

typedef struct {
    int passed;
    int failed;
    int skipped;
} Stats;

/* Skip files that run indefinitely or exit non-zero by design */
static int should_skip(const char* path) {
    if (strstr(path, "tcp_echo") != NULL) return 1;       /* Server */
    if (strstr(path, "http_get") != NULL) return 1;       /* Needs network */
    if (strstr(path, "worker_pool") != NULL) return 1;    /* Long-running */
    if (strstr(path, "deadlock_detect_demo") != NULL) return 1;  /* Intentional exit(1) */
    return 0;
}

static void run_files(CCArena* arena, const char* pattern, const char* label, Stats* stats, int timeout_sec) {
    printf("\n=== %s ===\n", label);

    CCGlobResult files = cc_glob(arena, pattern);
    size_t n = cc_glob_result_len(&files);
    if (n == 0) {
        printf("  (no files matching %s)\n", pattern);
        return;
    }

    for (size_t i = 0; i < n; i++) {
        const char* path = cc_glob_result_get(&files, i);
        
        if (should_skip(path)) {
            printf("  [%zu/%zu] %s ... SKIP (server/long-running)\n", i + 1, n, path);
            stats->skipped++;
            continue;
        }
        
        printf("  [%zu/%zu] %s ... ", i + 1, n, path);
        fflush(stdout);

        /* Small delay between tests to avoid resource contention */
        usleep(1000);  /* 1ms */

        /* Build args: ccc run [--timeout N] path */
        const char* args[6];
        int argc = 0;
        args[argc++] = "ccc";
        args[argc++] = "run";
        
        char timeout_str[16];
        if (timeout_sec > 0) {
            args[argc++] = "--timeout";
            snprintf(timeout_str, sizeof(timeout_str), "%d", timeout_sec);
            args[argc++] = timeout_str;
        }
        args[argc++] = path;
        args[argc] = NULL;

        /* Use a fresh temp arena for each test to avoid accumulation */
        CCArena test_arena = cc_heap_arena(megabytes(4));
        /* Use absolute path to avoid any path resolution issues */
        char ccc_path[4096];
        if (getcwd(ccc_path, sizeof(ccc_path) - 32)) {
            strcat(ccc_path, "/out/cc/bin/ccc");
        } else {
            strcpy(ccc_path, "./out/cc/bin/ccc");
        }
        CCResultProcessOutputIoError res = cc_process_run(&test_arena, ccc_path, args);

        if (res.is_err) {
            cc_heap_arena_free(&test_arena);
            printf("SKIP (spawn error)\n");
            stats->skipped++;
            continue;
        }

        CCProcessOutput out = res.ok;
        int exit_code = cc_process_output_exit_code(&out);
        
        if (exit_code == 0) {
            printf("OK\n");
            stats->passed++;
        } else if (exit_code == 124) {
            /* 124 = timeout (like GNU timeout) */
            printf("TIMEOUT (>%ds)\n", timeout_sec);
            stats->failed++;
        } else {
            printf("FAIL (exit %d)\n", exit_code);
            /* Print stdout/stderr on failure for debugging */
            const char* out_str = cc_process_output_stdout_str(&out);
            size_t out_len = cc_process_output_stdout_len(&out);
            if (out_len > 0 && out_str) {
                printf("    stdout: %.*s", (int)(out_len > 200 ? 200 : out_len), out_str);
                if (out_len > 200) printf("...(truncated)");
                printf("\n");
            }
            const char* err_str = cc_process_output_stderr_str(&out);
            size_t err_len = cc_process_output_stderr_len(&out);
            if (err_len > 0 && err_str) {
                printf("    stderr: %.*s", (int)(err_len > 200 ? 200 : err_len), err_str);
                if (err_len > 200) printf("...(truncated)");
                printf("\n");
            }
            if (out_len == 0 && err_len == 0) {
                printf("    (no output captured)\n");
            }
            stats->failed++;
        }
        
        cc_heap_arena_free(&test_arena);
    }
}

int main(int argc, char** argv) {
    CCArena arena = cc_heap_arena(megabytes(16));
    Stats stats = {0};

    // Parse args
    int do_examples = 0, do_stress = 0, do_perf = 0;

    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "examples") == 0) do_examples = 1;
        else if (strcmp(argv[i], "stress") == 0) do_stress = 1;
        else if (strcmp(argv[i], "perf") == 0) do_perf = 1;
        else if (strcmp(argv[i], "all") == 0) {
            do_examples = do_stress = do_perf = 1;
        }
    }

    if (!do_examples && !do_stress && !do_perf) {
        printf("Usage: ccc run tools/run_all.ccs -- <category>\n");
        printf("\nCategories:\n");
        printf("  examples  - run all example programs\n");
        printf("  stress    - run all stress tests (%ds timeout)\n", STRESS_TIMEOUT_SEC);
        printf("  perf      - run all performance benchmarks\n");
        printf("  all       - run everything\n");
        return 1;
    }

    printf("Concurrent-C Test Runner\n");

    if (do_examples) {
        run_files(&arena, "examples/*.ccs", "Examples", &stats, 0);  /* No timeout */
    }

    if (do_stress) {
        run_files(&arena, "stress/*.ccs", "Stress Tests", &stats, STRESS_TIMEOUT_SEC);
    }

    if (do_perf) {
        run_files(&arena, "perf/*.ccs", "Performance Benchmarks", &stats, 0);  /* No timeout */
    }

    // Summary
    printf("\n=== Summary ===\n");
    printf("  Passed:  %d\n", stats.passed);
    printf("  Failed:  %d\n", stats.failed);
    printf("  Skipped: %d\n", stats.skipped);
    printf("  Total:   %d\n", stats.passed + stats.failed + stats.skipped);

    cc_heap_arena_free(&arena);
    return stats.failed > 0 ? 1 : 0;
}

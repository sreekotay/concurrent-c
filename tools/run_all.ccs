/*
 * Run all examples, stress tests, or perf benchmarks.
 *
 * Usage:
 *   ccc run tools/run_all.ccs -- examples   # run all examples
 *   ccc run tools/run_all.ccs -- stress     # run all stress tests (10s timeout)
 *   ccc run tools/run_all.ccs -- perf       # run all perf benchmarks
 *   clear       # run everything
 *
 * This demonstrates the dir and process stdlib modules.
 */

#include <ccc/std/prelude.cch>
#include <unistd.h>

/* Default timeout for stress tests (seconds) */
#define STRESS_TIMEOUT_SEC 10

typedef struct {
    int passed;
    int failed;
    int skipped;
} Stats;

static const char* LOG_DIR = "tmp/run_all_logs";

static inline CCSlice slice_from_cstr(const char* s) {
    return cc_slice_from_buffer((void*)s, strlen(s));
}

static void ensure_log_dir(CCArena* arena) {
    const char* args[4];
    int argc = 0;
    args[argc++] = "mkdir";
    args[argc++] = "-p";
    args[argc++] = LOG_DIR;
    args[argc] = NULL;
    (void)cc_process_run(arena, "mkdir", args);
}

static void write_log(CCArena* arena, const char* path, const char* suffix,
                      const char* data, size_t len) {
    if (!data || len == 0) return;
    CCSlice base = cc_path_basename(arena, slice_from_cstr(path));
    // Build "<log_dir>/<basename><suffix>"
    CCString full = cc_string_new(arena);
    cc_string_push(&full, slice_from_cstr(LOG_DIR));
    if (full.len > 0 && ((char*)full.data)[full.len - 1] != cc_path_sep()) {
        cc_string_push_char(&full, cc_path_sep());
    }
    cc_string_push(&full, base);
    cc_string_push(&full, slice_from_cstr(suffix));

    CCFile f;
    if (cc_file_open(&f, (const char*)full.data, "w") == 0) {
        CCSlice slice = cc_slice_from_parts((void*)data, len, CC_SLICE_ID_UNTRACKED, len);
        (void)cc_file_write(&f, slice);
        cc_file_close(&f);
    }
}

/* Returns the expected exit code for a given test path.
 * Most tests expect 0, but some (like deadlock demos) expect 1.
 * Returns -1 if the test should be skipped entirely (like servers). */
static int get_expected_exit_code(const char* path) {
    if (strstr(path, "recipe_tcp_echo") != NULL) return -1;       /* Server */
    if (strstr(path, "deadlock_detect_demo") != NULL) return 1;   /* Expected deadlock abort */
    return 0;
}

static void run_files(CCArena* arena, const char* pattern, const char* label, Stats* stats, int timeout_sec) {
    printf("\n=== %s ===\n", label);

    ensure_log_dir(arena);

    CCGlobResult files = cc_glob(arena, pattern);
    size_t n = cc_glob_result_len(&files);
    if (n == 0) {
        printf("  (no files matching %s)\n", pattern);
        return;
    }

    for (size_t i = 0; i < n; i++) {
        const char* path = cc_glob_result_get(&files, i);
        
        int expected_exit = get_expected_exit_code(path);
        if (expected_exit == -1) {
            printf("  [%zu/%zu] %s ... SKIP (server/long-running)\n", i + 1, n, path);
            stats->skipped++;
            continue;
        }
        
        printf("  [%zu/%zu] %s ... ", i + 1, n, path);
        fflush(stdout);

        /* Small delay between tests to avoid resource contention */
        usleep(1000);  /* 1ms */

        /* Build args: ccc run [--timeout N] path */
        const char* args[6];
        int argc = 0;
        args[argc++] = "ccc";
        args[argc++] = "run";
        
        char timeout_str[16];
        if (timeout_sec > 0) {
            args[argc++] = "--timeout";
            snprintf(timeout_str, sizeof(timeout_str), "%d", timeout_sec);
            args[argc++] = timeout_str;
        }
        args[argc++] = path;
        args[argc] = NULL;

        /* Use a fresh temp arena for each test to avoid accumulation */
        CCArena test_arena = cc_arena_heap(megabytes(4));
        /* Use ccc from PATH */
        CCResultProcessOutputIoError res = cc_process_run(&test_arena, "ccc", args);

        if (cc_is_err(res)) {
            CCIoError err = cc_unwrap_err_as(res, CCIoError);
            cc_arena_free(&test_arena);
            printf("SKIP (spawn error: %s, os=%d)\n", cc_io_error_str(err), err.os_code);
            stats->skipped++;
            continue;
        }

        CCProcessOutput out = cc_unwrap_as(res, CCProcessOutput);
        int exit_code = cc_process_output_exit_code(&out);
        
        if (exit_code == expected_exit) {
            printf("OK%s\n", expected_exit != 0 ? " (expected failure)" : "");
            stats->passed++;
        } else if (exit_code == 124 && expected_exit != 124) {
            /* 124 = timeout (like GNU timeout) */
            printf("TIMEOUT (>%ds)\n", timeout_sec);
            const char* out_str = cc_process_output_stdout_str(&out);
            size_t out_len = cc_process_output_stdout_len(&out);
            const char* err_str = cc_process_output_stderr_str(&out);
            size_t err_len = cc_process_output_stderr_len(&out);
            write_log(&test_arena, path, ".stdout.txt", out_str, out_len);
            write_log(&test_arena, path, ".stderr.txt", err_str, err_len);
            CCSlice base = cc_path_basename(&test_arena, slice_from_cstr(path));
            printf("    logs: %s/%s.stdout.txt, %s/%s.stderr.txt\n",
                   LOG_DIR, (const char*)base.ptr,
                   LOG_DIR, (const char*)base.ptr);
            stats->failed++;
        } else {
            printf("FAIL (exit %d, expected %d)\n", exit_code, expected_exit);
            /* Print stdout/stderr on failure for debugging */
            const char* out_str = cc_process_output_stdout_str(&out);
            size_t out_len = cc_process_output_stdout_len(&out);
            const char* err_str = cc_process_output_stderr_str(&out);
            size_t err_len = cc_process_output_stderr_len(&out);
            write_log(&test_arena, path, ".stdout.txt", out_str, out_len);
            write_log(&test_arena, path, ".stderr.txt", err_str, err_len);
            if (out_len > 0 && out_str) {
                printf("    stdout: %.*s", (int)(out_len > 200 ? 200 : out_len), out_str);
                if (out_len > 200) printf("...(truncated)");
                printf("\n");
            }
            if (err_len > 0 && err_str) {
                printf("    stderr: %.*s", (int)(err_len > 200 ? 200 : err_len), err_str);
                if (err_len > 200) printf("...(truncated)");
                printf("\n");
            }
            if (out_len == 0 && err_len == 0) {
                printf("    (no output captured)\n");
            }
            CCSlice base = cc_path_basename(&test_arena, slice_from_cstr(path));
            printf("    logs: %s/%s.stdout.txt, %s/%s.stderr.txt\n",
                   LOG_DIR, (const char*)base.ptr,
                   LOG_DIR, (const char*)base.ptr);
            stats->failed++;
        }
        
        cc_arena_free(&test_arena);
    }
}

int main(int argc, char** argv) {
    CCArena arena = cc_arena_heap(megabytes(16));
    Stats stats = {0};

    // Parse args
    int do_examples = 0, do_stress = 0, do_perf = 0;

    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "examples") == 0) do_examples = 1;
        else if (strcmp(argv[i], "stress") == 0) do_stress = 1;
        else if (strcmp(argv[i], "perf") == 0) do_perf = 1;
        else if (strcmp(argv[i], "all") == 0) {
            do_examples = do_stress = do_perf = 1;
        }
    }

    if (!do_examples && !do_stress && !do_perf) {
        printf("Usage: ccc run tools/run_all.ccs -- <category>\n");
        printf("\nCategories:\n");
        printf("  examples  - run all example programs\n");
        printf("  stress    - run all stress tests (%ds timeout)\n", STRESS_TIMEOUT_SEC);
        printf("  perf      - run all performance benchmarks\n");
        printf("  all       - run everything\n");
        return 1;
    }

    printf("Concurrent-C Test Runner\n");

    if (do_examples) {
        run_files(&arena, "examples/*.ccs", "Examples", &stats, 0);  /* No timeout */
    }

    if (do_stress) {
        run_files(&arena, "stress/*.ccs", "Stress Tests", &stats, STRESS_TIMEOUT_SEC);
    }

    if (do_perf) {
        run_files(&arena, "perf/*.ccs", "Performance Benchmarks", &stats, 0);  /* No timeout */
    }

    // Summary
    printf("\n=== Summary ===\n");
    printf("  Passed:  %d\n", stats.passed);
    printf("  Failed:  %d\n", stats.failed);
    printf("  Skipped: %d\n", stats.skipped);
    printf("  Total:   %d\n", stats.passed + stats.failed + stats.skipped);

    cc_arena_free(&arena);
    return stats.failed > 0 ? 1 : 0;
}

/*
 * Run all examples, stress tests, or perf benchmarks.
 *
 * Usage:
 *   ccc run tools/run_all.ccs -- examples   # run all examples
 *   ccc run tools/run_all.ccs -- stress     # run all stress tests
 *   ccc run tools/run_all.ccs -- perf       # run all perf benchmarks
 *   ccc run tools/run_all.ccs -- all        # run everything
 *
 * This demonstrates the dir and process stdlib modules.
 */

#include <ccc/std/prelude.cch>

typedef struct {
    int passed;
    int failed;
    int skipped;
} Stats;

/* Skip files that run indefinitely or exit non-zero by design */
static int should_skip(const char* path) {
    if (strstr(path, "tcp_echo") != NULL) return 1;       /* Server */
    if (strstr(path, "http_get") != NULL) return 1;       /* Needs network */
    if (strstr(path, "worker_pool") != NULL) return 1;    /* Long-running */
    if (strstr(path, "deadlock_detect_demo") != NULL) return 1;  /* Intentional exit(1) */
    return 0;
}

static void run_files(CCArena* arena, const char* pattern, const char* label, Stats* stats) {
    printf("\n=== %s ===\n", label);

    CCGlobResult files = cc_glob(arena, pattern);
    size_t n = cc_glob_result_len(&files);
    if (n == 0) {
        printf("  (no files matching %s)\n", pattern);
        return;
    }

    for (size_t i = 0; i < n; i++) {
        const char* path = cc_glob_result_get(&files, i);
        
        if (should_skip(path)) {
            printf("  [%zu/%zu] %s ... SKIP (server/long-running)\n", i + 1, n, path);
            stats->skipped++;
            continue;
        }
        
        printf("  [%zu/%zu] %s ... ", i + 1, n, path);
        fflush(stdout);

        const char* args[] = {"ccc", "run", path, NULL};
        CCResultProcessOutputIoError res = cc_process_run(arena, "./out/cc/bin/ccc", args);

        if (res.is_err) {
            printf("SKIP (spawn error)\n");
            stats->skipped++;
            continue;
        }

        CCProcessOutput out = res.ok;
        if (cc_process_output_success(&out)) {
            printf("OK\n");
            stats->passed++;
        } else {
            printf("FAIL (exit %d)\n", cc_process_output_exit_code(&out));
            stats->failed++;
            // Show first few lines of output on failure
            size_t errlen = cc_process_output_stderr_len(&out);
            if (errlen > 0) {
                printf("    stderr: %.*s\n",
                       (int)(errlen > 200 ? 200 : errlen),
                       cc_process_output_stderr_str(&out));
            }
        }
    }
}

int main(int argc, char** argv) {
    CCArena arena = cc_heap_arena(megabytes(16));
    Stats stats = {0};

    // Parse args
    int do_examples = 0, do_stress = 0, do_perf = 0;

    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "examples") == 0) do_examples = 1;
        else if (strcmp(argv[i], "stress") == 0) do_stress = 1;
        else if (strcmp(argv[i], "perf") == 0) do_perf = 1;
        else if (strcmp(argv[i], "all") == 0) {
            do_examples = do_stress = do_perf = 1;
        }
    }

    if (!do_examples && !do_stress && !do_perf) {
        printf("Usage: ccc run tools/run_all.ccs -- <category>\n");
        printf("\nCategories:\n");
        printf("  examples  - run all example programs\n");
        printf("  stress    - run all stress tests\n");
        printf("  perf      - run all performance benchmarks\n");
        printf("  all       - run everything\n");
        return 1;
    }

    printf("Concurrent-C Test Runner\n");

    if (do_examples) {
        run_files(&arena, "examples/*.ccs", "Examples", &stats);
    }

    if (do_stress) {
        run_files(&arena, "stress/*.ccs", "Stress Tests", &stats);
    }

    if (do_perf) {
        run_files(&arena, "perf/*.ccs", "Performance Benchmarks", &stats);
    }

    // Summary
    printf("\n=== Summary ===\n");
    printf("  Passed:  %d\n", stats.passed);
    printf("  Failed:  %d\n", stats.failed);
    printf("  Skipped: %d\n", stats.skipped);
    printf("  Total:   %d\n", stats.passed + stats.failed + stats.skipped);

    cc_heap_arena_free(&arena);
    return stats.failed > 0 ? 1 : 0;
}
